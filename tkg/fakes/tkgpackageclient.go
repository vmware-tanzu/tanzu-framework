// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	v1 "k8s.io/api/core/v1"

	v1alpha1a "github.com/vmware-tanzu/carvel-kapp-controller/pkg/apis/packaging/v1alpha1"
	"github.com/vmware-tanzu/carvel-kapp-controller/pkg/apiserver/apis/datapackaging/v1alpha1"
	v1alpha1b "github.com/vmware-tanzu/carvel-secretgen-controller/pkg/apis/secretgen2/v1alpha1"
	"github.com/vmware-tanzu/tanzu-framework/tkg/tkgpackageclient"
	"github.com/vmware-tanzu/tanzu-framework/tkg/tkgpackagedatamodel"
)

type TKGPackageClient struct {
	AddRegistrySecretStub        func(*tkgpackagedatamodel.RegistrySecretOptions) error
	addRegistrySecretMutex       sync.RWMutex
	addRegistrySecretArgsForCall []struct {
		arg1 *tkgpackagedatamodel.RegistrySecretOptions
	}
	addRegistrySecretReturns struct {
		result1 error
	}
	addRegistrySecretReturnsOnCall map[int]struct {
		result1 error
	}
	AddRepositoryStub        func(*tkgpackagedatamodel.RepositoryOptions, *tkgpackagedatamodel.PackageProgress, tkgpackagedatamodel.OperationType)
	addRepositoryMutex       sync.RWMutex
	addRepositoryArgsForCall []struct {
		arg1 *tkgpackagedatamodel.RepositoryOptions
		arg2 *tkgpackagedatamodel.PackageProgress
		arg3 tkgpackagedatamodel.OperationType
	}
	AddRepositorySyncStub        func(*tkgpackagedatamodel.RepositoryOptions, tkgpackagedatamodel.OperationType) error
	addRepositorySyncMutex       sync.RWMutex
	addRepositorySyncArgsForCall []struct {
		arg1 *tkgpackagedatamodel.RepositoryOptions
		arg2 tkgpackagedatamodel.OperationType
	}
	addRepositorySyncReturns struct {
		result1 error
	}
	addRepositorySyncReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteRegistrySecretStub        func(*tkgpackagedatamodel.RegistrySecretOptions) (bool, error)
	deleteRegistrySecretMutex       sync.RWMutex
	deleteRegistrySecretArgsForCall []struct {
		arg1 *tkgpackagedatamodel.RegistrySecretOptions
	}
	deleteRegistrySecretReturns struct {
		result1 bool
		result2 error
	}
	deleteRegistrySecretReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	DeleteRepositoryStub        func(*tkgpackagedatamodel.RepositoryOptions, *tkgpackagedatamodel.PackageProgress)
	deleteRepositoryMutex       sync.RWMutex
	deleteRepositoryArgsForCall []struct {
		arg1 *tkgpackagedatamodel.RepositoryOptions
		arg2 *tkgpackagedatamodel.PackageProgress
	}
	DeleteRepositorySyncStub        func(*tkgpackagedatamodel.RepositoryOptions) error
	deleteRepositorySyncMutex       sync.RWMutex
	deleteRepositorySyncArgsForCall []struct {
		arg1 *tkgpackagedatamodel.RepositoryOptions
	}
	deleteRepositorySyncReturns struct {
		result1 error
	}
	deleteRepositorySyncReturnsOnCall map[int]struct {
		result1 error
	}
	GetPackageStub        func(*tkgpackagedatamodel.PackageOptions) (*v1alpha1.PackageMetadata, *v1alpha1.Package, error)
	getPackageMutex       sync.RWMutex
	getPackageArgsForCall []struct {
		arg1 *tkgpackagedatamodel.PackageOptions
	}
	getPackageReturns struct {
		result1 *v1alpha1.PackageMetadata
		result2 *v1alpha1.Package
		result3 error
	}
	getPackageReturnsOnCall map[int]struct {
		result1 *v1alpha1.PackageMetadata
		result2 *v1alpha1.Package
		result3 error
	}
	GetPackageInstallStub        func(*tkgpackagedatamodel.PackageOptions) (*v1alpha1a.PackageInstall, error)
	getPackageInstallMutex       sync.RWMutex
	getPackageInstallArgsForCall []struct {
		arg1 *tkgpackagedatamodel.PackageOptions
	}
	getPackageInstallReturns struct {
		result1 *v1alpha1a.PackageInstall
		result2 error
	}
	getPackageInstallReturnsOnCall map[int]struct {
		result1 *v1alpha1a.PackageInstall
		result2 error
	}
	GetRepositoryStub        func(*tkgpackagedatamodel.RepositoryOptions) (*v1alpha1a.PackageRepository, error)
	getRepositoryMutex       sync.RWMutex
	getRepositoryArgsForCall []struct {
		arg1 *tkgpackagedatamodel.RepositoryOptions
	}
	getRepositoryReturns struct {
		result1 *v1alpha1a.PackageRepository
		result2 error
	}
	getRepositoryReturnsOnCall map[int]struct {
		result1 *v1alpha1a.PackageRepository
		result2 error
	}
	GetSecretExportStub        func(*tkgpackagedatamodel.RegistrySecretOptions) (*v1alpha1b.SecretExport, error)
	getSecretExportMutex       sync.RWMutex
	getSecretExportArgsForCall []struct {
		arg1 *tkgpackagedatamodel.RegistrySecretOptions
	}
	getSecretExportReturns struct {
		result1 *v1alpha1b.SecretExport
		result2 error
	}
	getSecretExportReturnsOnCall map[int]struct {
		result1 *v1alpha1b.SecretExport
		result2 error
	}
	InstallPackageStub        func(*tkgpackagedatamodel.PackageOptions, *tkgpackagedatamodel.PackageProgress, tkgpackagedatamodel.OperationType)
	installPackageMutex       sync.RWMutex
	installPackageArgsForCall []struct {
		arg1 *tkgpackagedatamodel.PackageOptions
		arg2 *tkgpackagedatamodel.PackageProgress
		arg3 tkgpackagedatamodel.OperationType
	}
	InstallPackageSyncStub        func(*tkgpackagedatamodel.PackageOptions, tkgpackagedatamodel.OperationType) error
	installPackageSyncMutex       sync.RWMutex
	installPackageSyncArgsForCall []struct {
		arg1 *tkgpackagedatamodel.PackageOptions
		arg2 tkgpackagedatamodel.OperationType
	}
	installPackageSyncReturns struct {
		result1 error
	}
	installPackageSyncReturnsOnCall map[int]struct {
		result1 error
	}
	ListPackageInstallsStub        func(*tkgpackagedatamodel.PackageOptions) (*v1alpha1a.PackageInstallList, error)
	listPackageInstallsMutex       sync.RWMutex
	listPackageInstallsArgsForCall []struct {
		arg1 *tkgpackagedatamodel.PackageOptions
	}
	listPackageInstallsReturns struct {
		result1 *v1alpha1a.PackageInstallList
		result2 error
	}
	listPackageInstallsReturnsOnCall map[int]struct {
		result1 *v1alpha1a.PackageInstallList
		result2 error
	}
	ListPackageMetadataStub        func(*tkgpackagedatamodel.PackageAvailableOptions) (*v1alpha1.PackageMetadataList, error)
	listPackageMetadataMutex       sync.RWMutex
	listPackageMetadataArgsForCall []struct {
		arg1 *tkgpackagedatamodel.PackageAvailableOptions
	}
	listPackageMetadataReturns struct {
		result1 *v1alpha1.PackageMetadataList
		result2 error
	}
	listPackageMetadataReturnsOnCall map[int]struct {
		result1 *v1alpha1.PackageMetadataList
		result2 error
	}
	ListPackagesStub        func(*tkgpackagedatamodel.PackageAvailableOptions) (*v1alpha1.PackageList, error)
	listPackagesMutex       sync.RWMutex
	listPackagesArgsForCall []struct {
		arg1 *tkgpackagedatamodel.PackageAvailableOptions
	}
	listPackagesReturns struct {
		result1 *v1alpha1.PackageList
		result2 error
	}
	listPackagesReturnsOnCall map[int]struct {
		result1 *v1alpha1.PackageList
		result2 error
	}
	ListRegistrySecretsStub        func(*tkgpackagedatamodel.RegistrySecretOptions) (*v1.SecretList, error)
	listRegistrySecretsMutex       sync.RWMutex
	listRegistrySecretsArgsForCall []struct {
		arg1 *tkgpackagedatamodel.RegistrySecretOptions
	}
	listRegistrySecretsReturns struct {
		result1 *v1.SecretList
		result2 error
	}
	listRegistrySecretsReturnsOnCall map[int]struct {
		result1 *v1.SecretList
		result2 error
	}
	ListRepositoriesStub        func(*tkgpackagedatamodel.RepositoryOptions) (*v1alpha1a.PackageRepositoryList, error)
	listRepositoriesMutex       sync.RWMutex
	listRepositoriesArgsForCall []struct {
		arg1 *tkgpackagedatamodel.RepositoryOptions
	}
	listRepositoriesReturns struct {
		result1 *v1alpha1a.PackageRepositoryList
		result2 error
	}
	listRepositoriesReturnsOnCall map[int]struct {
		result1 *v1alpha1a.PackageRepositoryList
		result2 error
	}
	ListSecretExportsStub        func(*tkgpackagedatamodel.RegistrySecretOptions) (*v1alpha1b.SecretExportList, error)
	listSecretExportsMutex       sync.RWMutex
	listSecretExportsArgsForCall []struct {
		arg1 *tkgpackagedatamodel.RegistrySecretOptions
	}
	listSecretExportsReturns struct {
		result1 *v1alpha1b.SecretExportList
		result2 error
	}
	listSecretExportsReturnsOnCall map[int]struct {
		result1 *v1alpha1b.SecretExportList
		result2 error
	}
	UninstallPackageStub        func(*tkgpackagedatamodel.PackageOptions, *tkgpackagedatamodel.PackageProgress)
	uninstallPackageMutex       sync.RWMutex
	uninstallPackageArgsForCall []struct {
		arg1 *tkgpackagedatamodel.PackageOptions
		arg2 *tkgpackagedatamodel.PackageProgress
	}
	UninstallPackageSyncStub        func(*tkgpackagedatamodel.PackageOptions) error
	uninstallPackageSyncMutex       sync.RWMutex
	uninstallPackageSyncArgsForCall []struct {
		arg1 *tkgpackagedatamodel.PackageOptions
	}
	uninstallPackageSyncReturns struct {
		result1 error
	}
	uninstallPackageSyncReturnsOnCall map[int]struct {
		result1 error
	}
	UpdatePackageStub        func(*tkgpackagedatamodel.PackageOptions, *tkgpackagedatamodel.PackageProgress, tkgpackagedatamodel.OperationType)
	updatePackageMutex       sync.RWMutex
	updatePackageArgsForCall []struct {
		arg1 *tkgpackagedatamodel.PackageOptions
		arg2 *tkgpackagedatamodel.PackageProgress
		arg3 tkgpackagedatamodel.OperationType
	}
	UpdatePackageSyncStub        func(*tkgpackagedatamodel.PackageOptions, tkgpackagedatamodel.OperationType) error
	updatePackageSyncMutex       sync.RWMutex
	updatePackageSyncArgsForCall []struct {
		arg1 *tkgpackagedatamodel.PackageOptions
		arg2 tkgpackagedatamodel.OperationType
	}
	updatePackageSyncReturns struct {
		result1 error
	}
	updatePackageSyncReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateRegistrySecretStub        func(*tkgpackagedatamodel.RegistrySecretOptions) error
	updateRegistrySecretMutex       sync.RWMutex
	updateRegistrySecretArgsForCall []struct {
		arg1 *tkgpackagedatamodel.RegistrySecretOptions
	}
	updateRegistrySecretReturns struct {
		result1 error
	}
	updateRegistrySecretReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateRepositoryStub        func(*tkgpackagedatamodel.RepositoryOptions, *tkgpackagedatamodel.PackageProgress, tkgpackagedatamodel.OperationType)
	updateRepositoryMutex       sync.RWMutex
	updateRepositoryArgsForCall []struct {
		arg1 *tkgpackagedatamodel.RepositoryOptions
		arg2 *tkgpackagedatamodel.PackageProgress
		arg3 tkgpackagedatamodel.OperationType
	}
	UpdateRepositorySyncStub        func(*tkgpackagedatamodel.RepositoryOptions, tkgpackagedatamodel.OperationType) error
	updateRepositorySyncMutex       sync.RWMutex
	updateRepositorySyncArgsForCall []struct {
		arg1 *tkgpackagedatamodel.RepositoryOptions
		arg2 tkgpackagedatamodel.OperationType
	}
	updateRepositorySyncReturns struct {
		result1 error
	}
	updateRepositorySyncReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *TKGPackageClient) AddRegistrySecret(arg1 *tkgpackagedatamodel.RegistrySecretOptions) error {
	fake.addRegistrySecretMutex.Lock()
	ret, specificReturn := fake.addRegistrySecretReturnsOnCall[len(fake.addRegistrySecretArgsForCall)]
	fake.addRegistrySecretArgsForCall = append(fake.addRegistrySecretArgsForCall, struct {
		arg1 *tkgpackagedatamodel.RegistrySecretOptions
	}{arg1})
	stub := fake.AddRegistrySecretStub
	fakeReturns := fake.addRegistrySecretReturns
	fake.recordInvocation("AddRegistrySecret", []interface{}{arg1})
	fake.addRegistrySecretMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TKGPackageClient) AddRegistrySecretCallCount() int {
	fake.addRegistrySecretMutex.RLock()
	defer fake.addRegistrySecretMutex.RUnlock()
	return len(fake.addRegistrySecretArgsForCall)
}

func (fake *TKGPackageClient) AddRegistrySecretCalls(stub func(*tkgpackagedatamodel.RegistrySecretOptions) error) {
	fake.addRegistrySecretMutex.Lock()
	defer fake.addRegistrySecretMutex.Unlock()
	fake.AddRegistrySecretStub = stub
}

func (fake *TKGPackageClient) AddRegistrySecretArgsForCall(i int) *tkgpackagedatamodel.RegistrySecretOptions {
	fake.addRegistrySecretMutex.RLock()
	defer fake.addRegistrySecretMutex.RUnlock()
	argsForCall := fake.addRegistrySecretArgsForCall[i]
	return argsForCall.arg1
}

func (fake *TKGPackageClient) AddRegistrySecretReturns(result1 error) {
	fake.addRegistrySecretMutex.Lock()
	defer fake.addRegistrySecretMutex.Unlock()
	fake.AddRegistrySecretStub = nil
	fake.addRegistrySecretReturns = struct {
		result1 error
	}{result1}
}

func (fake *TKGPackageClient) AddRegistrySecretReturnsOnCall(i int, result1 error) {
	fake.addRegistrySecretMutex.Lock()
	defer fake.addRegistrySecretMutex.Unlock()
	fake.AddRegistrySecretStub = nil
	if fake.addRegistrySecretReturnsOnCall == nil {
		fake.addRegistrySecretReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addRegistrySecretReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *TKGPackageClient) AddRepository(arg1 *tkgpackagedatamodel.RepositoryOptions, arg2 *tkgpackagedatamodel.PackageProgress, arg3 tkgpackagedatamodel.OperationType) {
	fake.addRepositoryMutex.Lock()
	fake.addRepositoryArgsForCall = append(fake.addRepositoryArgsForCall, struct {
		arg1 *tkgpackagedatamodel.RepositoryOptions
		arg2 *tkgpackagedatamodel.PackageProgress
		arg3 tkgpackagedatamodel.OperationType
	}{arg1, arg2, arg3})
	stub := fake.AddRepositoryStub
	fake.recordInvocation("AddRepository", []interface{}{arg1, arg2, arg3})
	fake.addRepositoryMutex.Unlock()
	if stub != nil {
		fake.AddRepositoryStub(arg1, arg2, arg3)
	}
}

func (fake *TKGPackageClient) AddRepositoryCallCount() int {
	fake.addRepositoryMutex.RLock()
	defer fake.addRepositoryMutex.RUnlock()
	return len(fake.addRepositoryArgsForCall)
}

func (fake *TKGPackageClient) AddRepositoryCalls(stub func(*tkgpackagedatamodel.RepositoryOptions, *tkgpackagedatamodel.PackageProgress, tkgpackagedatamodel.OperationType)) {
	fake.addRepositoryMutex.Lock()
	defer fake.addRepositoryMutex.Unlock()
	fake.AddRepositoryStub = stub
}

func (fake *TKGPackageClient) AddRepositoryArgsForCall(i int) (*tkgpackagedatamodel.RepositoryOptions, *tkgpackagedatamodel.PackageProgress, tkgpackagedatamodel.OperationType) {
	fake.addRepositoryMutex.RLock()
	defer fake.addRepositoryMutex.RUnlock()
	argsForCall := fake.addRepositoryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *TKGPackageClient) AddRepositorySync(arg1 *tkgpackagedatamodel.RepositoryOptions, arg2 tkgpackagedatamodel.OperationType) error {
	fake.addRepositorySyncMutex.Lock()
	ret, specificReturn := fake.addRepositorySyncReturnsOnCall[len(fake.addRepositorySyncArgsForCall)]
	fake.addRepositorySyncArgsForCall = append(fake.addRepositorySyncArgsForCall, struct {
		arg1 *tkgpackagedatamodel.RepositoryOptions
		arg2 tkgpackagedatamodel.OperationType
	}{arg1, arg2})
	stub := fake.AddRepositorySyncStub
	fakeReturns := fake.addRepositorySyncReturns
	fake.recordInvocation("AddRepositorySync", []interface{}{arg1, arg2})
	fake.addRepositorySyncMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TKGPackageClient) AddRepositorySyncCallCount() int {
	fake.addRepositorySyncMutex.RLock()
	defer fake.addRepositorySyncMutex.RUnlock()
	return len(fake.addRepositorySyncArgsForCall)
}

func (fake *TKGPackageClient) AddRepositorySyncCalls(stub func(*tkgpackagedatamodel.RepositoryOptions, tkgpackagedatamodel.OperationType) error) {
	fake.addRepositorySyncMutex.Lock()
	defer fake.addRepositorySyncMutex.Unlock()
	fake.AddRepositorySyncStub = stub
}

func (fake *TKGPackageClient) AddRepositorySyncArgsForCall(i int) (*tkgpackagedatamodel.RepositoryOptions, tkgpackagedatamodel.OperationType) {
	fake.addRepositorySyncMutex.RLock()
	defer fake.addRepositorySyncMutex.RUnlock()
	argsForCall := fake.addRepositorySyncArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *TKGPackageClient) AddRepositorySyncReturns(result1 error) {
	fake.addRepositorySyncMutex.Lock()
	defer fake.addRepositorySyncMutex.Unlock()
	fake.AddRepositorySyncStub = nil
	fake.addRepositorySyncReturns = struct {
		result1 error
	}{result1}
}

func (fake *TKGPackageClient) AddRepositorySyncReturnsOnCall(i int, result1 error) {
	fake.addRepositorySyncMutex.Lock()
	defer fake.addRepositorySyncMutex.Unlock()
	fake.AddRepositorySyncStub = nil
	if fake.addRepositorySyncReturnsOnCall == nil {
		fake.addRepositorySyncReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addRepositorySyncReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *TKGPackageClient) DeleteRegistrySecret(arg1 *tkgpackagedatamodel.RegistrySecretOptions) (bool, error) {
	fake.deleteRegistrySecretMutex.Lock()
	ret, specificReturn := fake.deleteRegistrySecretReturnsOnCall[len(fake.deleteRegistrySecretArgsForCall)]
	fake.deleteRegistrySecretArgsForCall = append(fake.deleteRegistrySecretArgsForCall, struct {
		arg1 *tkgpackagedatamodel.RegistrySecretOptions
	}{arg1})
	stub := fake.DeleteRegistrySecretStub
	fakeReturns := fake.deleteRegistrySecretReturns
	fake.recordInvocation("DeleteRegistrySecret", []interface{}{arg1})
	fake.deleteRegistrySecretMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *TKGPackageClient) DeleteRegistrySecretCallCount() int {
	fake.deleteRegistrySecretMutex.RLock()
	defer fake.deleteRegistrySecretMutex.RUnlock()
	return len(fake.deleteRegistrySecretArgsForCall)
}

func (fake *TKGPackageClient) DeleteRegistrySecretCalls(stub func(*tkgpackagedatamodel.RegistrySecretOptions) (bool, error)) {
	fake.deleteRegistrySecretMutex.Lock()
	defer fake.deleteRegistrySecretMutex.Unlock()
	fake.DeleteRegistrySecretStub = stub
}

func (fake *TKGPackageClient) DeleteRegistrySecretArgsForCall(i int) *tkgpackagedatamodel.RegistrySecretOptions {
	fake.deleteRegistrySecretMutex.RLock()
	defer fake.deleteRegistrySecretMutex.RUnlock()
	argsForCall := fake.deleteRegistrySecretArgsForCall[i]
	return argsForCall.arg1
}

func (fake *TKGPackageClient) DeleteRegistrySecretReturns(result1 bool, result2 error) {
	fake.deleteRegistrySecretMutex.Lock()
	defer fake.deleteRegistrySecretMutex.Unlock()
	fake.DeleteRegistrySecretStub = nil
	fake.deleteRegistrySecretReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *TKGPackageClient) DeleteRegistrySecretReturnsOnCall(i int, result1 bool, result2 error) {
	fake.deleteRegistrySecretMutex.Lock()
	defer fake.deleteRegistrySecretMutex.Unlock()
	fake.DeleteRegistrySecretStub = nil
	if fake.deleteRegistrySecretReturnsOnCall == nil {
		fake.deleteRegistrySecretReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.deleteRegistrySecretReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *TKGPackageClient) DeleteRepository(arg1 *tkgpackagedatamodel.RepositoryOptions, arg2 *tkgpackagedatamodel.PackageProgress) {
	fake.deleteRepositoryMutex.Lock()
	fake.deleteRepositoryArgsForCall = append(fake.deleteRepositoryArgsForCall, struct {
		arg1 *tkgpackagedatamodel.RepositoryOptions
		arg2 *tkgpackagedatamodel.PackageProgress
	}{arg1, arg2})
	stub := fake.DeleteRepositoryStub
	fake.recordInvocation("DeleteRepository", []interface{}{arg1, arg2})
	fake.deleteRepositoryMutex.Unlock()
	if stub != nil {
		fake.DeleteRepositoryStub(arg1, arg2)
	}
}

func (fake *TKGPackageClient) DeleteRepositoryCallCount() int {
	fake.deleteRepositoryMutex.RLock()
	defer fake.deleteRepositoryMutex.RUnlock()
	return len(fake.deleteRepositoryArgsForCall)
}

func (fake *TKGPackageClient) DeleteRepositoryCalls(stub func(*tkgpackagedatamodel.RepositoryOptions, *tkgpackagedatamodel.PackageProgress)) {
	fake.deleteRepositoryMutex.Lock()
	defer fake.deleteRepositoryMutex.Unlock()
	fake.DeleteRepositoryStub = stub
}

func (fake *TKGPackageClient) DeleteRepositoryArgsForCall(i int) (*tkgpackagedatamodel.RepositoryOptions, *tkgpackagedatamodel.PackageProgress) {
	fake.deleteRepositoryMutex.RLock()
	defer fake.deleteRepositoryMutex.RUnlock()
	argsForCall := fake.deleteRepositoryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *TKGPackageClient) DeleteRepositorySync(arg1 *tkgpackagedatamodel.RepositoryOptions) error {
	fake.deleteRepositorySyncMutex.Lock()
	ret, specificReturn := fake.deleteRepositorySyncReturnsOnCall[len(fake.deleteRepositorySyncArgsForCall)]
	fake.deleteRepositorySyncArgsForCall = append(fake.deleteRepositorySyncArgsForCall, struct {
		arg1 *tkgpackagedatamodel.RepositoryOptions
	}{arg1})
	stub := fake.DeleteRepositorySyncStub
	fakeReturns := fake.deleteRepositorySyncReturns
	fake.recordInvocation("DeleteRepositorySync", []interface{}{arg1})
	fake.deleteRepositorySyncMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TKGPackageClient) DeleteRepositorySyncCallCount() int {
	fake.deleteRepositorySyncMutex.RLock()
	defer fake.deleteRepositorySyncMutex.RUnlock()
	return len(fake.deleteRepositorySyncArgsForCall)
}

func (fake *TKGPackageClient) DeleteRepositorySyncCalls(stub func(*tkgpackagedatamodel.RepositoryOptions) error) {
	fake.deleteRepositorySyncMutex.Lock()
	defer fake.deleteRepositorySyncMutex.Unlock()
	fake.DeleteRepositorySyncStub = stub
}

func (fake *TKGPackageClient) DeleteRepositorySyncArgsForCall(i int) *tkgpackagedatamodel.RepositoryOptions {
	fake.deleteRepositorySyncMutex.RLock()
	defer fake.deleteRepositorySyncMutex.RUnlock()
	argsForCall := fake.deleteRepositorySyncArgsForCall[i]
	return argsForCall.arg1
}

func (fake *TKGPackageClient) DeleteRepositorySyncReturns(result1 error) {
	fake.deleteRepositorySyncMutex.Lock()
	defer fake.deleteRepositorySyncMutex.Unlock()
	fake.DeleteRepositorySyncStub = nil
	fake.deleteRepositorySyncReturns = struct {
		result1 error
	}{result1}
}

func (fake *TKGPackageClient) DeleteRepositorySyncReturnsOnCall(i int, result1 error) {
	fake.deleteRepositorySyncMutex.Lock()
	defer fake.deleteRepositorySyncMutex.Unlock()
	fake.DeleteRepositorySyncStub = nil
	if fake.deleteRepositorySyncReturnsOnCall == nil {
		fake.deleteRepositorySyncReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteRepositorySyncReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *TKGPackageClient) GetPackage(arg1 *tkgpackagedatamodel.PackageOptions) (*v1alpha1.PackageMetadata, *v1alpha1.Package, error) {
	fake.getPackageMutex.Lock()
	ret, specificReturn := fake.getPackageReturnsOnCall[len(fake.getPackageArgsForCall)]
	fake.getPackageArgsForCall = append(fake.getPackageArgsForCall, struct {
		arg1 *tkgpackagedatamodel.PackageOptions
	}{arg1})
	stub := fake.GetPackageStub
	fakeReturns := fake.getPackageReturns
	fake.recordInvocation("GetPackage", []interface{}{arg1})
	fake.getPackageMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *TKGPackageClient) GetPackageCallCount() int {
	fake.getPackageMutex.RLock()
	defer fake.getPackageMutex.RUnlock()
	return len(fake.getPackageArgsForCall)
}

func (fake *TKGPackageClient) GetPackageCalls(stub func(*tkgpackagedatamodel.PackageOptions) (*v1alpha1.PackageMetadata, *v1alpha1.Package, error)) {
	fake.getPackageMutex.Lock()
	defer fake.getPackageMutex.Unlock()
	fake.GetPackageStub = stub
}

func (fake *TKGPackageClient) GetPackageArgsForCall(i int) *tkgpackagedatamodel.PackageOptions {
	fake.getPackageMutex.RLock()
	defer fake.getPackageMutex.RUnlock()
	argsForCall := fake.getPackageArgsForCall[i]
	return argsForCall.arg1
}

func (fake *TKGPackageClient) GetPackageReturns(result1 *v1alpha1.PackageMetadata, result2 *v1alpha1.Package, result3 error) {
	fake.getPackageMutex.Lock()
	defer fake.getPackageMutex.Unlock()
	fake.GetPackageStub = nil
	fake.getPackageReturns = struct {
		result1 *v1alpha1.PackageMetadata
		result2 *v1alpha1.Package
		result3 error
	}{result1, result2, result3}
}

func (fake *TKGPackageClient) GetPackageReturnsOnCall(i int, result1 *v1alpha1.PackageMetadata, result2 *v1alpha1.Package, result3 error) {
	fake.getPackageMutex.Lock()
	defer fake.getPackageMutex.Unlock()
	fake.GetPackageStub = nil
	if fake.getPackageReturnsOnCall == nil {
		fake.getPackageReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.PackageMetadata
			result2 *v1alpha1.Package
			result3 error
		})
	}
	fake.getPackageReturnsOnCall[i] = struct {
		result1 *v1alpha1.PackageMetadata
		result2 *v1alpha1.Package
		result3 error
	}{result1, result2, result3}
}

func (fake *TKGPackageClient) GetPackageInstall(arg1 *tkgpackagedatamodel.PackageOptions) (*v1alpha1a.PackageInstall, error) {
	fake.getPackageInstallMutex.Lock()
	ret, specificReturn := fake.getPackageInstallReturnsOnCall[len(fake.getPackageInstallArgsForCall)]
	fake.getPackageInstallArgsForCall = append(fake.getPackageInstallArgsForCall, struct {
		arg1 *tkgpackagedatamodel.PackageOptions
	}{arg1})
	stub := fake.GetPackageInstallStub
	fakeReturns := fake.getPackageInstallReturns
	fake.recordInvocation("GetPackageInstall", []interface{}{arg1})
	fake.getPackageInstallMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *TKGPackageClient) GetPackageInstallCallCount() int {
	fake.getPackageInstallMutex.RLock()
	defer fake.getPackageInstallMutex.RUnlock()
	return len(fake.getPackageInstallArgsForCall)
}

func (fake *TKGPackageClient) GetPackageInstallCalls(stub func(*tkgpackagedatamodel.PackageOptions) (*v1alpha1a.PackageInstall, error)) {
	fake.getPackageInstallMutex.Lock()
	defer fake.getPackageInstallMutex.Unlock()
	fake.GetPackageInstallStub = stub
}

func (fake *TKGPackageClient) GetPackageInstallArgsForCall(i int) *tkgpackagedatamodel.PackageOptions {
	fake.getPackageInstallMutex.RLock()
	defer fake.getPackageInstallMutex.RUnlock()
	argsForCall := fake.getPackageInstallArgsForCall[i]
	return argsForCall.arg1
}

func (fake *TKGPackageClient) GetPackageInstallReturns(result1 *v1alpha1a.PackageInstall, result2 error) {
	fake.getPackageInstallMutex.Lock()
	defer fake.getPackageInstallMutex.Unlock()
	fake.GetPackageInstallStub = nil
	fake.getPackageInstallReturns = struct {
		result1 *v1alpha1a.PackageInstall
		result2 error
	}{result1, result2}
}

func (fake *TKGPackageClient) GetPackageInstallReturnsOnCall(i int, result1 *v1alpha1a.PackageInstall, result2 error) {
	fake.getPackageInstallMutex.Lock()
	defer fake.getPackageInstallMutex.Unlock()
	fake.GetPackageInstallStub = nil
	if fake.getPackageInstallReturnsOnCall == nil {
		fake.getPackageInstallReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1a.PackageInstall
			result2 error
		})
	}
	fake.getPackageInstallReturnsOnCall[i] = struct {
		result1 *v1alpha1a.PackageInstall
		result2 error
	}{result1, result2}
}

func (fake *TKGPackageClient) GetRepository(arg1 *tkgpackagedatamodel.RepositoryOptions) (*v1alpha1a.PackageRepository, error) {
	fake.getRepositoryMutex.Lock()
	ret, specificReturn := fake.getRepositoryReturnsOnCall[len(fake.getRepositoryArgsForCall)]
	fake.getRepositoryArgsForCall = append(fake.getRepositoryArgsForCall, struct {
		arg1 *tkgpackagedatamodel.RepositoryOptions
	}{arg1})
	stub := fake.GetRepositoryStub
	fakeReturns := fake.getRepositoryReturns
	fake.recordInvocation("GetRepository", []interface{}{arg1})
	fake.getRepositoryMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *TKGPackageClient) GetRepositoryCallCount() int {
	fake.getRepositoryMutex.RLock()
	defer fake.getRepositoryMutex.RUnlock()
	return len(fake.getRepositoryArgsForCall)
}

func (fake *TKGPackageClient) GetRepositoryCalls(stub func(*tkgpackagedatamodel.RepositoryOptions) (*v1alpha1a.PackageRepository, error)) {
	fake.getRepositoryMutex.Lock()
	defer fake.getRepositoryMutex.Unlock()
	fake.GetRepositoryStub = stub
}

func (fake *TKGPackageClient) GetRepositoryArgsForCall(i int) *tkgpackagedatamodel.RepositoryOptions {
	fake.getRepositoryMutex.RLock()
	defer fake.getRepositoryMutex.RUnlock()
	argsForCall := fake.getRepositoryArgsForCall[i]
	return argsForCall.arg1
}

func (fake *TKGPackageClient) GetRepositoryReturns(result1 *v1alpha1a.PackageRepository, result2 error) {
	fake.getRepositoryMutex.Lock()
	defer fake.getRepositoryMutex.Unlock()
	fake.GetRepositoryStub = nil
	fake.getRepositoryReturns = struct {
		result1 *v1alpha1a.PackageRepository
		result2 error
	}{result1, result2}
}

func (fake *TKGPackageClient) GetRepositoryReturnsOnCall(i int, result1 *v1alpha1a.PackageRepository, result2 error) {
	fake.getRepositoryMutex.Lock()
	defer fake.getRepositoryMutex.Unlock()
	fake.GetRepositoryStub = nil
	if fake.getRepositoryReturnsOnCall == nil {
		fake.getRepositoryReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1a.PackageRepository
			result2 error
		})
	}
	fake.getRepositoryReturnsOnCall[i] = struct {
		result1 *v1alpha1a.PackageRepository
		result2 error
	}{result1, result2}
}

func (fake *TKGPackageClient) GetSecretExport(arg1 *tkgpackagedatamodel.RegistrySecretOptions) (*v1alpha1b.SecretExport, error) {
	fake.getSecretExportMutex.Lock()
	ret, specificReturn := fake.getSecretExportReturnsOnCall[len(fake.getSecretExportArgsForCall)]
	fake.getSecretExportArgsForCall = append(fake.getSecretExportArgsForCall, struct {
		arg1 *tkgpackagedatamodel.RegistrySecretOptions
	}{arg1})
	stub := fake.GetSecretExportStub
	fakeReturns := fake.getSecretExportReturns
	fake.recordInvocation("GetSecretExport", []interface{}{arg1})
	fake.getSecretExportMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *TKGPackageClient) GetSecretExportCallCount() int {
	fake.getSecretExportMutex.RLock()
	defer fake.getSecretExportMutex.RUnlock()
	return len(fake.getSecretExportArgsForCall)
}

func (fake *TKGPackageClient) GetSecretExportCalls(stub func(*tkgpackagedatamodel.RegistrySecretOptions) (*v1alpha1b.SecretExport, error)) {
	fake.getSecretExportMutex.Lock()
	defer fake.getSecretExportMutex.Unlock()
	fake.GetSecretExportStub = stub
}

func (fake *TKGPackageClient) GetSecretExportArgsForCall(i int) *tkgpackagedatamodel.RegistrySecretOptions {
	fake.getSecretExportMutex.RLock()
	defer fake.getSecretExportMutex.RUnlock()
	argsForCall := fake.getSecretExportArgsForCall[i]
	return argsForCall.arg1
}

func (fake *TKGPackageClient) GetSecretExportReturns(result1 *v1alpha1b.SecretExport, result2 error) {
	fake.getSecretExportMutex.Lock()
	defer fake.getSecretExportMutex.Unlock()
	fake.GetSecretExportStub = nil
	fake.getSecretExportReturns = struct {
		result1 *v1alpha1b.SecretExport
		result2 error
	}{result1, result2}
}

func (fake *TKGPackageClient) GetSecretExportReturnsOnCall(i int, result1 *v1alpha1b.SecretExport, result2 error) {
	fake.getSecretExportMutex.Lock()
	defer fake.getSecretExportMutex.Unlock()
	fake.GetSecretExportStub = nil
	if fake.getSecretExportReturnsOnCall == nil {
		fake.getSecretExportReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1b.SecretExport
			result2 error
		})
	}
	fake.getSecretExportReturnsOnCall[i] = struct {
		result1 *v1alpha1b.SecretExport
		result2 error
	}{result1, result2}
}

func (fake *TKGPackageClient) InstallPackage(arg1 *tkgpackagedatamodel.PackageOptions, arg2 *tkgpackagedatamodel.PackageProgress, arg3 tkgpackagedatamodel.OperationType) {
	fake.installPackageMutex.Lock()
	fake.installPackageArgsForCall = append(fake.installPackageArgsForCall, struct {
		arg1 *tkgpackagedatamodel.PackageOptions
		arg2 *tkgpackagedatamodel.PackageProgress
		arg3 tkgpackagedatamodel.OperationType
	}{arg1, arg2, arg3})
	stub := fake.InstallPackageStub
	fake.recordInvocation("InstallPackage", []interface{}{arg1, arg2, arg3})
	fake.installPackageMutex.Unlock()
	if stub != nil {
		fake.InstallPackageStub(arg1, arg2, arg3)
	}
}

func (fake *TKGPackageClient) InstallPackageCallCount() int {
	fake.installPackageMutex.RLock()
	defer fake.installPackageMutex.RUnlock()
	return len(fake.installPackageArgsForCall)
}

func (fake *TKGPackageClient) InstallPackageCalls(stub func(*tkgpackagedatamodel.PackageOptions, *tkgpackagedatamodel.PackageProgress, tkgpackagedatamodel.OperationType)) {
	fake.installPackageMutex.Lock()
	defer fake.installPackageMutex.Unlock()
	fake.InstallPackageStub = stub
}

func (fake *TKGPackageClient) InstallPackageArgsForCall(i int) (*tkgpackagedatamodel.PackageOptions, *tkgpackagedatamodel.PackageProgress, tkgpackagedatamodel.OperationType) {
	fake.installPackageMutex.RLock()
	defer fake.installPackageMutex.RUnlock()
	argsForCall := fake.installPackageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *TKGPackageClient) InstallPackageSync(arg1 *tkgpackagedatamodel.PackageOptions, arg2 tkgpackagedatamodel.OperationType) error {
	fake.installPackageSyncMutex.Lock()
	ret, specificReturn := fake.installPackageSyncReturnsOnCall[len(fake.installPackageSyncArgsForCall)]
	fake.installPackageSyncArgsForCall = append(fake.installPackageSyncArgsForCall, struct {
		arg1 *tkgpackagedatamodel.PackageOptions
		arg2 tkgpackagedatamodel.OperationType
	}{arg1, arg2})
	stub := fake.InstallPackageSyncStub
	fakeReturns := fake.installPackageSyncReturns
	fake.recordInvocation("InstallPackageSync", []interface{}{arg1, arg2})
	fake.installPackageSyncMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TKGPackageClient) InstallPackageSyncCallCount() int {
	fake.installPackageSyncMutex.RLock()
	defer fake.installPackageSyncMutex.RUnlock()
	return len(fake.installPackageSyncArgsForCall)
}

func (fake *TKGPackageClient) InstallPackageSyncCalls(stub func(*tkgpackagedatamodel.PackageOptions, tkgpackagedatamodel.OperationType) error) {
	fake.installPackageSyncMutex.Lock()
	defer fake.installPackageSyncMutex.Unlock()
	fake.InstallPackageSyncStub = stub
}

func (fake *TKGPackageClient) InstallPackageSyncArgsForCall(i int) (*tkgpackagedatamodel.PackageOptions, tkgpackagedatamodel.OperationType) {
	fake.installPackageSyncMutex.RLock()
	defer fake.installPackageSyncMutex.RUnlock()
	argsForCall := fake.installPackageSyncArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *TKGPackageClient) InstallPackageSyncReturns(result1 error) {
	fake.installPackageSyncMutex.Lock()
	defer fake.installPackageSyncMutex.Unlock()
	fake.InstallPackageSyncStub = nil
	fake.installPackageSyncReturns = struct {
		result1 error
	}{result1}
}

func (fake *TKGPackageClient) InstallPackageSyncReturnsOnCall(i int, result1 error) {
	fake.installPackageSyncMutex.Lock()
	defer fake.installPackageSyncMutex.Unlock()
	fake.InstallPackageSyncStub = nil
	if fake.installPackageSyncReturnsOnCall == nil {
		fake.installPackageSyncReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.installPackageSyncReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *TKGPackageClient) ListPackageInstalls(arg1 *tkgpackagedatamodel.PackageOptions) (*v1alpha1a.PackageInstallList, error) {
	fake.listPackageInstallsMutex.Lock()
	ret, specificReturn := fake.listPackageInstallsReturnsOnCall[len(fake.listPackageInstallsArgsForCall)]
	fake.listPackageInstallsArgsForCall = append(fake.listPackageInstallsArgsForCall, struct {
		arg1 *tkgpackagedatamodel.PackageOptions
	}{arg1})
	stub := fake.ListPackageInstallsStub
	fakeReturns := fake.listPackageInstallsReturns
	fake.recordInvocation("ListPackageInstalls", []interface{}{arg1})
	fake.listPackageInstallsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *TKGPackageClient) ListPackageInstallsCallCount() int {
	fake.listPackageInstallsMutex.RLock()
	defer fake.listPackageInstallsMutex.RUnlock()
	return len(fake.listPackageInstallsArgsForCall)
}

func (fake *TKGPackageClient) ListPackageInstallsCalls(stub func(*tkgpackagedatamodel.PackageOptions) (*v1alpha1a.PackageInstallList, error)) {
	fake.listPackageInstallsMutex.Lock()
	defer fake.listPackageInstallsMutex.Unlock()
	fake.ListPackageInstallsStub = stub
}

func (fake *TKGPackageClient) ListPackageInstallsArgsForCall(i int) *tkgpackagedatamodel.PackageOptions {
	fake.listPackageInstallsMutex.RLock()
	defer fake.listPackageInstallsMutex.RUnlock()
	argsForCall := fake.listPackageInstallsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *TKGPackageClient) ListPackageInstallsReturns(result1 *v1alpha1a.PackageInstallList, result2 error) {
	fake.listPackageInstallsMutex.Lock()
	defer fake.listPackageInstallsMutex.Unlock()
	fake.ListPackageInstallsStub = nil
	fake.listPackageInstallsReturns = struct {
		result1 *v1alpha1a.PackageInstallList
		result2 error
	}{result1, result2}
}

func (fake *TKGPackageClient) ListPackageInstallsReturnsOnCall(i int, result1 *v1alpha1a.PackageInstallList, result2 error) {
	fake.listPackageInstallsMutex.Lock()
	defer fake.listPackageInstallsMutex.Unlock()
	fake.ListPackageInstallsStub = nil
	if fake.listPackageInstallsReturnsOnCall == nil {
		fake.listPackageInstallsReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1a.PackageInstallList
			result2 error
		})
	}
	fake.listPackageInstallsReturnsOnCall[i] = struct {
		result1 *v1alpha1a.PackageInstallList
		result2 error
	}{result1, result2}
}

func (fake *TKGPackageClient) ListPackageMetadata(arg1 *tkgpackagedatamodel.PackageAvailableOptions) (*v1alpha1.PackageMetadataList, error) {
	fake.listPackageMetadataMutex.Lock()
	ret, specificReturn := fake.listPackageMetadataReturnsOnCall[len(fake.listPackageMetadataArgsForCall)]
	fake.listPackageMetadataArgsForCall = append(fake.listPackageMetadataArgsForCall, struct {
		arg1 *tkgpackagedatamodel.PackageAvailableOptions
	}{arg1})
	stub := fake.ListPackageMetadataStub
	fakeReturns := fake.listPackageMetadataReturns
	fake.recordInvocation("ListPackageMetadata", []interface{}{arg1})
	fake.listPackageMetadataMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *TKGPackageClient) ListPackageMetadataCallCount() int {
	fake.listPackageMetadataMutex.RLock()
	defer fake.listPackageMetadataMutex.RUnlock()
	return len(fake.listPackageMetadataArgsForCall)
}

func (fake *TKGPackageClient) ListPackageMetadataCalls(stub func(*tkgpackagedatamodel.PackageAvailableOptions) (*v1alpha1.PackageMetadataList, error)) {
	fake.listPackageMetadataMutex.Lock()
	defer fake.listPackageMetadataMutex.Unlock()
	fake.ListPackageMetadataStub = stub
}

func (fake *TKGPackageClient) ListPackageMetadataArgsForCall(i int) *tkgpackagedatamodel.PackageAvailableOptions {
	fake.listPackageMetadataMutex.RLock()
	defer fake.listPackageMetadataMutex.RUnlock()
	argsForCall := fake.listPackageMetadataArgsForCall[i]
	return argsForCall.arg1
}

func (fake *TKGPackageClient) ListPackageMetadataReturns(result1 *v1alpha1.PackageMetadataList, result2 error) {
	fake.listPackageMetadataMutex.Lock()
	defer fake.listPackageMetadataMutex.Unlock()
	fake.ListPackageMetadataStub = nil
	fake.listPackageMetadataReturns = struct {
		result1 *v1alpha1.PackageMetadataList
		result2 error
	}{result1, result2}
}

func (fake *TKGPackageClient) ListPackageMetadataReturnsOnCall(i int, result1 *v1alpha1.PackageMetadataList, result2 error) {
	fake.listPackageMetadataMutex.Lock()
	defer fake.listPackageMetadataMutex.Unlock()
	fake.ListPackageMetadataStub = nil
	if fake.listPackageMetadataReturnsOnCall == nil {
		fake.listPackageMetadataReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.PackageMetadataList
			result2 error
		})
	}
	fake.listPackageMetadataReturnsOnCall[i] = struct {
		result1 *v1alpha1.PackageMetadataList
		result2 error
	}{result1, result2}
}

func (fake *TKGPackageClient) ListPackages(arg1 *tkgpackagedatamodel.PackageAvailableOptions) (*v1alpha1.PackageList, error) {
	fake.listPackagesMutex.Lock()
	ret, specificReturn := fake.listPackagesReturnsOnCall[len(fake.listPackagesArgsForCall)]
	fake.listPackagesArgsForCall = append(fake.listPackagesArgsForCall, struct {
		arg1 *tkgpackagedatamodel.PackageAvailableOptions
	}{arg1})
	stub := fake.ListPackagesStub
	fakeReturns := fake.listPackagesReturns
	fake.recordInvocation("ListPackages", []interface{}{arg1})
	fake.listPackagesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *TKGPackageClient) ListPackagesCallCount() int {
	fake.listPackagesMutex.RLock()
	defer fake.listPackagesMutex.RUnlock()
	return len(fake.listPackagesArgsForCall)
}

func (fake *TKGPackageClient) ListPackagesCalls(stub func(*tkgpackagedatamodel.PackageAvailableOptions) (*v1alpha1.PackageList, error)) {
	fake.listPackagesMutex.Lock()
	defer fake.listPackagesMutex.Unlock()
	fake.ListPackagesStub = stub
}

func (fake *TKGPackageClient) ListPackagesArgsForCall(i int) *tkgpackagedatamodel.PackageAvailableOptions {
	fake.listPackagesMutex.RLock()
	defer fake.listPackagesMutex.RUnlock()
	argsForCall := fake.listPackagesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *TKGPackageClient) ListPackagesReturns(result1 *v1alpha1.PackageList, result2 error) {
	fake.listPackagesMutex.Lock()
	defer fake.listPackagesMutex.Unlock()
	fake.ListPackagesStub = nil
	fake.listPackagesReturns = struct {
		result1 *v1alpha1.PackageList
		result2 error
	}{result1, result2}
}

func (fake *TKGPackageClient) ListPackagesReturnsOnCall(i int, result1 *v1alpha1.PackageList, result2 error) {
	fake.listPackagesMutex.Lock()
	defer fake.listPackagesMutex.Unlock()
	fake.ListPackagesStub = nil
	if fake.listPackagesReturnsOnCall == nil {
		fake.listPackagesReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.PackageList
			result2 error
		})
	}
	fake.listPackagesReturnsOnCall[i] = struct {
		result1 *v1alpha1.PackageList
		result2 error
	}{result1, result2}
}

func (fake *TKGPackageClient) ListRegistrySecrets(arg1 *tkgpackagedatamodel.RegistrySecretOptions) (*v1.SecretList, error) {
	fake.listRegistrySecretsMutex.Lock()
	ret, specificReturn := fake.listRegistrySecretsReturnsOnCall[len(fake.listRegistrySecretsArgsForCall)]
	fake.listRegistrySecretsArgsForCall = append(fake.listRegistrySecretsArgsForCall, struct {
		arg1 *tkgpackagedatamodel.RegistrySecretOptions
	}{arg1})
	stub := fake.ListRegistrySecretsStub
	fakeReturns := fake.listRegistrySecretsReturns
	fake.recordInvocation("ListRegistrySecrets", []interface{}{arg1})
	fake.listRegistrySecretsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *TKGPackageClient) ListRegistrySecretsCallCount() int {
	fake.listRegistrySecretsMutex.RLock()
	defer fake.listRegistrySecretsMutex.RUnlock()
	return len(fake.listRegistrySecretsArgsForCall)
}

func (fake *TKGPackageClient) ListRegistrySecretsCalls(stub func(*tkgpackagedatamodel.RegistrySecretOptions) (*v1.SecretList, error)) {
	fake.listRegistrySecretsMutex.Lock()
	defer fake.listRegistrySecretsMutex.Unlock()
	fake.ListRegistrySecretsStub = stub
}

func (fake *TKGPackageClient) ListRegistrySecretsArgsForCall(i int) *tkgpackagedatamodel.RegistrySecretOptions {
	fake.listRegistrySecretsMutex.RLock()
	defer fake.listRegistrySecretsMutex.RUnlock()
	argsForCall := fake.listRegistrySecretsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *TKGPackageClient) ListRegistrySecretsReturns(result1 *v1.SecretList, result2 error) {
	fake.listRegistrySecretsMutex.Lock()
	defer fake.listRegistrySecretsMutex.Unlock()
	fake.ListRegistrySecretsStub = nil
	fake.listRegistrySecretsReturns = struct {
		result1 *v1.SecretList
		result2 error
	}{result1, result2}
}

func (fake *TKGPackageClient) ListRegistrySecretsReturnsOnCall(i int, result1 *v1.SecretList, result2 error) {
	fake.listRegistrySecretsMutex.Lock()
	defer fake.listRegistrySecretsMutex.Unlock()
	fake.ListRegistrySecretsStub = nil
	if fake.listRegistrySecretsReturnsOnCall == nil {
		fake.listRegistrySecretsReturnsOnCall = make(map[int]struct {
			result1 *v1.SecretList
			result2 error
		})
	}
	fake.listRegistrySecretsReturnsOnCall[i] = struct {
		result1 *v1.SecretList
		result2 error
	}{result1, result2}
}

func (fake *TKGPackageClient) ListRepositories(arg1 *tkgpackagedatamodel.RepositoryOptions) (*v1alpha1a.PackageRepositoryList, error) {
	fake.listRepositoriesMutex.Lock()
	ret, specificReturn := fake.listRepositoriesReturnsOnCall[len(fake.listRepositoriesArgsForCall)]
	fake.listRepositoriesArgsForCall = append(fake.listRepositoriesArgsForCall, struct {
		arg1 *tkgpackagedatamodel.RepositoryOptions
	}{arg1})
	stub := fake.ListRepositoriesStub
	fakeReturns := fake.listRepositoriesReturns
	fake.recordInvocation("ListRepositories", []interface{}{arg1})
	fake.listRepositoriesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *TKGPackageClient) ListRepositoriesCallCount() int {
	fake.listRepositoriesMutex.RLock()
	defer fake.listRepositoriesMutex.RUnlock()
	return len(fake.listRepositoriesArgsForCall)
}

func (fake *TKGPackageClient) ListRepositoriesCalls(stub func(*tkgpackagedatamodel.RepositoryOptions) (*v1alpha1a.PackageRepositoryList, error)) {
	fake.listRepositoriesMutex.Lock()
	defer fake.listRepositoriesMutex.Unlock()
	fake.ListRepositoriesStub = stub
}

func (fake *TKGPackageClient) ListRepositoriesArgsForCall(i int) *tkgpackagedatamodel.RepositoryOptions {
	fake.listRepositoriesMutex.RLock()
	defer fake.listRepositoriesMutex.RUnlock()
	argsForCall := fake.listRepositoriesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *TKGPackageClient) ListRepositoriesReturns(result1 *v1alpha1a.PackageRepositoryList, result2 error) {
	fake.listRepositoriesMutex.Lock()
	defer fake.listRepositoriesMutex.Unlock()
	fake.ListRepositoriesStub = nil
	fake.listRepositoriesReturns = struct {
		result1 *v1alpha1a.PackageRepositoryList
		result2 error
	}{result1, result2}
}

func (fake *TKGPackageClient) ListRepositoriesReturnsOnCall(i int, result1 *v1alpha1a.PackageRepositoryList, result2 error) {
	fake.listRepositoriesMutex.Lock()
	defer fake.listRepositoriesMutex.Unlock()
	fake.ListRepositoriesStub = nil
	if fake.listRepositoriesReturnsOnCall == nil {
		fake.listRepositoriesReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1a.PackageRepositoryList
			result2 error
		})
	}
	fake.listRepositoriesReturnsOnCall[i] = struct {
		result1 *v1alpha1a.PackageRepositoryList
		result2 error
	}{result1, result2}
}

func (fake *TKGPackageClient) ListSecretExports(arg1 *tkgpackagedatamodel.RegistrySecretOptions) (*v1alpha1b.SecretExportList, error) {
	fake.listSecretExportsMutex.Lock()
	ret, specificReturn := fake.listSecretExportsReturnsOnCall[len(fake.listSecretExportsArgsForCall)]
	fake.listSecretExportsArgsForCall = append(fake.listSecretExportsArgsForCall, struct {
		arg1 *tkgpackagedatamodel.RegistrySecretOptions
	}{arg1})
	stub := fake.ListSecretExportsStub
	fakeReturns := fake.listSecretExportsReturns
	fake.recordInvocation("ListSecretExports", []interface{}{arg1})
	fake.listSecretExportsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *TKGPackageClient) ListSecretExportsCallCount() int {
	fake.listSecretExportsMutex.RLock()
	defer fake.listSecretExportsMutex.RUnlock()
	return len(fake.listSecretExportsArgsForCall)
}

func (fake *TKGPackageClient) ListSecretExportsCalls(stub func(*tkgpackagedatamodel.RegistrySecretOptions) (*v1alpha1b.SecretExportList, error)) {
	fake.listSecretExportsMutex.Lock()
	defer fake.listSecretExportsMutex.Unlock()
	fake.ListSecretExportsStub = stub
}

func (fake *TKGPackageClient) ListSecretExportsArgsForCall(i int) *tkgpackagedatamodel.RegistrySecretOptions {
	fake.listSecretExportsMutex.RLock()
	defer fake.listSecretExportsMutex.RUnlock()
	argsForCall := fake.listSecretExportsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *TKGPackageClient) ListSecretExportsReturns(result1 *v1alpha1b.SecretExportList, result2 error) {
	fake.listSecretExportsMutex.Lock()
	defer fake.listSecretExportsMutex.Unlock()
	fake.ListSecretExportsStub = nil
	fake.listSecretExportsReturns = struct {
		result1 *v1alpha1b.SecretExportList
		result2 error
	}{result1, result2}
}

func (fake *TKGPackageClient) ListSecretExportsReturnsOnCall(i int, result1 *v1alpha1b.SecretExportList, result2 error) {
	fake.listSecretExportsMutex.Lock()
	defer fake.listSecretExportsMutex.Unlock()
	fake.ListSecretExportsStub = nil
	if fake.listSecretExportsReturnsOnCall == nil {
		fake.listSecretExportsReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1b.SecretExportList
			result2 error
		})
	}
	fake.listSecretExportsReturnsOnCall[i] = struct {
		result1 *v1alpha1b.SecretExportList
		result2 error
	}{result1, result2}
}

func (fake *TKGPackageClient) UninstallPackage(arg1 *tkgpackagedatamodel.PackageOptions, arg2 *tkgpackagedatamodel.PackageProgress) {
	fake.uninstallPackageMutex.Lock()
	fake.uninstallPackageArgsForCall = append(fake.uninstallPackageArgsForCall, struct {
		arg1 *tkgpackagedatamodel.PackageOptions
		arg2 *tkgpackagedatamodel.PackageProgress
	}{arg1, arg2})
	stub := fake.UninstallPackageStub
	fake.recordInvocation("UninstallPackage", []interface{}{arg1, arg2})
	fake.uninstallPackageMutex.Unlock()
	if stub != nil {
		fake.UninstallPackageStub(arg1, arg2)
	}
}

func (fake *TKGPackageClient) UninstallPackageCallCount() int {
	fake.uninstallPackageMutex.RLock()
	defer fake.uninstallPackageMutex.RUnlock()
	return len(fake.uninstallPackageArgsForCall)
}

func (fake *TKGPackageClient) UninstallPackageCalls(stub func(*tkgpackagedatamodel.PackageOptions, *tkgpackagedatamodel.PackageProgress)) {
	fake.uninstallPackageMutex.Lock()
	defer fake.uninstallPackageMutex.Unlock()
	fake.UninstallPackageStub = stub
}

func (fake *TKGPackageClient) UninstallPackageArgsForCall(i int) (*tkgpackagedatamodel.PackageOptions, *tkgpackagedatamodel.PackageProgress) {
	fake.uninstallPackageMutex.RLock()
	defer fake.uninstallPackageMutex.RUnlock()
	argsForCall := fake.uninstallPackageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *TKGPackageClient) UninstallPackageSync(arg1 *tkgpackagedatamodel.PackageOptions) error {
	fake.uninstallPackageSyncMutex.Lock()
	ret, specificReturn := fake.uninstallPackageSyncReturnsOnCall[len(fake.uninstallPackageSyncArgsForCall)]
	fake.uninstallPackageSyncArgsForCall = append(fake.uninstallPackageSyncArgsForCall, struct {
		arg1 *tkgpackagedatamodel.PackageOptions
	}{arg1})
	stub := fake.UninstallPackageSyncStub
	fakeReturns := fake.uninstallPackageSyncReturns
	fake.recordInvocation("UninstallPackageSync", []interface{}{arg1})
	fake.uninstallPackageSyncMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TKGPackageClient) UninstallPackageSyncCallCount() int {
	fake.uninstallPackageSyncMutex.RLock()
	defer fake.uninstallPackageSyncMutex.RUnlock()
	return len(fake.uninstallPackageSyncArgsForCall)
}

func (fake *TKGPackageClient) UninstallPackageSyncCalls(stub func(*tkgpackagedatamodel.PackageOptions) error) {
	fake.uninstallPackageSyncMutex.Lock()
	defer fake.uninstallPackageSyncMutex.Unlock()
	fake.UninstallPackageSyncStub = stub
}

func (fake *TKGPackageClient) UninstallPackageSyncArgsForCall(i int) *tkgpackagedatamodel.PackageOptions {
	fake.uninstallPackageSyncMutex.RLock()
	defer fake.uninstallPackageSyncMutex.RUnlock()
	argsForCall := fake.uninstallPackageSyncArgsForCall[i]
	return argsForCall.arg1
}

func (fake *TKGPackageClient) UninstallPackageSyncReturns(result1 error) {
	fake.uninstallPackageSyncMutex.Lock()
	defer fake.uninstallPackageSyncMutex.Unlock()
	fake.UninstallPackageSyncStub = nil
	fake.uninstallPackageSyncReturns = struct {
		result1 error
	}{result1}
}

func (fake *TKGPackageClient) UninstallPackageSyncReturnsOnCall(i int, result1 error) {
	fake.uninstallPackageSyncMutex.Lock()
	defer fake.uninstallPackageSyncMutex.Unlock()
	fake.UninstallPackageSyncStub = nil
	if fake.uninstallPackageSyncReturnsOnCall == nil {
		fake.uninstallPackageSyncReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.uninstallPackageSyncReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *TKGPackageClient) UpdatePackage(arg1 *tkgpackagedatamodel.PackageOptions, arg2 *tkgpackagedatamodel.PackageProgress, arg3 tkgpackagedatamodel.OperationType) {
	fake.updatePackageMutex.Lock()
	fake.updatePackageArgsForCall = append(fake.updatePackageArgsForCall, struct {
		arg1 *tkgpackagedatamodel.PackageOptions
		arg2 *tkgpackagedatamodel.PackageProgress
		arg3 tkgpackagedatamodel.OperationType
	}{arg1, arg2, arg3})
	stub := fake.UpdatePackageStub
	fake.recordInvocation("UpdatePackage", []interface{}{arg1, arg2, arg3})
	fake.updatePackageMutex.Unlock()
	if stub != nil {
		fake.UpdatePackageStub(arg1, arg2, arg3)
	}
}

func (fake *TKGPackageClient) UpdatePackageCallCount() int {
	fake.updatePackageMutex.RLock()
	defer fake.updatePackageMutex.RUnlock()
	return len(fake.updatePackageArgsForCall)
}

func (fake *TKGPackageClient) UpdatePackageCalls(stub func(*tkgpackagedatamodel.PackageOptions, *tkgpackagedatamodel.PackageProgress, tkgpackagedatamodel.OperationType)) {
	fake.updatePackageMutex.Lock()
	defer fake.updatePackageMutex.Unlock()
	fake.UpdatePackageStub = stub
}

func (fake *TKGPackageClient) UpdatePackageArgsForCall(i int) (*tkgpackagedatamodel.PackageOptions, *tkgpackagedatamodel.PackageProgress, tkgpackagedatamodel.OperationType) {
	fake.updatePackageMutex.RLock()
	defer fake.updatePackageMutex.RUnlock()
	argsForCall := fake.updatePackageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *TKGPackageClient) UpdatePackageSync(arg1 *tkgpackagedatamodel.PackageOptions, arg2 tkgpackagedatamodel.OperationType) error {
	fake.updatePackageSyncMutex.Lock()
	ret, specificReturn := fake.updatePackageSyncReturnsOnCall[len(fake.updatePackageSyncArgsForCall)]
	fake.updatePackageSyncArgsForCall = append(fake.updatePackageSyncArgsForCall, struct {
		arg1 *tkgpackagedatamodel.PackageOptions
		arg2 tkgpackagedatamodel.OperationType
	}{arg1, arg2})
	stub := fake.UpdatePackageSyncStub
	fakeReturns := fake.updatePackageSyncReturns
	fake.recordInvocation("UpdatePackageSync", []interface{}{arg1, arg2})
	fake.updatePackageSyncMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TKGPackageClient) UpdatePackageSyncCallCount() int {
	fake.updatePackageSyncMutex.RLock()
	defer fake.updatePackageSyncMutex.RUnlock()
	return len(fake.updatePackageSyncArgsForCall)
}

func (fake *TKGPackageClient) UpdatePackageSyncCalls(stub func(*tkgpackagedatamodel.PackageOptions, tkgpackagedatamodel.OperationType) error) {
	fake.updatePackageSyncMutex.Lock()
	defer fake.updatePackageSyncMutex.Unlock()
	fake.UpdatePackageSyncStub = stub
}

func (fake *TKGPackageClient) UpdatePackageSyncArgsForCall(i int) (*tkgpackagedatamodel.PackageOptions, tkgpackagedatamodel.OperationType) {
	fake.updatePackageSyncMutex.RLock()
	defer fake.updatePackageSyncMutex.RUnlock()
	argsForCall := fake.updatePackageSyncArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *TKGPackageClient) UpdatePackageSyncReturns(result1 error) {
	fake.updatePackageSyncMutex.Lock()
	defer fake.updatePackageSyncMutex.Unlock()
	fake.UpdatePackageSyncStub = nil
	fake.updatePackageSyncReturns = struct {
		result1 error
	}{result1}
}

func (fake *TKGPackageClient) UpdatePackageSyncReturnsOnCall(i int, result1 error) {
	fake.updatePackageSyncMutex.Lock()
	defer fake.updatePackageSyncMutex.Unlock()
	fake.UpdatePackageSyncStub = nil
	if fake.updatePackageSyncReturnsOnCall == nil {
		fake.updatePackageSyncReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updatePackageSyncReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *TKGPackageClient) UpdateRegistrySecret(arg1 *tkgpackagedatamodel.RegistrySecretOptions) error {
	fake.updateRegistrySecretMutex.Lock()
	ret, specificReturn := fake.updateRegistrySecretReturnsOnCall[len(fake.updateRegistrySecretArgsForCall)]
	fake.updateRegistrySecretArgsForCall = append(fake.updateRegistrySecretArgsForCall, struct {
		arg1 *tkgpackagedatamodel.RegistrySecretOptions
	}{arg1})
	stub := fake.UpdateRegistrySecretStub
	fakeReturns := fake.updateRegistrySecretReturns
	fake.recordInvocation("UpdateRegistrySecret", []interface{}{arg1})
	fake.updateRegistrySecretMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TKGPackageClient) UpdateRegistrySecretCallCount() int {
	fake.updateRegistrySecretMutex.RLock()
	defer fake.updateRegistrySecretMutex.RUnlock()
	return len(fake.updateRegistrySecretArgsForCall)
}

func (fake *TKGPackageClient) UpdateRegistrySecretCalls(stub func(*tkgpackagedatamodel.RegistrySecretOptions) error) {
	fake.updateRegistrySecretMutex.Lock()
	defer fake.updateRegistrySecretMutex.Unlock()
	fake.UpdateRegistrySecretStub = stub
}

func (fake *TKGPackageClient) UpdateRegistrySecretArgsForCall(i int) *tkgpackagedatamodel.RegistrySecretOptions {
	fake.updateRegistrySecretMutex.RLock()
	defer fake.updateRegistrySecretMutex.RUnlock()
	argsForCall := fake.updateRegistrySecretArgsForCall[i]
	return argsForCall.arg1
}

func (fake *TKGPackageClient) UpdateRegistrySecretReturns(result1 error) {
	fake.updateRegistrySecretMutex.Lock()
	defer fake.updateRegistrySecretMutex.Unlock()
	fake.UpdateRegistrySecretStub = nil
	fake.updateRegistrySecretReturns = struct {
		result1 error
	}{result1}
}

func (fake *TKGPackageClient) UpdateRegistrySecretReturnsOnCall(i int, result1 error) {
	fake.updateRegistrySecretMutex.Lock()
	defer fake.updateRegistrySecretMutex.Unlock()
	fake.UpdateRegistrySecretStub = nil
	if fake.updateRegistrySecretReturnsOnCall == nil {
		fake.updateRegistrySecretReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateRegistrySecretReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *TKGPackageClient) UpdateRepository(arg1 *tkgpackagedatamodel.RepositoryOptions, arg2 *tkgpackagedatamodel.PackageProgress, arg3 tkgpackagedatamodel.OperationType) {
	fake.updateRepositoryMutex.Lock()
	fake.updateRepositoryArgsForCall = append(fake.updateRepositoryArgsForCall, struct {
		arg1 *tkgpackagedatamodel.RepositoryOptions
		arg2 *tkgpackagedatamodel.PackageProgress
		arg3 tkgpackagedatamodel.OperationType
	}{arg1, arg2, arg3})
	stub := fake.UpdateRepositoryStub
	fake.recordInvocation("UpdateRepository", []interface{}{arg1, arg2, arg3})
	fake.updateRepositoryMutex.Unlock()
	if stub != nil {
		fake.UpdateRepositoryStub(arg1, arg2, arg3)
	}
}

func (fake *TKGPackageClient) UpdateRepositoryCallCount() int {
	fake.updateRepositoryMutex.RLock()
	defer fake.updateRepositoryMutex.RUnlock()
	return len(fake.updateRepositoryArgsForCall)
}

func (fake *TKGPackageClient) UpdateRepositoryCalls(stub func(*tkgpackagedatamodel.RepositoryOptions, *tkgpackagedatamodel.PackageProgress, tkgpackagedatamodel.OperationType)) {
	fake.updateRepositoryMutex.Lock()
	defer fake.updateRepositoryMutex.Unlock()
	fake.UpdateRepositoryStub = stub
}

func (fake *TKGPackageClient) UpdateRepositoryArgsForCall(i int) (*tkgpackagedatamodel.RepositoryOptions, *tkgpackagedatamodel.PackageProgress, tkgpackagedatamodel.OperationType) {
	fake.updateRepositoryMutex.RLock()
	defer fake.updateRepositoryMutex.RUnlock()
	argsForCall := fake.updateRepositoryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *TKGPackageClient) UpdateRepositorySync(arg1 *tkgpackagedatamodel.RepositoryOptions, arg2 tkgpackagedatamodel.OperationType) error {
	fake.updateRepositorySyncMutex.Lock()
	ret, specificReturn := fake.updateRepositorySyncReturnsOnCall[len(fake.updateRepositorySyncArgsForCall)]
	fake.updateRepositorySyncArgsForCall = append(fake.updateRepositorySyncArgsForCall, struct {
		arg1 *tkgpackagedatamodel.RepositoryOptions
		arg2 tkgpackagedatamodel.OperationType
	}{arg1, arg2})
	stub := fake.UpdateRepositorySyncStub
	fakeReturns := fake.updateRepositorySyncReturns
	fake.recordInvocation("UpdateRepositorySync", []interface{}{arg1, arg2})
	fake.updateRepositorySyncMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TKGPackageClient) UpdateRepositorySyncCallCount() int {
	fake.updateRepositorySyncMutex.RLock()
	defer fake.updateRepositorySyncMutex.RUnlock()
	return len(fake.updateRepositorySyncArgsForCall)
}

func (fake *TKGPackageClient) UpdateRepositorySyncCalls(stub func(*tkgpackagedatamodel.RepositoryOptions, tkgpackagedatamodel.OperationType) error) {
	fake.updateRepositorySyncMutex.Lock()
	defer fake.updateRepositorySyncMutex.Unlock()
	fake.UpdateRepositorySyncStub = stub
}

func (fake *TKGPackageClient) UpdateRepositorySyncArgsForCall(i int) (*tkgpackagedatamodel.RepositoryOptions, tkgpackagedatamodel.OperationType) {
	fake.updateRepositorySyncMutex.RLock()
	defer fake.updateRepositorySyncMutex.RUnlock()
	argsForCall := fake.updateRepositorySyncArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *TKGPackageClient) UpdateRepositorySyncReturns(result1 error) {
	fake.updateRepositorySyncMutex.Lock()
	defer fake.updateRepositorySyncMutex.Unlock()
	fake.UpdateRepositorySyncStub = nil
	fake.updateRepositorySyncReturns = struct {
		result1 error
	}{result1}
}

func (fake *TKGPackageClient) UpdateRepositorySyncReturnsOnCall(i int, result1 error) {
	fake.updateRepositorySyncMutex.Lock()
	defer fake.updateRepositorySyncMutex.Unlock()
	fake.UpdateRepositorySyncStub = nil
	if fake.updateRepositorySyncReturnsOnCall == nil {
		fake.updateRepositorySyncReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateRepositorySyncReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *TKGPackageClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addRegistrySecretMutex.RLock()
	defer fake.addRegistrySecretMutex.RUnlock()
	fake.addRepositoryMutex.RLock()
	defer fake.addRepositoryMutex.RUnlock()
	fake.addRepositorySyncMutex.RLock()
	defer fake.addRepositorySyncMutex.RUnlock()
	fake.deleteRegistrySecretMutex.RLock()
	defer fake.deleteRegistrySecretMutex.RUnlock()
	fake.deleteRepositoryMutex.RLock()
	defer fake.deleteRepositoryMutex.RUnlock()
	fake.deleteRepositorySyncMutex.RLock()
	defer fake.deleteRepositorySyncMutex.RUnlock()
	fake.getPackageMutex.RLock()
	defer fake.getPackageMutex.RUnlock()
	fake.getPackageInstallMutex.RLock()
	defer fake.getPackageInstallMutex.RUnlock()
	fake.getRepositoryMutex.RLock()
	defer fake.getRepositoryMutex.RUnlock()
	fake.getSecretExportMutex.RLock()
	defer fake.getSecretExportMutex.RUnlock()
	fake.installPackageMutex.RLock()
	defer fake.installPackageMutex.RUnlock()
	fake.installPackageSyncMutex.RLock()
	defer fake.installPackageSyncMutex.RUnlock()
	fake.listPackageInstallsMutex.RLock()
	defer fake.listPackageInstallsMutex.RUnlock()
	fake.listPackageMetadataMutex.RLock()
	defer fake.listPackageMetadataMutex.RUnlock()
	fake.listPackagesMutex.RLock()
	defer fake.listPackagesMutex.RUnlock()
	fake.listRegistrySecretsMutex.RLock()
	defer fake.listRegistrySecretsMutex.RUnlock()
	fake.listRepositoriesMutex.RLock()
	defer fake.listRepositoriesMutex.RUnlock()
	fake.listSecretExportsMutex.RLock()
	defer fake.listSecretExportsMutex.RUnlock()
	fake.uninstallPackageMutex.RLock()
	defer fake.uninstallPackageMutex.RUnlock()
	fake.uninstallPackageSyncMutex.RLock()
	defer fake.uninstallPackageSyncMutex.RUnlock()
	fake.updatePackageMutex.RLock()
	defer fake.updatePackageMutex.RUnlock()
	fake.updatePackageSyncMutex.RLock()
	defer fake.updatePackageSyncMutex.RUnlock()
	fake.updateRegistrySecretMutex.RLock()
	defer fake.updateRegistrySecretMutex.RUnlock()
	fake.updateRepositoryMutex.RLock()
	defer fake.updateRepositoryMutex.RUnlock()
	fake.updateRepositorySyncMutex.RLock()
	defer fake.updateRepositorySyncMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *TKGPackageClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ tkgpackageclient.TKGPackageClient = new(TKGPackageClient)
