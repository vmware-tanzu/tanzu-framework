# Copyright 2021 VMware, Inc. All Rights Reserved.
# SPDX-License-Identifier: Apache-2.0

def prog_checks():
    if prog_avail_local("docker") == "":
        log(prefix="Error", msg="docker program not found")
        return False

    if prog_avail_local("kind") == "":
        log(prefix="Error", msg="kind program not found")
        return False

    if prog_avail_local("kubectl") == "":
        log(prefix="Error", msg="kubectl program not found")
        return False

    return True

# retrieve_k8s
def capture_k8s_objects(k8sconf,cluster_name,nspaces):
    log(prefix="Info", msg="Retrieving pod logs: cluster={}; namespaces={}".format(cluster_name,nspaces))
    kube_capture(what="logs", namespaces=nspaces, kube_config=k8sconf)
    log(prefix="Info", msg="Retrieving API objects: cluster={}; namespaces={}".format(cluster_name,nspaces))
    kube_capture(what="objects", kinds=["pods", "services"], namespaces=nspaces, kube_config=k8sconf)
    kube_capture(what="objects", kinds=["deployments", "replicasets"], groups=["apps"], namespaces=nspaces, kube_config=k8sconf)
    kube_capture(what="objects", kinds=["apps"], groups=["kappctrl.k14s.io"], namespaces=["tkg-system"], kube_config=k8sconf)
    kube_capture(what="objects", kinds=["tanzukubernetesreleases"], groups=["run.tanzu.vmware.com"], kube_config=k8sconf)
    kube_capture(what="objects", kinds=["configmaps"], namespaces=["tkr-system"], kube_config=k8sconf)
    kube_capture(what="objects", categories=["cluster-api"], kube_config=k8sconf)

def capture_node_diagnostics(nodes):
    log(prefix="Info", msg="Capturing information for {} nodes".format(len(nodes)))
    capture(cmd="sudo df -i", resources=nodes)
    capture(cmd="sudo crictl info", resources=nodes)
    capture(cmd="df -h /var/lib/containerd", resources=nodes)
    capture(cmd="sudo systemctl status kubelet", resources=nodes)
    capture(cmd="sudo systemctl status containerd", resources=nodes)
    capture(cmd="sudo journalctl -xeu kubelet", resources=nodes)
    capture(cmd="sudo cat /var/log/cloud-init-output.log", resources=nodes)
    capture(cmd="sudo cat /var/log/cloud-init.log", resources=nodes)

# extract diagnostic info from local kind boostrap cluster
def diagnose_bootstrap_clusters():
    clusters=get_bootstrap_clusters()
    if len(clusters) == 0:
        log(prefix="Warn", msg="No `tkg-kind-*` bootstrap cluster found, skipping bootstrap cluster")
        return

    nspaces=[
        "capi-kubeadm-bootstrap-system",
        "capi-kubeadm-control-plane-system",
        "capi-system",
        "capi-webhook-system",
        "capv-system",
        "capa-system",
        "cert-manager",
        "tkg-system",
    ]

    # for each tkg-kind cluster:
    #  - capture kind logs, export kubecfg, and api objects
    for kind_cluster in clusters:
        wd = "{}/{}".format(args.workdir, kind_cluster)
        log(prefix="Info", msg="Retrieving node logs: cluster={}".format(kind_cluster))
        run_local("kind export logs --name {} {}/kind-logs".format(kind_cluster, wd))

        # extract kubeconfig file for cluster
        kind_cfg = capture_local(
            cmd="kind get kubeconfig --name {0}".format(kind_cluster),
            workdir="./",
            file_name="{}.kubecfg".format(kind_cluster)
        )

        conf = crashd_config(workdir=wd)
        k8sconf = kube_config(path=kind_cfg)

        capture_k8s_objects(k8sconf, kind_cluster, nspaces)
        archive(output_file="bootstrap.{}.diagnostics.tar.gz".format(kind_cluster), source_paths=[conf.workdir])


# return all bootstrap clusters in kind (tkg-kind-xxxx)
def get_bootstrap_clusters():
    clusters = run_local("kind get clusters").split('\n')
    result = []

    for cluster in clusters:
        if cluster.startswith("tkg-kind"):
            result.append(cluster)

    if len(result) > 0:
        log(prefix="Info", msg="Found tkg-kind-* clusters: {}".format(result))
    return result

# diagnose_workload_cluster retrieves cluster information
# from a non-management cluster.
def diagnose_workload_cluster(infra, name):
    if len(infra) == 0:
        log(prefix="Error", msg="Infra argument not provided")
        return

    kubeconfig = "{}/.kube/config".format(os.home)
    if hasattr(args, "kubeconfig"):
        kubeconfig = args.kubeconfig

    sshconfig = None
    if hasattr(args, "ssh_user") and hasattr(args, "ssh_pk_file"):
        sshconfig = ssh_config(username=args.ssh_user, private_key_path=args.ssh_pk_file)

    log(prefix="Info", msg="retrieving workload cluster info...")

    wd = "{}/{}".format(args.workdir, name)

    conf = crashd_config(workdir=wd)
    context_name = "{}-admin@{}".format(name, name)
    k8sconfig = kube_config(path=kubeconfig, cluster_context=context_name)
    log(prefix="Info", msg="Using kube_config:  kubeconfig={}; context={}".format(kubeconfig, context_name))

    nspaces=[
        "capi-kubeadm-bootstrap-system",
        "capi-kubeadm-control-plane-system",
        "capi-system",
        "capi-webhook-system",
        "cert-manager",
        "tkg-system",
        "kube-system",
        "tkr-system",
    ]

    if infra == "aws":
        nspaces.append("capa-system")
    else:
        nspaces.append("capv-system")

    capture_k8s_objects(k8sconfig, name, nspaces)

    # collect nodes data
    if sshconfig != None:
        nodes=resources(provider=kube_nodes_provider(kube_config=k8sconfig, ssh_config=sshconfig))
        capture_node_diagnostics(nodes)

    arc_file = "cluster.{}.diagnostics.tar.gz".format(name)
    log(prefix="Info", msg="Archiving: {}".format(arc_file))
    archive(output_file="cluster.{}.diagnostics.tar.gz".format(name), source_paths=[conf.workdir])


def diagnose():
    # program pre-checks
    if not prog_checks():
        log(prefix="Error", msg="One or more prerequisites are not met")
        return

    # argument validation
    infra = "docker"
    if hasattr(args, "infra") and len(args.cluster_name) > 0:
       infra = args.infra
    if not hasattr(args, "cluster_name") or len(args.cluster_name) == 0:
        log(prefix="Error", msg="cluster-name is required")
        return
    name = args.cluster_name

    log(msg="Collecting diagnostics: infra={}; cluster-name={}".format(infra, name))

    # diagnose boostrap cluster
    diagnose_bootstrap_clusters()

    # diagnose cluster
    diagnose_workload_cluster(infra, name)

    log(msg="Done!")


# starting point
diagnose()