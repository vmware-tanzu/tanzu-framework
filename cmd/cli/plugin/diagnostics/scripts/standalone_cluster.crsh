# Copyright 2021 VMware, Inc. All Rights Reserved.
# SPDX-License-Identifier: Apache-2.0

def prog_checks():
    if prog_avail_local("docker") == "":
        log(prefix="Error", msg="docker program not found")
        return False

    if prog_avail_local("kubectl") == "":
        log(prefix="Error", msg="kubectl program not found")
        return False

    return True

# retrieve_k8s
def capture_k8s_objects(k8sconf,cluster_name,nspaces):
    log(prefix="Info", msg="Retrieving pod logs: cluster={}; namespaces={}".format(cluster_name,nspaces))
    kube_capture(what="logs", namespaces=nspaces, kube_config=k8sconf)
    log(prefix="Info", msg="Retrieving API objects: cluster={}; namespaces={}".format(cluster_name,nspaces))
    kube_capture(what="objects", kinds=["pods", "services"], namespaces=nspaces, kube_config=k8sconf)
    kube_capture(what="objects", kinds=["deployments", "replicasets"], groups=["apps"], namespaces=nspaces, kube_config=k8sconf)
    kube_capture(what="objects", kinds=["apps"], groups=["kappctrl.k14s.io"], namespaces=["tkg-system"], kube_config=k8sconf)
    kube_capture(what="objects", kinds=["tanzukubernetesreleases"], groups=["run.tanzu.vmware.com"], kube_config=k8sconf)
    kube_capture(what="objects", kinds=["configmaps"], namespaces=["tkr-system"], kube_config=k8sconf)
    kube_capture(what="objects", categories=["cluster-api"], kube_config=k8sconf)

def capture_node_diagnostics(nodes):
    log(prefix="Info", msg="Capturing information for {} nodes".format(len(nodes)))
    capture(cmd="sudo df -i", resources=nodes)
    capture(cmd="sudo crictl info", resources=nodes)
    capture(cmd="df -h /var/lib/containerd", resources=nodes)
    capture(cmd="sudo systemctl status kubelet", resources=nodes)
    capture(cmd="sudo systemctl status containerd", resources=nodes)
    capture(cmd="sudo journalctl -xeu kubelet", resources=nodes)
    capture(cmd="sudo cat /var/log/cloud-init-output.log", resources=nodes)
    capture(cmd="sudo cat /var/log/cloud-init.log", resources=nodes)

# diagnose_workload_cluster retrieves cluster information
# from a non-management cluster.
def diagnose_workload_cluster():
    kubeconfig = "{}/.kube/config".format(os.home)
    if hasattr(args, "kubeconfig"):
        kubeconfig = args.kubeconfig

    # argument validation
    infra = "docker"
    if hasattr(args, "workload_infra") and len(args.workload_infra) > 0:
        infra = args.workload_infra

    if not hasattr(args, "workload_cluster_name") or len(args.workload_cluster_name) == 0:
        log(prefix="Error", msg="workload-cluster-name is required")
        return
    name = args.workload_cluster_name

    context_name = "{}-admin@{}".format(name, name)
    if hasattr(args, "workload_context") and len(args.workload_context) > 0:
        context_name = args.workload_context

    wd = "{}/{}".format(args.workdir, name)
    conf = crashd_config(workdir=wd)

    k8sconfig = kube_config(path=kubeconfig, cluster_context=context_name)
    log(prefix="Info", msg="Retrieving workload cluster: cluster={}; context={}; kubeconfig={};".format(name, context_name, kubeconfig))

    nspaces=[
        "capi-kubeadm-bootstrap-system",
        "capi-kubeadm-control-plane-system",
        "capi-system",
        "capi-webhook-system",
        "cert-manager",
        "tkg-system",
        "kube-system",
        "tkr-system",
    ]

    if infra == "aws":
        nspaces.append("capa-system")
    else:
        nspaces.append("capv-system")

    capture_k8s_objects(k8sconfig, name, nspaces)

    # collect nodes data
    sshconfig = None
    if hasattr(args, "ssh_user") and hasattr(args, "ssh_pk_file"):
        sshconfig = ssh_config(username=args.ssh_user, private_key_path=args.ssh_pk_file)

    if sshconfig != None:
        nodes=resources(provider=kube_nodes_provider(kube_config=k8sconfig, ssh_config=sshconfig))
        # capture_node_diagnostics(nodes)

    arc_file = "workload-cluster.{}.diagnostics.tar.gz".format(name)
    log(prefix="Info", msg="Archiving: {}".format(arc_file))
    archive(output_file=arc_file, source_paths=[conf.workdir])

def diagnose():
    # program pre-checks
    if not prog_checks():
        log(prefix="Error", msg="One or more prerequisites are not met")
        return

    # diagnose cluster
    diagnose_workload_cluster()

# starting point
diagnose()