// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"github.com/vmware-tanzu/tanzu-framework/pkg/v1/tkg/region"
)

type RegionManager struct {
	DeleteRegionContextStub        func(string) error
	deleteRegionContextMutex       sync.RWMutex
	deleteRegionContextArgsForCall []struct {
		arg1 string
	}
	deleteRegionContextReturns struct {
		result1 error
	}
	deleteRegionContextReturnsOnCall map[int]struct {
		result1 error
	}
	GetCurrentContextStub        func() (region.RegionContext, error)
	getCurrentContextMutex       sync.RWMutex
	getCurrentContextArgsForCall []struct {
	}
	getCurrentContextReturns struct {
		result1 region.RegionContext
		result2 error
	}
	getCurrentContextReturnsOnCall map[int]struct {
		result1 region.RegionContext
		result2 error
	}
	ListRegionContextsStub        func() ([]region.RegionContext, error)
	listRegionContextsMutex       sync.RWMutex
	listRegionContextsArgsForCall []struct {
	}
	listRegionContextsReturns struct {
		result1 []region.RegionContext
		result2 error
	}
	listRegionContextsReturnsOnCall map[int]struct {
		result1 []region.RegionContext
		result2 error
	}
	SaveRegionContextStub        func(region.RegionContext) error
	saveRegionContextMutex       sync.RWMutex
	saveRegionContextArgsForCall []struct {
		arg1 region.RegionContext
	}
	saveRegionContextReturns struct {
		result1 error
	}
	saveRegionContextReturnsOnCall map[int]struct {
		result1 error
	}
	SetCurrentContextStub        func(string, string) error
	setCurrentContextMutex       sync.RWMutex
	setCurrentContextArgsForCall []struct {
		arg1 string
		arg2 string
	}
	setCurrentContextReturns struct {
		result1 error
	}
	setCurrentContextReturnsOnCall map[int]struct {
		result1 error
	}
	UpsertRegionContextStub        func(region.RegionContext) error
	upsertRegionContextMutex       sync.RWMutex
	upsertRegionContextArgsForCall []struct {
		arg1 region.RegionContext
	}
	upsertRegionContextReturns struct {
		result1 error
	}
	upsertRegionContextReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *RegionManager) DeleteRegionContext(arg1 string) error {
	fake.deleteRegionContextMutex.Lock()
	ret, specificReturn := fake.deleteRegionContextReturnsOnCall[len(fake.deleteRegionContextArgsForCall)]
	fake.deleteRegionContextArgsForCall = append(fake.deleteRegionContextArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeleteRegionContextStub
	fakeReturns := fake.deleteRegionContextReturns
	fake.recordInvocation("DeleteRegionContext", []interface{}{arg1})
	fake.deleteRegionContextMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *RegionManager) DeleteRegionContextCallCount() int {
	fake.deleteRegionContextMutex.RLock()
	defer fake.deleteRegionContextMutex.RUnlock()
	return len(fake.deleteRegionContextArgsForCall)
}

func (fake *RegionManager) DeleteRegionContextCalls(stub func(string) error) {
	fake.deleteRegionContextMutex.Lock()
	defer fake.deleteRegionContextMutex.Unlock()
	fake.DeleteRegionContextStub = stub
}

func (fake *RegionManager) DeleteRegionContextArgsForCall(i int) string {
	fake.deleteRegionContextMutex.RLock()
	defer fake.deleteRegionContextMutex.RUnlock()
	argsForCall := fake.deleteRegionContextArgsForCall[i]
	return argsForCall.arg1
}

func (fake *RegionManager) DeleteRegionContextReturns(result1 error) {
	fake.deleteRegionContextMutex.Lock()
	defer fake.deleteRegionContextMutex.Unlock()
	fake.DeleteRegionContextStub = nil
	fake.deleteRegionContextReturns = struct {
		result1 error
	}{result1}
}

func (fake *RegionManager) DeleteRegionContextReturnsOnCall(i int, result1 error) {
	fake.deleteRegionContextMutex.Lock()
	defer fake.deleteRegionContextMutex.Unlock()
	fake.DeleteRegionContextStub = nil
	if fake.deleteRegionContextReturnsOnCall == nil {
		fake.deleteRegionContextReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteRegionContextReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *RegionManager) GetCurrentContext() (region.RegionContext, error) {
	fake.getCurrentContextMutex.Lock()
	ret, specificReturn := fake.getCurrentContextReturnsOnCall[len(fake.getCurrentContextArgsForCall)]
	fake.getCurrentContextArgsForCall = append(fake.getCurrentContextArgsForCall, struct {
	}{})
	stub := fake.GetCurrentContextStub
	fakeReturns := fake.getCurrentContextReturns
	fake.recordInvocation("GetCurrentContext", []interface{}{})
	fake.getCurrentContextMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *RegionManager) GetCurrentContextCallCount() int {
	fake.getCurrentContextMutex.RLock()
	defer fake.getCurrentContextMutex.RUnlock()
	return len(fake.getCurrentContextArgsForCall)
}

func (fake *RegionManager) GetCurrentContextCalls(stub func() (region.RegionContext, error)) {
	fake.getCurrentContextMutex.Lock()
	defer fake.getCurrentContextMutex.Unlock()
	fake.GetCurrentContextStub = stub
}

func (fake *RegionManager) GetCurrentContextReturns(result1 region.RegionContext, result2 error) {
	fake.getCurrentContextMutex.Lock()
	defer fake.getCurrentContextMutex.Unlock()
	fake.GetCurrentContextStub = nil
	fake.getCurrentContextReturns = struct {
		result1 region.RegionContext
		result2 error
	}{result1, result2}
}

func (fake *RegionManager) GetCurrentContextReturnsOnCall(i int, result1 region.RegionContext, result2 error) {
	fake.getCurrentContextMutex.Lock()
	defer fake.getCurrentContextMutex.Unlock()
	fake.GetCurrentContextStub = nil
	if fake.getCurrentContextReturnsOnCall == nil {
		fake.getCurrentContextReturnsOnCall = make(map[int]struct {
			result1 region.RegionContext
			result2 error
		})
	}
	fake.getCurrentContextReturnsOnCall[i] = struct {
		result1 region.RegionContext
		result2 error
	}{result1, result2}
}

func (fake *RegionManager) ListRegionContexts() ([]region.RegionContext, error) {
	fake.listRegionContextsMutex.Lock()
	ret, specificReturn := fake.listRegionContextsReturnsOnCall[len(fake.listRegionContextsArgsForCall)]
	fake.listRegionContextsArgsForCall = append(fake.listRegionContextsArgsForCall, struct {
	}{})
	stub := fake.ListRegionContextsStub
	fakeReturns := fake.listRegionContextsReturns
	fake.recordInvocation("ListRegionContexts", []interface{}{})
	fake.listRegionContextsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *RegionManager) ListRegionContextsCallCount() int {
	fake.listRegionContextsMutex.RLock()
	defer fake.listRegionContextsMutex.RUnlock()
	return len(fake.listRegionContextsArgsForCall)
}

func (fake *RegionManager) ListRegionContextsCalls(stub func() ([]region.RegionContext, error)) {
	fake.listRegionContextsMutex.Lock()
	defer fake.listRegionContextsMutex.Unlock()
	fake.ListRegionContextsStub = stub
}

func (fake *RegionManager) ListRegionContextsReturns(result1 []region.RegionContext, result2 error) {
	fake.listRegionContextsMutex.Lock()
	defer fake.listRegionContextsMutex.Unlock()
	fake.ListRegionContextsStub = nil
	fake.listRegionContextsReturns = struct {
		result1 []region.RegionContext
		result2 error
	}{result1, result2}
}

func (fake *RegionManager) ListRegionContextsReturnsOnCall(i int, result1 []region.RegionContext, result2 error) {
	fake.listRegionContextsMutex.Lock()
	defer fake.listRegionContextsMutex.Unlock()
	fake.ListRegionContextsStub = nil
	if fake.listRegionContextsReturnsOnCall == nil {
		fake.listRegionContextsReturnsOnCall = make(map[int]struct {
			result1 []region.RegionContext
			result2 error
		})
	}
	fake.listRegionContextsReturnsOnCall[i] = struct {
		result1 []region.RegionContext
		result2 error
	}{result1, result2}
}

func (fake *RegionManager) SaveRegionContext(arg1 region.RegionContext) error {
	fake.saveRegionContextMutex.Lock()
	ret, specificReturn := fake.saveRegionContextReturnsOnCall[len(fake.saveRegionContextArgsForCall)]
	fake.saveRegionContextArgsForCall = append(fake.saveRegionContextArgsForCall, struct {
		arg1 region.RegionContext
	}{arg1})
	stub := fake.SaveRegionContextStub
	fakeReturns := fake.saveRegionContextReturns
	fake.recordInvocation("SaveRegionContext", []interface{}{arg1})
	fake.saveRegionContextMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *RegionManager) SaveRegionContextCallCount() int {
	fake.saveRegionContextMutex.RLock()
	defer fake.saveRegionContextMutex.RUnlock()
	return len(fake.saveRegionContextArgsForCall)
}

func (fake *RegionManager) SaveRegionContextCalls(stub func(region.RegionContext) error) {
	fake.saveRegionContextMutex.Lock()
	defer fake.saveRegionContextMutex.Unlock()
	fake.SaveRegionContextStub = stub
}

func (fake *RegionManager) SaveRegionContextArgsForCall(i int) region.RegionContext {
	fake.saveRegionContextMutex.RLock()
	defer fake.saveRegionContextMutex.RUnlock()
	argsForCall := fake.saveRegionContextArgsForCall[i]
	return argsForCall.arg1
}

func (fake *RegionManager) SaveRegionContextReturns(result1 error) {
	fake.saveRegionContextMutex.Lock()
	defer fake.saveRegionContextMutex.Unlock()
	fake.SaveRegionContextStub = nil
	fake.saveRegionContextReturns = struct {
		result1 error
	}{result1}
}

func (fake *RegionManager) SaveRegionContextReturnsOnCall(i int, result1 error) {
	fake.saveRegionContextMutex.Lock()
	defer fake.saveRegionContextMutex.Unlock()
	fake.SaveRegionContextStub = nil
	if fake.saveRegionContextReturnsOnCall == nil {
		fake.saveRegionContextReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveRegionContextReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *RegionManager) SetCurrentContext(arg1 string, arg2 string) error {
	fake.setCurrentContextMutex.Lock()
	ret, specificReturn := fake.setCurrentContextReturnsOnCall[len(fake.setCurrentContextArgsForCall)]
	fake.setCurrentContextArgsForCall = append(fake.setCurrentContextArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.SetCurrentContextStub
	fakeReturns := fake.setCurrentContextReturns
	fake.recordInvocation("SetCurrentContext", []interface{}{arg1, arg2})
	fake.setCurrentContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *RegionManager) SetCurrentContextCallCount() int {
	fake.setCurrentContextMutex.RLock()
	defer fake.setCurrentContextMutex.RUnlock()
	return len(fake.setCurrentContextArgsForCall)
}

func (fake *RegionManager) SetCurrentContextCalls(stub func(string, string) error) {
	fake.setCurrentContextMutex.Lock()
	defer fake.setCurrentContextMutex.Unlock()
	fake.SetCurrentContextStub = stub
}

func (fake *RegionManager) SetCurrentContextArgsForCall(i int) (string, string) {
	fake.setCurrentContextMutex.RLock()
	defer fake.setCurrentContextMutex.RUnlock()
	argsForCall := fake.setCurrentContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *RegionManager) SetCurrentContextReturns(result1 error) {
	fake.setCurrentContextMutex.Lock()
	defer fake.setCurrentContextMutex.Unlock()
	fake.SetCurrentContextStub = nil
	fake.setCurrentContextReturns = struct {
		result1 error
	}{result1}
}

func (fake *RegionManager) SetCurrentContextReturnsOnCall(i int, result1 error) {
	fake.setCurrentContextMutex.Lock()
	defer fake.setCurrentContextMutex.Unlock()
	fake.SetCurrentContextStub = nil
	if fake.setCurrentContextReturnsOnCall == nil {
		fake.setCurrentContextReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setCurrentContextReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *RegionManager) UpsertRegionContext(arg1 region.RegionContext) error {
	fake.upsertRegionContextMutex.Lock()
	ret, specificReturn := fake.upsertRegionContextReturnsOnCall[len(fake.upsertRegionContextArgsForCall)]
	fake.upsertRegionContextArgsForCall = append(fake.upsertRegionContextArgsForCall, struct {
		arg1 region.RegionContext
	}{arg1})
	stub := fake.UpsertRegionContextStub
	fakeReturns := fake.upsertRegionContextReturns
	fake.recordInvocation("UpsertRegionContext", []interface{}{arg1})
	fake.upsertRegionContextMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *RegionManager) UpsertRegionContextCallCount() int {
	fake.upsertRegionContextMutex.RLock()
	defer fake.upsertRegionContextMutex.RUnlock()
	return len(fake.upsertRegionContextArgsForCall)
}

func (fake *RegionManager) UpsertRegionContextCalls(stub func(region.RegionContext) error) {
	fake.upsertRegionContextMutex.Lock()
	defer fake.upsertRegionContextMutex.Unlock()
	fake.UpsertRegionContextStub = stub
}

func (fake *RegionManager) UpsertRegionContextArgsForCall(i int) region.RegionContext {
	fake.upsertRegionContextMutex.RLock()
	defer fake.upsertRegionContextMutex.RUnlock()
	argsForCall := fake.upsertRegionContextArgsForCall[i]
	return argsForCall.arg1
}

func (fake *RegionManager) UpsertRegionContextReturns(result1 error) {
	fake.upsertRegionContextMutex.Lock()
	defer fake.upsertRegionContextMutex.Unlock()
	fake.UpsertRegionContextStub = nil
	fake.upsertRegionContextReturns = struct {
		result1 error
	}{result1}
}

func (fake *RegionManager) UpsertRegionContextReturnsOnCall(i int, result1 error) {
	fake.upsertRegionContextMutex.Lock()
	defer fake.upsertRegionContextMutex.Unlock()
	fake.UpsertRegionContextStub = nil
	if fake.upsertRegionContextReturnsOnCall == nil {
		fake.upsertRegionContextReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.upsertRegionContextReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *RegionManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.deleteRegionContextMutex.RLock()
	defer fake.deleteRegionContextMutex.RUnlock()
	fake.getCurrentContextMutex.RLock()
	defer fake.getCurrentContextMutex.RUnlock()
	fake.listRegionContextsMutex.RLock()
	defer fake.listRegionContextsMutex.RUnlock()
	fake.saveRegionContextMutex.RLock()
	defer fake.saveRegionContextMutex.RUnlock()
	fake.setCurrentContextMutex.RLock()
	defer fake.setCurrentContextMutex.RUnlock()
	fake.upsertRegionContextMutex.RLock()
	defer fake.upsertRegionContextMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *RegionManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ region.Manager = new(RegionManager)
