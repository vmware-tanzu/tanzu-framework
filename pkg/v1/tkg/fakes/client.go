// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"
	"time"

	"sigs.k8s.io/cluster-api/api/v1alpha3"
	v1alpha3a "sigs.k8s.io/cluster-api/cmd/clusterctl/api/v1alpha3"
	"sigs.k8s.io/cluster-api/cmd/clusterctl/client/tree"

	"github.com/vmware-tanzu/tanzu-framework/apis/run/v1alpha1"
	"github.com/vmware-tanzu/tanzu-framework/apis/run/v1alpha2"
	"github.com/vmware-tanzu/tanzu-framework/pkg/v1/tkg/client"
	"github.com/vmware-tanzu/tanzu-framework/pkg/v1/tkg/clusterclient"
	"github.com/vmware-tanzu/tanzu-framework/pkg/v1/tkg/region"
	"github.com/vmware-tanzu/tanzu-framework/pkg/v1/tkg/tkgconfigreaderwriter"
	"github.com/vmware-tanzu/tanzu-framework/pkg/v1/tkg/vc"
)

type Client struct {
	ActivateTanzuKubernetesReleasesStub        func(string) error
	activateTanzuKubernetesReleasesMutex       sync.RWMutex
	activateTanzuKubernetesReleasesArgsForCall []struct {
		arg1 string
	}
	activateTanzuKubernetesReleasesReturns struct {
		result1 error
	}
	activateTanzuKubernetesReleasesReturnsOnCall map[int]struct {
		result1 error
	}
	AddRegionContextStub        func(region.RegionContext, bool, bool) error
	addRegionContextMutex       sync.RWMutex
	addRegionContextArgsForCall []struct {
		arg1 region.RegionContext
		arg2 bool
		arg3 bool
	}
	addRegionContextReturns struct {
		result1 error
	}
	addRegionContextReturnsOnCall map[int]struct {
		result1 error
	}
	ConfigureAndValidateManagementClusterConfigurationStub        func(*client.InitRegionOptions, bool) *client.ValidationError
	configureAndValidateManagementClusterConfigurationMutex       sync.RWMutex
	configureAndValidateManagementClusterConfigurationArgsForCall []struct {
		arg1 *client.InitRegionOptions
		arg2 bool
	}
	configureAndValidateManagementClusterConfigurationReturns struct {
		result1 *client.ValidationError
	}
	configureAndValidateManagementClusterConfigurationReturnsOnCall map[int]struct {
		result1 *client.ValidationError
	}
	ConfigureAndValidateTkrVersionStub        func(string) (string, string, error)
	configureAndValidateTkrVersionMutex       sync.RWMutex
	configureAndValidateTkrVersionArgsForCall []struct {
		arg1 string
	}
	configureAndValidateTkrVersionReturns struct {
		result1 string
		result2 string
		result3 error
	}
	configureAndValidateTkrVersionReturnsOnCall map[int]struct {
		result1 string
		result2 string
		result3 error
	}
	ConfigureTimeoutStub        func(time.Duration)
	configureTimeoutMutex       sync.RWMutex
	configureTimeoutArgsForCall []struct {
		arg1 time.Duration
	}
	CreateAWSCloudFormationStackStub        func() error
	createAWSCloudFormationStackMutex       sync.RWMutex
	createAWSCloudFormationStackArgsForCall []struct {
	}
	createAWSCloudFormationStackReturns struct {
		result1 error
	}
	createAWSCloudFormationStackReturnsOnCall map[int]struct {
		result1 error
	}
	CreateClusterStub        func(*client.CreateClusterOptions, bool) error
	createClusterMutex       sync.RWMutex
	createClusterArgsForCall []struct {
		arg1 *client.CreateClusterOptions
		arg2 bool
	}
	createClusterReturns struct {
		result1 error
	}
	createClusterReturnsOnCall map[int]struct {
		result1 error
	}
	DeRegisterManagementClusterFromTmcStub        func(string) error
	deRegisterManagementClusterFromTmcMutex       sync.RWMutex
	deRegisterManagementClusterFromTmcArgsForCall []struct {
		arg1 string
	}
	deRegisterManagementClusterFromTmcReturns struct {
		result1 error
	}
	deRegisterManagementClusterFromTmcReturnsOnCall map[int]struct {
		result1 error
	}
	DeactivateTanzuKubernetesReleasesStub        func(string) error
	deactivateTanzuKubernetesReleasesMutex       sync.RWMutex
	deactivateTanzuKubernetesReleasesArgsForCall []struct {
		arg1 string
	}
	deactivateTanzuKubernetesReleasesReturns struct {
		result1 error
	}
	deactivateTanzuKubernetesReleasesReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteMachineDeploymentStub        func(client.DeleteMachineDeploymentOptions) error
	deleteMachineDeploymentMutex       sync.RWMutex
	deleteMachineDeploymentArgsForCall []struct {
		arg1 client.DeleteMachineDeploymentOptions
	}
	deleteMachineDeploymentReturns struct {
		result1 error
	}
	deleteMachineDeploymentReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteMachineHealthCheckStub        func(client.MachineHealthCheckOptions) error
	deleteMachineHealthCheckMutex       sync.RWMutex
	deleteMachineHealthCheckArgsForCall []struct {
		arg1 client.MachineHealthCheckOptions
	}
	deleteMachineHealthCheckReturns struct {
		result1 error
	}
	deleteMachineHealthCheckReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteRegionStub        func(client.DeleteRegionOptions) error
	deleteRegionMutex       sync.RWMutex
	deleteRegionArgsForCall []struct {
		arg1 client.DeleteRegionOptions
	}
	deleteRegionReturns struct {
		result1 error
	}
	deleteRegionReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteWorkloadClusterStub        func(client.DeleteWorkloadClusterOptions) error
	deleteWorkloadClusterMutex       sync.RWMutex
	deleteWorkloadClusterArgsForCall []struct {
		arg1 client.DeleteWorkloadClusterOptions
	}
	deleteWorkloadClusterReturns struct {
		result1 error
	}
	deleteWorkloadClusterReturnsOnCall map[int]struct {
		result1 error
	}
	DescribeClusterStub        func(client.DescribeTKGClustersOptions) (*tree.ObjectTree, *v1alpha3.Cluster, *v1alpha3a.ProviderList, error)
	describeClusterMutex       sync.RWMutex
	describeClusterArgsForCall []struct {
		arg1 client.DescribeTKGClustersOptions
	}
	describeClusterReturns struct {
		result1 *tree.ObjectTree
		result2 *v1alpha3.Cluster
		result3 *v1alpha3a.ProviderList
		result4 error
	}
	describeClusterReturnsOnCall map[int]struct {
		result1 *tree.ObjectTree
		result2 *v1alpha3.Cluster
		result3 *v1alpha3a.ProviderList
		result4 error
	}
	DescribeProviderStub        func() (*v1alpha3a.ProviderList, error)
	describeProviderMutex       sync.RWMutex
	describeProviderArgsForCall []struct {
	}
	describeProviderReturns struct {
		result1 *v1alpha3a.ProviderList
		result2 error
	}
	describeProviderReturnsOnCall map[int]struct {
		result1 *v1alpha3a.ProviderList
		result2 error
	}
	DownloadBomFileStub        func(string) error
	downloadBomFileMutex       sync.RWMutex
	downloadBomFileArgsForCall []struct {
		arg1 string
	}
	downloadBomFileReturns struct {
		result1 error
	}
	downloadBomFileReturnsOnCall map[int]struct {
		result1 error
	}
	GetCEIPParticipationStub        func() (client.ClusterCeipInfo, error)
	getCEIPParticipationMutex       sync.RWMutex
	getCEIPParticipationArgsForCall []struct {
	}
	getCEIPParticipationReturns struct {
		result1 client.ClusterCeipInfo
		result2 error
	}
	getCEIPParticipationReturnsOnCall map[int]struct {
		result1 client.ClusterCeipInfo
		result2 error
	}
	GetClusterConfigurationStub        func(*client.CreateClusterOptions) ([]byte, error)
	getClusterConfigurationMutex       sync.RWMutex
	getClusterConfigurationArgsForCall []struct {
		arg1 *client.CreateClusterOptions
	}
	getClusterConfigurationReturns struct {
		result1 []byte
		result2 error
	}
	getClusterConfigurationReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	GetClusterPinnipedInfoStub        func(client.GetClusterPinnipedInfoOptions) (*client.ClusterPinnipedInfo, error)
	getClusterPinnipedInfoMutex       sync.RWMutex
	getClusterPinnipedInfoArgsForCall []struct {
		arg1 client.GetClusterPinnipedInfoOptions
	}
	getClusterPinnipedInfoReturns struct {
		result1 *client.ClusterPinnipedInfo
		result2 error
	}
	getClusterPinnipedInfoReturnsOnCall map[int]struct {
		result1 *client.ClusterPinnipedInfo
		result2 error
	}
	GetCurrentRegionContextStub        func() (region.RegionContext, error)
	getCurrentRegionContextMutex       sync.RWMutex
	getCurrentRegionContextArgsForCall []struct {
	}
	getCurrentRegionContextReturns struct {
		result1 region.RegionContext
		result2 error
	}
	getCurrentRegionContextReturnsOnCall map[int]struct {
		result1 region.RegionContext
		result2 error
	}
	GetKubernetesVersionsStub        func() (*client.KubernetesVersionsInfo, error)
	getKubernetesVersionsMutex       sync.RWMutex
	getKubernetesVersionsArgsForCall []struct {
	}
	getKubernetesVersionsReturns struct {
		result1 *client.KubernetesVersionsInfo
		result2 error
	}
	getKubernetesVersionsReturnsOnCall map[int]struct {
		result1 *client.KubernetesVersionsInfo
		result2 error
	}
	GetMachineDeploymentsStub        func(client.GetMachineDeploymentOptions) ([]v1alpha3.MachineDeployment, error)
	getMachineDeploymentsMutex       sync.RWMutex
	getMachineDeploymentsArgsForCall []struct {
		arg1 client.GetMachineDeploymentOptions
	}
	getMachineDeploymentsReturns struct {
		result1 []v1alpha3.MachineDeployment
		result2 error
	}
	getMachineDeploymentsReturnsOnCall map[int]struct {
		result1 []v1alpha3.MachineDeployment
		result2 error
	}
	GetMachineHealthChecksStub        func(client.MachineHealthCheckOptions) ([]client.MachineHealthCheck, error)
	getMachineHealthChecksMutex       sync.RWMutex
	getMachineHealthChecksArgsForCall []struct {
		arg1 client.MachineHealthCheckOptions
	}
	getMachineHealthChecksReturns struct {
		result1 []client.MachineHealthCheck
		result2 error
	}
	getMachineHealthChecksReturnsOnCall map[int]struct {
		result1 []client.MachineHealthCheck
		result2 error
	}
	GetPacificClusterObjectStub        func(string, string) (*v1alpha2.TanzuKubernetesCluster, error)
	getPacificClusterObjectMutex       sync.RWMutex
	getPacificClusterObjectArgsForCall []struct {
		arg1 string
		arg2 string
	}
	getPacificClusterObjectReturns struct {
		result1 *v1alpha2.TanzuKubernetesCluster
		result2 error
	}
	getPacificClusterObjectReturnsOnCall map[int]struct {
		result1 *v1alpha2.TanzuKubernetesCluster
		result2 error
	}
	GetPacificMachineDeploymentsStub        func(client.GetMachineDeploymentOptions) ([]v1alpha3.MachineDeployment, error)
	getPacificMachineDeploymentsMutex       sync.RWMutex
	getPacificMachineDeploymentsArgsForCall []struct {
		arg1 client.GetMachineDeploymentOptions
	}
	getPacificMachineDeploymentsReturns struct {
		result1 []v1alpha3.MachineDeployment
		result2 error
	}
	getPacificMachineDeploymentsReturnsOnCall map[int]struct {
		result1 []v1alpha3.MachineDeployment
		result2 error
	}
	GetRegionContextsStub        func(string) ([]region.RegionContext, error)
	getRegionContextsMutex       sync.RWMutex
	getRegionContextsArgsForCall []struct {
		arg1 string
	}
	getRegionContextsReturns struct {
		result1 []region.RegionContext
		result2 error
	}
	getRegionContextsReturnsOnCall map[int]struct {
		result1 []region.RegionContext
		result2 error
	}
	GetTanzuKubernetesReleasesStub        func(string) ([]v1alpha1.TanzuKubernetesRelease, error)
	getTanzuKubernetesReleasesMutex       sync.RWMutex
	getTanzuKubernetesReleasesArgsForCall []struct {
		arg1 string
	}
	getTanzuKubernetesReleasesReturns struct {
		result1 []v1alpha1.TanzuKubernetesRelease
		result2 error
	}
	getTanzuKubernetesReleasesReturnsOnCall map[int]struct {
		result1 []v1alpha1.TanzuKubernetesRelease
		result2 error
	}
	GetVSphereEndpointStub        func(clusterclient.Client) (vc.Client, error)
	getVSphereEndpointMutex       sync.RWMutex
	getVSphereEndpointArgsForCall []struct {
		arg1 clusterclient.Client
	}
	getVSphereEndpointReturns struct {
		result1 vc.Client
		result2 error
	}
	getVSphereEndpointReturnsOnCall map[int]struct {
		result1 vc.Client
		result2 error
	}
	GetWorkloadClusterCredentialsStub        func(client.GetWorkloadClusterCredentialsOptions) (string, string, error)
	getWorkloadClusterCredentialsMutex       sync.RWMutex
	getWorkloadClusterCredentialsArgsForCall []struct {
		arg1 client.GetWorkloadClusterCredentialsOptions
	}
	getWorkloadClusterCredentialsReturns struct {
		result1 string
		result2 string
		result3 error
	}
	getWorkloadClusterCredentialsReturnsOnCall map[int]struct {
		result1 string
		result2 string
		result3 error
	}
	InitRegionStub        func(*client.InitRegionOptions) error
	initRegionMutex       sync.RWMutex
	initRegionArgsForCall []struct {
		arg1 *client.InitRegionOptions
	}
	initRegionReturns struct {
		result1 error
	}
	initRegionReturnsOnCall map[int]struct {
		result1 error
	}
	InitRegionDryRunStub        func(*client.InitRegionOptions) ([]byte, error)
	initRegionDryRunMutex       sync.RWMutex
	initRegionDryRunArgsForCall []struct {
		arg1 *client.InitRegionOptions
	}
	initRegionDryRunReturns struct {
		result1 []byte
		result2 error
	}
	initRegionDryRunReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	IsManagementClusterAKindClusterStub        func(string) (bool, error)
	isManagementClusterAKindClusterMutex       sync.RWMutex
	isManagementClusterAKindClusterArgsForCall []struct {
		arg1 string
	}
	isManagementClusterAKindClusterReturns struct {
		result1 bool
		result2 error
	}
	isManagementClusterAKindClusterReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	IsPacificManagementClusterStub        func() (bool, error)
	isPacificManagementClusterMutex       sync.RWMutex
	isPacificManagementClusterArgsForCall []struct {
	}
	isPacificManagementClusterReturns struct {
		result1 bool
		result2 error
	}
	isPacificManagementClusterReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	IsPacificRegionalClusterStub        func() (bool, error)
	isPacificRegionalClusterMutex       sync.RWMutex
	isPacificRegionalClusterArgsForCall []struct {
	}
	isPacificRegionalClusterReturns struct {
		result1 bool
		result2 error
	}
	isPacificRegionalClusterReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	ListTKGClustersStub        func(client.ListTKGClustersOptions) ([]client.ClusterInfo, error)
	listTKGClustersMutex       sync.RWMutex
	listTKGClustersArgsForCall []struct {
		arg1 client.ListTKGClustersOptions
	}
	listTKGClustersReturns struct {
		result1 []client.ClusterInfo
		result2 error
	}
	listTKGClustersReturnsOnCall map[int]struct {
		result1 []client.ClusterInfo
		result2 error
	}
	ParseHiddenArgsAsFeatureFlagsStub        func(*client.InitRegionOptions)
	parseHiddenArgsAsFeatureFlagsMutex       sync.RWMutex
	parseHiddenArgsAsFeatureFlagsArgsForCall []struct {
		arg1 *client.InitRegionOptions
	}
	RegisterManagementClusterToTmcStub        func(string, string) error
	registerManagementClusterToTmcMutex       sync.RWMutex
	registerManagementClusterToTmcArgsForCall []struct {
		arg1 string
		arg2 string
	}
	registerManagementClusterToTmcReturns struct {
		result1 error
	}
	registerManagementClusterToTmcReturnsOnCall map[int]struct {
		result1 error
	}
	SaveFeatureFlagsStub        func(map[string]string) error
	saveFeatureFlagsMutex       sync.RWMutex
	saveFeatureFlagsArgsForCall []struct {
		arg1 map[string]string
	}
	saveFeatureFlagsReturns struct {
		result1 error
	}
	saveFeatureFlagsReturnsOnCall map[int]struct {
		result1 error
	}
	ScaleClusterStub        func(client.ScaleClusterOptions) error
	scaleClusterMutex       sync.RWMutex
	scaleClusterArgsForCall []struct {
		arg1 client.ScaleClusterOptions
	}
	scaleClusterReturns struct {
		result1 error
	}
	scaleClusterReturnsOnCall map[int]struct {
		result1 error
	}
	SetCEIPParticipationStub        func(bool, string, string) error
	setCEIPParticipationMutex       sync.RWMutex
	setCEIPParticipationArgsForCall []struct {
		arg1 bool
		arg2 string
		arg3 string
	}
	setCEIPParticipationReturns struct {
		result1 error
	}
	setCEIPParticipationReturnsOnCall map[int]struct {
		result1 error
	}
	SetMachineDeploymentStub        func(*client.SetMachineDeploymentOptions) error
	setMachineDeploymentMutex       sync.RWMutex
	setMachineDeploymentArgsForCall []struct {
		arg1 *client.SetMachineDeploymentOptions
	}
	setMachineDeploymentReturns struct {
		result1 error
	}
	setMachineDeploymentReturnsOnCall map[int]struct {
		result1 error
	}
	SetMachineHealthCheckStub        func(*client.SetMachineHealthCheckOptions) error
	setMachineHealthCheckMutex       sync.RWMutex
	setMachineHealthCheckArgsForCall []struct {
		arg1 *client.SetMachineHealthCheckOptions
	}
	setMachineHealthCheckReturns struct {
		result1 error
	}
	setMachineHealthCheckReturnsOnCall map[int]struct {
		result1 error
	}
	SetRegionContextStub        func(string, string) error
	setRegionContextMutex       sync.RWMutex
	setRegionContextArgsForCall []struct {
		arg1 string
		arg2 string
	}
	setRegionContextReturns struct {
		result1 error
	}
	setRegionContextReturnsOnCall map[int]struct {
		result1 error
	}
	TKGConfigReaderWriterStub        func() tkgconfigreaderwriter.TKGConfigReaderWriter
	tKGConfigReaderWriterMutex       sync.RWMutex
	tKGConfigReaderWriterArgsForCall []struct {
	}
	tKGConfigReaderWriterReturns struct {
		result1 tkgconfigreaderwriter.TKGConfigReaderWriter
	}
	tKGConfigReaderWriterReturnsOnCall map[int]struct {
		result1 tkgconfigreaderwriter.TKGConfigReaderWriter
	}
	UpdateCredentialsClusterStub        func(*client.UpdateCredentialsOptions) error
	updateCredentialsClusterMutex       sync.RWMutex
	updateCredentialsClusterArgsForCall []struct {
		arg1 *client.UpdateCredentialsOptions
	}
	updateCredentialsClusterReturns struct {
		result1 error
	}
	updateCredentialsClusterReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateCredentialsRegionStub        func(*client.UpdateCredentialsOptions) error
	updateCredentialsRegionMutex       sync.RWMutex
	updateCredentialsRegionArgsForCall []struct {
		arg1 *client.UpdateCredentialsOptions
	}
	updateCredentialsRegionReturns struct {
		result1 error
	}
	updateCredentialsRegionReturnsOnCall map[int]struct {
		result1 error
	}
	UpgradeClusterStub        func(*client.UpgradeClusterOptions) error
	upgradeClusterMutex       sync.RWMutex
	upgradeClusterArgsForCall []struct {
		arg1 *client.UpgradeClusterOptions
	}
	upgradeClusterReturns struct {
		result1 error
	}
	upgradeClusterReturnsOnCall map[int]struct {
		result1 error
	}
	UpgradeManagementClusterStub        func(*client.UpgradeClusterOptions) error
	upgradeManagementClusterMutex       sync.RWMutex
	upgradeManagementClusterArgsForCall []struct {
		arg1 *client.UpgradeClusterOptions
	}
	upgradeManagementClusterReturns struct {
		result1 error
	}
	upgradeManagementClusterReturnsOnCall map[int]struct {
		result1 error
	}
	ValidatePrerequisitesStub        func(bool, bool) error
	validatePrerequisitesMutex       sync.RWMutex
	validatePrerequisitesArgsForCall []struct {
		arg1 bool
		arg2 bool
	}
	validatePrerequisitesReturns struct {
		result1 error
	}
	validatePrerequisitesReturnsOnCall map[int]struct {
		result1 error
	}
	VerifyRegionStub        func(string) (region.RegionContext, error)
	verifyRegionMutex       sync.RWMutex
	verifyRegionArgsForCall []struct {
		arg1 string
	}
	verifyRegionReturns struct {
		result1 region.RegionContext
		result2 error
	}
	verifyRegionReturnsOnCall map[int]struct {
		result1 region.RegionContext
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *Client) ActivateTanzuKubernetesReleases(arg1 string) error {
	fake.activateTanzuKubernetesReleasesMutex.Lock()
	ret, specificReturn := fake.activateTanzuKubernetesReleasesReturnsOnCall[len(fake.activateTanzuKubernetesReleasesArgsForCall)]
	fake.activateTanzuKubernetesReleasesArgsForCall = append(fake.activateTanzuKubernetesReleasesArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ActivateTanzuKubernetesReleasesStub
	fakeReturns := fake.activateTanzuKubernetesReleasesReturns
	fake.recordInvocation("ActivateTanzuKubernetesReleases", []interface{}{arg1})
	fake.activateTanzuKubernetesReleasesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Client) ActivateTanzuKubernetesReleasesCallCount() int {
	fake.activateTanzuKubernetesReleasesMutex.RLock()
	defer fake.activateTanzuKubernetesReleasesMutex.RUnlock()
	return len(fake.activateTanzuKubernetesReleasesArgsForCall)
}

func (fake *Client) ActivateTanzuKubernetesReleasesCalls(stub func(string) error) {
	fake.activateTanzuKubernetesReleasesMutex.Lock()
	defer fake.activateTanzuKubernetesReleasesMutex.Unlock()
	fake.ActivateTanzuKubernetesReleasesStub = stub
}

func (fake *Client) ActivateTanzuKubernetesReleasesArgsForCall(i int) string {
	fake.activateTanzuKubernetesReleasesMutex.RLock()
	defer fake.activateTanzuKubernetesReleasesMutex.RUnlock()
	argsForCall := fake.activateTanzuKubernetesReleasesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) ActivateTanzuKubernetesReleasesReturns(result1 error) {
	fake.activateTanzuKubernetesReleasesMutex.Lock()
	defer fake.activateTanzuKubernetesReleasesMutex.Unlock()
	fake.ActivateTanzuKubernetesReleasesStub = nil
	fake.activateTanzuKubernetesReleasesReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) ActivateTanzuKubernetesReleasesReturnsOnCall(i int, result1 error) {
	fake.activateTanzuKubernetesReleasesMutex.Lock()
	defer fake.activateTanzuKubernetesReleasesMutex.Unlock()
	fake.ActivateTanzuKubernetesReleasesStub = nil
	if fake.activateTanzuKubernetesReleasesReturnsOnCall == nil {
		fake.activateTanzuKubernetesReleasesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.activateTanzuKubernetesReleasesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Client) AddRegionContext(arg1 region.RegionContext, arg2 bool, arg3 bool) error {
	fake.addRegionContextMutex.Lock()
	ret, specificReturn := fake.addRegionContextReturnsOnCall[len(fake.addRegionContextArgsForCall)]
	fake.addRegionContextArgsForCall = append(fake.addRegionContextArgsForCall, struct {
		arg1 region.RegionContext
		arg2 bool
		arg3 bool
	}{arg1, arg2, arg3})
	stub := fake.AddRegionContextStub
	fakeReturns := fake.addRegionContextReturns
	fake.recordInvocation("AddRegionContext", []interface{}{arg1, arg2, arg3})
	fake.addRegionContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Client) AddRegionContextCallCount() int {
	fake.addRegionContextMutex.RLock()
	defer fake.addRegionContextMutex.RUnlock()
	return len(fake.addRegionContextArgsForCall)
}

func (fake *Client) AddRegionContextCalls(stub func(region.RegionContext, bool, bool) error) {
	fake.addRegionContextMutex.Lock()
	defer fake.addRegionContextMutex.Unlock()
	fake.AddRegionContextStub = stub
}

func (fake *Client) AddRegionContextArgsForCall(i int) (region.RegionContext, bool, bool) {
	fake.addRegionContextMutex.RLock()
	defer fake.addRegionContextMutex.RUnlock()
	argsForCall := fake.addRegionContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Client) AddRegionContextReturns(result1 error) {
	fake.addRegionContextMutex.Lock()
	defer fake.addRegionContextMutex.Unlock()
	fake.AddRegionContextStub = nil
	fake.addRegionContextReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) AddRegionContextReturnsOnCall(i int, result1 error) {
	fake.addRegionContextMutex.Lock()
	defer fake.addRegionContextMutex.Unlock()
	fake.AddRegionContextStub = nil
	if fake.addRegionContextReturnsOnCall == nil {
		fake.addRegionContextReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addRegionContextReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Client) ConfigureAndValidateManagementClusterConfiguration(arg1 *client.InitRegionOptions, arg2 bool) *client.ValidationError {
	fake.configureAndValidateManagementClusterConfigurationMutex.Lock()
	ret, specificReturn := fake.configureAndValidateManagementClusterConfigurationReturnsOnCall[len(fake.configureAndValidateManagementClusterConfigurationArgsForCall)]
	fake.configureAndValidateManagementClusterConfigurationArgsForCall = append(fake.configureAndValidateManagementClusterConfigurationArgsForCall, struct {
		arg1 *client.InitRegionOptions
		arg2 bool
	}{arg1, arg2})
	stub := fake.ConfigureAndValidateManagementClusterConfigurationStub
	fakeReturns := fake.configureAndValidateManagementClusterConfigurationReturns
	fake.recordInvocation("ConfigureAndValidateManagementClusterConfiguration", []interface{}{arg1, arg2})
	fake.configureAndValidateManagementClusterConfigurationMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Client) ConfigureAndValidateManagementClusterConfigurationCallCount() int {
	fake.configureAndValidateManagementClusterConfigurationMutex.RLock()
	defer fake.configureAndValidateManagementClusterConfigurationMutex.RUnlock()
	return len(fake.configureAndValidateManagementClusterConfigurationArgsForCall)
}

func (fake *Client) ConfigureAndValidateManagementClusterConfigurationCalls(stub func(*client.InitRegionOptions, bool) *client.ValidationError) {
	fake.configureAndValidateManagementClusterConfigurationMutex.Lock()
	defer fake.configureAndValidateManagementClusterConfigurationMutex.Unlock()
	fake.ConfigureAndValidateManagementClusterConfigurationStub = stub
}

func (fake *Client) ConfigureAndValidateManagementClusterConfigurationArgsForCall(i int) (*client.InitRegionOptions, bool) {
	fake.configureAndValidateManagementClusterConfigurationMutex.RLock()
	defer fake.configureAndValidateManagementClusterConfigurationMutex.RUnlock()
	argsForCall := fake.configureAndValidateManagementClusterConfigurationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Client) ConfigureAndValidateManagementClusterConfigurationReturns(result1 *client.ValidationError) {
	fake.configureAndValidateManagementClusterConfigurationMutex.Lock()
	defer fake.configureAndValidateManagementClusterConfigurationMutex.Unlock()
	fake.ConfigureAndValidateManagementClusterConfigurationStub = nil
	fake.configureAndValidateManagementClusterConfigurationReturns = struct {
		result1 *client.ValidationError
	}{result1}
}

func (fake *Client) ConfigureAndValidateManagementClusterConfigurationReturnsOnCall(i int, result1 *client.ValidationError) {
	fake.configureAndValidateManagementClusterConfigurationMutex.Lock()
	defer fake.configureAndValidateManagementClusterConfigurationMutex.Unlock()
	fake.ConfigureAndValidateManagementClusterConfigurationStub = nil
	if fake.configureAndValidateManagementClusterConfigurationReturnsOnCall == nil {
		fake.configureAndValidateManagementClusterConfigurationReturnsOnCall = make(map[int]struct {
			result1 *client.ValidationError
		})
	}
	fake.configureAndValidateManagementClusterConfigurationReturnsOnCall[i] = struct {
		result1 *client.ValidationError
	}{result1}
}

func (fake *Client) ConfigureAndValidateTkrVersion(arg1 string) (string, string, error) {
	fake.configureAndValidateTkrVersionMutex.Lock()
	ret, specificReturn := fake.configureAndValidateTkrVersionReturnsOnCall[len(fake.configureAndValidateTkrVersionArgsForCall)]
	fake.configureAndValidateTkrVersionArgsForCall = append(fake.configureAndValidateTkrVersionArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ConfigureAndValidateTkrVersionStub
	fakeReturns := fake.configureAndValidateTkrVersionReturns
	fake.recordInvocation("ConfigureAndValidateTkrVersion", []interface{}{arg1})
	fake.configureAndValidateTkrVersionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *Client) ConfigureAndValidateTkrVersionCallCount() int {
	fake.configureAndValidateTkrVersionMutex.RLock()
	defer fake.configureAndValidateTkrVersionMutex.RUnlock()
	return len(fake.configureAndValidateTkrVersionArgsForCall)
}

func (fake *Client) ConfigureAndValidateTkrVersionCalls(stub func(string) (string, string, error)) {
	fake.configureAndValidateTkrVersionMutex.Lock()
	defer fake.configureAndValidateTkrVersionMutex.Unlock()
	fake.ConfigureAndValidateTkrVersionStub = stub
}

func (fake *Client) ConfigureAndValidateTkrVersionArgsForCall(i int) string {
	fake.configureAndValidateTkrVersionMutex.RLock()
	defer fake.configureAndValidateTkrVersionMutex.RUnlock()
	argsForCall := fake.configureAndValidateTkrVersionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) ConfigureAndValidateTkrVersionReturns(result1 string, result2 string, result3 error) {
	fake.configureAndValidateTkrVersionMutex.Lock()
	defer fake.configureAndValidateTkrVersionMutex.Unlock()
	fake.ConfigureAndValidateTkrVersionStub = nil
	fake.configureAndValidateTkrVersionReturns = struct {
		result1 string
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *Client) ConfigureAndValidateTkrVersionReturnsOnCall(i int, result1 string, result2 string, result3 error) {
	fake.configureAndValidateTkrVersionMutex.Lock()
	defer fake.configureAndValidateTkrVersionMutex.Unlock()
	fake.ConfigureAndValidateTkrVersionStub = nil
	if fake.configureAndValidateTkrVersionReturnsOnCall == nil {
		fake.configureAndValidateTkrVersionReturnsOnCall = make(map[int]struct {
			result1 string
			result2 string
			result3 error
		})
	}
	fake.configureAndValidateTkrVersionReturnsOnCall[i] = struct {
		result1 string
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *Client) ConfigureTimeout(arg1 time.Duration) {
	fake.configureTimeoutMutex.Lock()
	fake.configureTimeoutArgsForCall = append(fake.configureTimeoutArgsForCall, struct {
		arg1 time.Duration
	}{arg1})
	stub := fake.ConfigureTimeoutStub
	fake.recordInvocation("ConfigureTimeout", []interface{}{arg1})
	fake.configureTimeoutMutex.Unlock()
	if stub != nil {
		fake.ConfigureTimeoutStub(arg1)
	}
}

func (fake *Client) ConfigureTimeoutCallCount() int {
	fake.configureTimeoutMutex.RLock()
	defer fake.configureTimeoutMutex.RUnlock()
	return len(fake.configureTimeoutArgsForCall)
}

func (fake *Client) ConfigureTimeoutCalls(stub func(time.Duration)) {
	fake.configureTimeoutMutex.Lock()
	defer fake.configureTimeoutMutex.Unlock()
	fake.ConfigureTimeoutStub = stub
}

func (fake *Client) ConfigureTimeoutArgsForCall(i int) time.Duration {
	fake.configureTimeoutMutex.RLock()
	defer fake.configureTimeoutMutex.RUnlock()
	argsForCall := fake.configureTimeoutArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) CreateAWSCloudFormationStack() error {
	fake.createAWSCloudFormationStackMutex.Lock()
	ret, specificReturn := fake.createAWSCloudFormationStackReturnsOnCall[len(fake.createAWSCloudFormationStackArgsForCall)]
	fake.createAWSCloudFormationStackArgsForCall = append(fake.createAWSCloudFormationStackArgsForCall, struct {
	}{})
	stub := fake.CreateAWSCloudFormationStackStub
	fakeReturns := fake.createAWSCloudFormationStackReturns
	fake.recordInvocation("CreateAWSCloudFormationStack", []interface{}{})
	fake.createAWSCloudFormationStackMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Client) CreateAWSCloudFormationStackCallCount() int {
	fake.createAWSCloudFormationStackMutex.RLock()
	defer fake.createAWSCloudFormationStackMutex.RUnlock()
	return len(fake.createAWSCloudFormationStackArgsForCall)
}

func (fake *Client) CreateAWSCloudFormationStackCalls(stub func() error) {
	fake.createAWSCloudFormationStackMutex.Lock()
	defer fake.createAWSCloudFormationStackMutex.Unlock()
	fake.CreateAWSCloudFormationStackStub = stub
}

func (fake *Client) CreateAWSCloudFormationStackReturns(result1 error) {
	fake.createAWSCloudFormationStackMutex.Lock()
	defer fake.createAWSCloudFormationStackMutex.Unlock()
	fake.CreateAWSCloudFormationStackStub = nil
	fake.createAWSCloudFormationStackReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) CreateAWSCloudFormationStackReturnsOnCall(i int, result1 error) {
	fake.createAWSCloudFormationStackMutex.Lock()
	defer fake.createAWSCloudFormationStackMutex.Unlock()
	fake.CreateAWSCloudFormationStackStub = nil
	if fake.createAWSCloudFormationStackReturnsOnCall == nil {
		fake.createAWSCloudFormationStackReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createAWSCloudFormationStackReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Client) CreateCluster(arg1 *client.CreateClusterOptions, arg2 bool) error {
	fake.createClusterMutex.Lock()
	ret, specificReturn := fake.createClusterReturnsOnCall[len(fake.createClusterArgsForCall)]
	fake.createClusterArgsForCall = append(fake.createClusterArgsForCall, struct {
		arg1 *client.CreateClusterOptions
		arg2 bool
	}{arg1, arg2})
	stub := fake.CreateClusterStub
	fakeReturns := fake.createClusterReturns
	fake.recordInvocation("CreateCluster", []interface{}{arg1, arg2})
	fake.createClusterMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Client) CreateClusterCallCount() int {
	fake.createClusterMutex.RLock()
	defer fake.createClusterMutex.RUnlock()
	return len(fake.createClusterArgsForCall)
}

func (fake *Client) CreateClusterCalls(stub func(*client.CreateClusterOptions, bool) error) {
	fake.createClusterMutex.Lock()
	defer fake.createClusterMutex.Unlock()
	fake.CreateClusterStub = stub
}

func (fake *Client) CreateClusterArgsForCall(i int) (*client.CreateClusterOptions, bool) {
	fake.createClusterMutex.RLock()
	defer fake.createClusterMutex.RUnlock()
	argsForCall := fake.createClusterArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Client) CreateClusterReturns(result1 error) {
	fake.createClusterMutex.Lock()
	defer fake.createClusterMutex.Unlock()
	fake.CreateClusterStub = nil
	fake.createClusterReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) CreateClusterReturnsOnCall(i int, result1 error) {
	fake.createClusterMutex.Lock()
	defer fake.createClusterMutex.Unlock()
	fake.CreateClusterStub = nil
	if fake.createClusterReturnsOnCall == nil {
		fake.createClusterReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createClusterReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Client) DeRegisterManagementClusterFromTmc(arg1 string) error {
	fake.deRegisterManagementClusterFromTmcMutex.Lock()
	ret, specificReturn := fake.deRegisterManagementClusterFromTmcReturnsOnCall[len(fake.deRegisterManagementClusterFromTmcArgsForCall)]
	fake.deRegisterManagementClusterFromTmcArgsForCall = append(fake.deRegisterManagementClusterFromTmcArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeRegisterManagementClusterFromTmcStub
	fakeReturns := fake.deRegisterManagementClusterFromTmcReturns
	fake.recordInvocation("DeRegisterManagementClusterFromTmc", []interface{}{arg1})
	fake.deRegisterManagementClusterFromTmcMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Client) DeRegisterManagementClusterFromTmcCallCount() int {
	fake.deRegisterManagementClusterFromTmcMutex.RLock()
	defer fake.deRegisterManagementClusterFromTmcMutex.RUnlock()
	return len(fake.deRegisterManagementClusterFromTmcArgsForCall)
}

func (fake *Client) DeRegisterManagementClusterFromTmcCalls(stub func(string) error) {
	fake.deRegisterManagementClusterFromTmcMutex.Lock()
	defer fake.deRegisterManagementClusterFromTmcMutex.Unlock()
	fake.DeRegisterManagementClusterFromTmcStub = stub
}

func (fake *Client) DeRegisterManagementClusterFromTmcArgsForCall(i int) string {
	fake.deRegisterManagementClusterFromTmcMutex.RLock()
	defer fake.deRegisterManagementClusterFromTmcMutex.RUnlock()
	argsForCall := fake.deRegisterManagementClusterFromTmcArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) DeRegisterManagementClusterFromTmcReturns(result1 error) {
	fake.deRegisterManagementClusterFromTmcMutex.Lock()
	defer fake.deRegisterManagementClusterFromTmcMutex.Unlock()
	fake.DeRegisterManagementClusterFromTmcStub = nil
	fake.deRegisterManagementClusterFromTmcReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) DeRegisterManagementClusterFromTmcReturnsOnCall(i int, result1 error) {
	fake.deRegisterManagementClusterFromTmcMutex.Lock()
	defer fake.deRegisterManagementClusterFromTmcMutex.Unlock()
	fake.DeRegisterManagementClusterFromTmcStub = nil
	if fake.deRegisterManagementClusterFromTmcReturnsOnCall == nil {
		fake.deRegisterManagementClusterFromTmcReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deRegisterManagementClusterFromTmcReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Client) DeactivateTanzuKubernetesReleases(arg1 string) error {
	fake.deactivateTanzuKubernetesReleasesMutex.Lock()
	ret, specificReturn := fake.deactivateTanzuKubernetesReleasesReturnsOnCall[len(fake.deactivateTanzuKubernetesReleasesArgsForCall)]
	fake.deactivateTanzuKubernetesReleasesArgsForCall = append(fake.deactivateTanzuKubernetesReleasesArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeactivateTanzuKubernetesReleasesStub
	fakeReturns := fake.deactivateTanzuKubernetesReleasesReturns
	fake.recordInvocation("DeactivateTanzuKubernetesReleases", []interface{}{arg1})
	fake.deactivateTanzuKubernetesReleasesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Client) DeactivateTanzuKubernetesReleasesCallCount() int {
	fake.deactivateTanzuKubernetesReleasesMutex.RLock()
	defer fake.deactivateTanzuKubernetesReleasesMutex.RUnlock()
	return len(fake.deactivateTanzuKubernetesReleasesArgsForCall)
}

func (fake *Client) DeactivateTanzuKubernetesReleasesCalls(stub func(string) error) {
	fake.deactivateTanzuKubernetesReleasesMutex.Lock()
	defer fake.deactivateTanzuKubernetesReleasesMutex.Unlock()
	fake.DeactivateTanzuKubernetesReleasesStub = stub
}

func (fake *Client) DeactivateTanzuKubernetesReleasesArgsForCall(i int) string {
	fake.deactivateTanzuKubernetesReleasesMutex.RLock()
	defer fake.deactivateTanzuKubernetesReleasesMutex.RUnlock()
	argsForCall := fake.deactivateTanzuKubernetesReleasesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) DeactivateTanzuKubernetesReleasesReturns(result1 error) {
	fake.deactivateTanzuKubernetesReleasesMutex.Lock()
	defer fake.deactivateTanzuKubernetesReleasesMutex.Unlock()
	fake.DeactivateTanzuKubernetesReleasesStub = nil
	fake.deactivateTanzuKubernetesReleasesReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) DeactivateTanzuKubernetesReleasesReturnsOnCall(i int, result1 error) {
	fake.deactivateTanzuKubernetesReleasesMutex.Lock()
	defer fake.deactivateTanzuKubernetesReleasesMutex.Unlock()
	fake.DeactivateTanzuKubernetesReleasesStub = nil
	if fake.deactivateTanzuKubernetesReleasesReturnsOnCall == nil {
		fake.deactivateTanzuKubernetesReleasesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deactivateTanzuKubernetesReleasesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Client) DeleteMachineDeployment(arg1 client.DeleteMachineDeploymentOptions) error {
	fake.deleteMachineDeploymentMutex.Lock()
	ret, specificReturn := fake.deleteMachineDeploymentReturnsOnCall[len(fake.deleteMachineDeploymentArgsForCall)]
	fake.deleteMachineDeploymentArgsForCall = append(fake.deleteMachineDeploymentArgsForCall, struct {
		arg1 client.DeleteMachineDeploymentOptions
	}{arg1})
	stub := fake.DeleteMachineDeploymentStub
	fakeReturns := fake.deleteMachineDeploymentReturns
	fake.recordInvocation("DeleteMachineDeployment", []interface{}{arg1})
	fake.deleteMachineDeploymentMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Client) DeleteMachineDeploymentCallCount() int {
	fake.deleteMachineDeploymentMutex.RLock()
	defer fake.deleteMachineDeploymentMutex.RUnlock()
	return len(fake.deleteMachineDeploymentArgsForCall)
}

func (fake *Client) DeleteMachineDeploymentCalls(stub func(client.DeleteMachineDeploymentOptions) error) {
	fake.deleteMachineDeploymentMutex.Lock()
	defer fake.deleteMachineDeploymentMutex.Unlock()
	fake.DeleteMachineDeploymentStub = stub
}

func (fake *Client) DeleteMachineDeploymentArgsForCall(i int) client.DeleteMachineDeploymentOptions {
	fake.deleteMachineDeploymentMutex.RLock()
	defer fake.deleteMachineDeploymentMutex.RUnlock()
	argsForCall := fake.deleteMachineDeploymentArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) DeleteMachineDeploymentReturns(result1 error) {
	fake.deleteMachineDeploymentMutex.Lock()
	defer fake.deleteMachineDeploymentMutex.Unlock()
	fake.DeleteMachineDeploymentStub = nil
	fake.deleteMachineDeploymentReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) DeleteMachineDeploymentReturnsOnCall(i int, result1 error) {
	fake.deleteMachineDeploymentMutex.Lock()
	defer fake.deleteMachineDeploymentMutex.Unlock()
	fake.DeleteMachineDeploymentStub = nil
	if fake.deleteMachineDeploymentReturnsOnCall == nil {
		fake.deleteMachineDeploymentReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteMachineDeploymentReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Client) DeleteMachineHealthCheck(arg1 client.MachineHealthCheckOptions) error {
	fake.deleteMachineHealthCheckMutex.Lock()
	ret, specificReturn := fake.deleteMachineHealthCheckReturnsOnCall[len(fake.deleteMachineHealthCheckArgsForCall)]
	fake.deleteMachineHealthCheckArgsForCall = append(fake.deleteMachineHealthCheckArgsForCall, struct {
		arg1 client.MachineHealthCheckOptions
	}{arg1})
	stub := fake.DeleteMachineHealthCheckStub
	fakeReturns := fake.deleteMachineHealthCheckReturns
	fake.recordInvocation("DeleteMachineHealthCheck", []interface{}{arg1})
	fake.deleteMachineHealthCheckMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Client) DeleteMachineHealthCheckCallCount() int {
	fake.deleteMachineHealthCheckMutex.RLock()
	defer fake.deleteMachineHealthCheckMutex.RUnlock()
	return len(fake.deleteMachineHealthCheckArgsForCall)
}

func (fake *Client) DeleteMachineHealthCheckCalls(stub func(client.MachineHealthCheckOptions) error) {
	fake.deleteMachineHealthCheckMutex.Lock()
	defer fake.deleteMachineHealthCheckMutex.Unlock()
	fake.DeleteMachineHealthCheckStub = stub
}

func (fake *Client) DeleteMachineHealthCheckArgsForCall(i int) client.MachineHealthCheckOptions {
	fake.deleteMachineHealthCheckMutex.RLock()
	defer fake.deleteMachineHealthCheckMutex.RUnlock()
	argsForCall := fake.deleteMachineHealthCheckArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) DeleteMachineHealthCheckReturns(result1 error) {
	fake.deleteMachineHealthCheckMutex.Lock()
	defer fake.deleteMachineHealthCheckMutex.Unlock()
	fake.DeleteMachineHealthCheckStub = nil
	fake.deleteMachineHealthCheckReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) DeleteMachineHealthCheckReturnsOnCall(i int, result1 error) {
	fake.deleteMachineHealthCheckMutex.Lock()
	defer fake.deleteMachineHealthCheckMutex.Unlock()
	fake.DeleteMachineHealthCheckStub = nil
	if fake.deleteMachineHealthCheckReturnsOnCall == nil {
		fake.deleteMachineHealthCheckReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteMachineHealthCheckReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Client) DeleteRegion(arg1 client.DeleteRegionOptions) error {
	fake.deleteRegionMutex.Lock()
	ret, specificReturn := fake.deleteRegionReturnsOnCall[len(fake.deleteRegionArgsForCall)]
	fake.deleteRegionArgsForCall = append(fake.deleteRegionArgsForCall, struct {
		arg1 client.DeleteRegionOptions
	}{arg1})
	stub := fake.DeleteRegionStub
	fakeReturns := fake.deleteRegionReturns
	fake.recordInvocation("DeleteRegion", []interface{}{arg1})
	fake.deleteRegionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Client) DeleteRegionCallCount() int {
	fake.deleteRegionMutex.RLock()
	defer fake.deleteRegionMutex.RUnlock()
	return len(fake.deleteRegionArgsForCall)
}

func (fake *Client) DeleteRegionCalls(stub func(client.DeleteRegionOptions) error) {
	fake.deleteRegionMutex.Lock()
	defer fake.deleteRegionMutex.Unlock()
	fake.DeleteRegionStub = stub
}

func (fake *Client) DeleteRegionArgsForCall(i int) client.DeleteRegionOptions {
	fake.deleteRegionMutex.RLock()
	defer fake.deleteRegionMutex.RUnlock()
	argsForCall := fake.deleteRegionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) DeleteRegionReturns(result1 error) {
	fake.deleteRegionMutex.Lock()
	defer fake.deleteRegionMutex.Unlock()
	fake.DeleteRegionStub = nil
	fake.deleteRegionReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) DeleteRegionReturnsOnCall(i int, result1 error) {
	fake.deleteRegionMutex.Lock()
	defer fake.deleteRegionMutex.Unlock()
	fake.DeleteRegionStub = nil
	if fake.deleteRegionReturnsOnCall == nil {
		fake.deleteRegionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteRegionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Client) DeleteWorkloadCluster(arg1 client.DeleteWorkloadClusterOptions) error {
	fake.deleteWorkloadClusterMutex.Lock()
	ret, specificReturn := fake.deleteWorkloadClusterReturnsOnCall[len(fake.deleteWorkloadClusterArgsForCall)]
	fake.deleteWorkloadClusterArgsForCall = append(fake.deleteWorkloadClusterArgsForCall, struct {
		arg1 client.DeleteWorkloadClusterOptions
	}{arg1})
	stub := fake.DeleteWorkloadClusterStub
	fakeReturns := fake.deleteWorkloadClusterReturns
	fake.recordInvocation("DeleteWorkloadCluster", []interface{}{arg1})
	fake.deleteWorkloadClusterMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Client) DeleteWorkloadClusterCallCount() int {
	fake.deleteWorkloadClusterMutex.RLock()
	defer fake.deleteWorkloadClusterMutex.RUnlock()
	return len(fake.deleteWorkloadClusterArgsForCall)
}

func (fake *Client) DeleteWorkloadClusterCalls(stub func(client.DeleteWorkloadClusterOptions) error) {
	fake.deleteWorkloadClusterMutex.Lock()
	defer fake.deleteWorkloadClusterMutex.Unlock()
	fake.DeleteWorkloadClusterStub = stub
}

func (fake *Client) DeleteWorkloadClusterArgsForCall(i int) client.DeleteWorkloadClusterOptions {
	fake.deleteWorkloadClusterMutex.RLock()
	defer fake.deleteWorkloadClusterMutex.RUnlock()
	argsForCall := fake.deleteWorkloadClusterArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) DeleteWorkloadClusterReturns(result1 error) {
	fake.deleteWorkloadClusterMutex.Lock()
	defer fake.deleteWorkloadClusterMutex.Unlock()
	fake.DeleteWorkloadClusterStub = nil
	fake.deleteWorkloadClusterReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) DeleteWorkloadClusterReturnsOnCall(i int, result1 error) {
	fake.deleteWorkloadClusterMutex.Lock()
	defer fake.deleteWorkloadClusterMutex.Unlock()
	fake.DeleteWorkloadClusterStub = nil
	if fake.deleteWorkloadClusterReturnsOnCall == nil {
		fake.deleteWorkloadClusterReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteWorkloadClusterReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Client) DescribeCluster(arg1 client.DescribeTKGClustersOptions) (*tree.ObjectTree, *v1alpha3.Cluster, *v1alpha3a.ProviderList, error) {
	fake.describeClusterMutex.Lock()
	ret, specificReturn := fake.describeClusterReturnsOnCall[len(fake.describeClusterArgsForCall)]
	fake.describeClusterArgsForCall = append(fake.describeClusterArgsForCall, struct {
		arg1 client.DescribeTKGClustersOptions
	}{arg1})
	stub := fake.DescribeClusterStub
	fakeReturns := fake.describeClusterReturns
	fake.recordInvocation("DescribeCluster", []interface{}{arg1})
	fake.describeClusterMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3, fakeReturns.result4
}

func (fake *Client) DescribeClusterCallCount() int {
	fake.describeClusterMutex.RLock()
	defer fake.describeClusterMutex.RUnlock()
	return len(fake.describeClusterArgsForCall)
}

func (fake *Client) DescribeClusterCalls(stub func(client.DescribeTKGClustersOptions) (*tree.ObjectTree, *v1alpha3.Cluster, *v1alpha3a.ProviderList, error)) {
	fake.describeClusterMutex.Lock()
	defer fake.describeClusterMutex.Unlock()
	fake.DescribeClusterStub = stub
}

func (fake *Client) DescribeClusterArgsForCall(i int) client.DescribeTKGClustersOptions {
	fake.describeClusterMutex.RLock()
	defer fake.describeClusterMutex.RUnlock()
	argsForCall := fake.describeClusterArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) DescribeClusterReturns(result1 *tree.ObjectTree, result2 *v1alpha3.Cluster, result3 *v1alpha3a.ProviderList, result4 error) {
	fake.describeClusterMutex.Lock()
	defer fake.describeClusterMutex.Unlock()
	fake.DescribeClusterStub = nil
	fake.describeClusterReturns = struct {
		result1 *tree.ObjectTree
		result2 *v1alpha3.Cluster
		result3 *v1alpha3a.ProviderList
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *Client) DescribeClusterReturnsOnCall(i int, result1 *tree.ObjectTree, result2 *v1alpha3.Cluster, result3 *v1alpha3a.ProviderList, result4 error) {
	fake.describeClusterMutex.Lock()
	defer fake.describeClusterMutex.Unlock()
	fake.DescribeClusterStub = nil
	if fake.describeClusterReturnsOnCall == nil {
		fake.describeClusterReturnsOnCall = make(map[int]struct {
			result1 *tree.ObjectTree
			result2 *v1alpha3.Cluster
			result3 *v1alpha3a.ProviderList
			result4 error
		})
	}
	fake.describeClusterReturnsOnCall[i] = struct {
		result1 *tree.ObjectTree
		result2 *v1alpha3.Cluster
		result3 *v1alpha3a.ProviderList
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *Client) DescribeProvider() (*v1alpha3a.ProviderList, error) {
	fake.describeProviderMutex.Lock()
	ret, specificReturn := fake.describeProviderReturnsOnCall[len(fake.describeProviderArgsForCall)]
	fake.describeProviderArgsForCall = append(fake.describeProviderArgsForCall, struct {
	}{})
	stub := fake.DescribeProviderStub
	fakeReturns := fake.describeProviderReturns
	fake.recordInvocation("DescribeProvider", []interface{}{})
	fake.describeProviderMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Client) DescribeProviderCallCount() int {
	fake.describeProviderMutex.RLock()
	defer fake.describeProviderMutex.RUnlock()
	return len(fake.describeProviderArgsForCall)
}

func (fake *Client) DescribeProviderCalls(stub func() (*v1alpha3a.ProviderList, error)) {
	fake.describeProviderMutex.Lock()
	defer fake.describeProviderMutex.Unlock()
	fake.DescribeProviderStub = stub
}

func (fake *Client) DescribeProviderReturns(result1 *v1alpha3a.ProviderList, result2 error) {
	fake.describeProviderMutex.Lock()
	defer fake.describeProviderMutex.Unlock()
	fake.DescribeProviderStub = nil
	fake.describeProviderReturns = struct {
		result1 *v1alpha3a.ProviderList
		result2 error
	}{result1, result2}
}

func (fake *Client) DescribeProviderReturnsOnCall(i int, result1 *v1alpha3a.ProviderList, result2 error) {
	fake.describeProviderMutex.Lock()
	defer fake.describeProviderMutex.Unlock()
	fake.DescribeProviderStub = nil
	if fake.describeProviderReturnsOnCall == nil {
		fake.describeProviderReturnsOnCall = make(map[int]struct {
			result1 *v1alpha3a.ProviderList
			result2 error
		})
	}
	fake.describeProviderReturnsOnCall[i] = struct {
		result1 *v1alpha3a.ProviderList
		result2 error
	}{result1, result2}
}

func (fake *Client) DownloadBomFile(arg1 string) error {
	fake.downloadBomFileMutex.Lock()
	ret, specificReturn := fake.downloadBomFileReturnsOnCall[len(fake.downloadBomFileArgsForCall)]
	fake.downloadBomFileArgsForCall = append(fake.downloadBomFileArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DownloadBomFileStub
	fakeReturns := fake.downloadBomFileReturns
	fake.recordInvocation("DownloadBomFile", []interface{}{arg1})
	fake.downloadBomFileMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Client) DownloadBomFileCallCount() int {
	fake.downloadBomFileMutex.RLock()
	defer fake.downloadBomFileMutex.RUnlock()
	return len(fake.downloadBomFileArgsForCall)
}

func (fake *Client) DownloadBomFileCalls(stub func(string) error) {
	fake.downloadBomFileMutex.Lock()
	defer fake.downloadBomFileMutex.Unlock()
	fake.DownloadBomFileStub = stub
}

func (fake *Client) DownloadBomFileArgsForCall(i int) string {
	fake.downloadBomFileMutex.RLock()
	defer fake.downloadBomFileMutex.RUnlock()
	argsForCall := fake.downloadBomFileArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) DownloadBomFileReturns(result1 error) {
	fake.downloadBomFileMutex.Lock()
	defer fake.downloadBomFileMutex.Unlock()
	fake.DownloadBomFileStub = nil
	fake.downloadBomFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) DownloadBomFileReturnsOnCall(i int, result1 error) {
	fake.downloadBomFileMutex.Lock()
	defer fake.downloadBomFileMutex.Unlock()
	fake.DownloadBomFileStub = nil
	if fake.downloadBomFileReturnsOnCall == nil {
		fake.downloadBomFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.downloadBomFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Client) GetCEIPParticipation() (client.ClusterCeipInfo, error) {
	fake.getCEIPParticipationMutex.Lock()
	ret, specificReturn := fake.getCEIPParticipationReturnsOnCall[len(fake.getCEIPParticipationArgsForCall)]
	fake.getCEIPParticipationArgsForCall = append(fake.getCEIPParticipationArgsForCall, struct {
	}{})
	stub := fake.GetCEIPParticipationStub
	fakeReturns := fake.getCEIPParticipationReturns
	fake.recordInvocation("GetCEIPParticipation", []interface{}{})
	fake.getCEIPParticipationMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Client) GetCEIPParticipationCallCount() int {
	fake.getCEIPParticipationMutex.RLock()
	defer fake.getCEIPParticipationMutex.RUnlock()
	return len(fake.getCEIPParticipationArgsForCall)
}

func (fake *Client) GetCEIPParticipationCalls(stub func() (client.ClusterCeipInfo, error)) {
	fake.getCEIPParticipationMutex.Lock()
	defer fake.getCEIPParticipationMutex.Unlock()
	fake.GetCEIPParticipationStub = stub
}

func (fake *Client) GetCEIPParticipationReturns(result1 client.ClusterCeipInfo, result2 error) {
	fake.getCEIPParticipationMutex.Lock()
	defer fake.getCEIPParticipationMutex.Unlock()
	fake.GetCEIPParticipationStub = nil
	fake.getCEIPParticipationReturns = struct {
		result1 client.ClusterCeipInfo
		result2 error
	}{result1, result2}
}

func (fake *Client) GetCEIPParticipationReturnsOnCall(i int, result1 client.ClusterCeipInfo, result2 error) {
	fake.getCEIPParticipationMutex.Lock()
	defer fake.getCEIPParticipationMutex.Unlock()
	fake.GetCEIPParticipationStub = nil
	if fake.getCEIPParticipationReturnsOnCall == nil {
		fake.getCEIPParticipationReturnsOnCall = make(map[int]struct {
			result1 client.ClusterCeipInfo
			result2 error
		})
	}
	fake.getCEIPParticipationReturnsOnCall[i] = struct {
		result1 client.ClusterCeipInfo
		result2 error
	}{result1, result2}
}

func (fake *Client) GetClusterConfiguration(arg1 *client.CreateClusterOptions) ([]byte, error) {
	fake.getClusterConfigurationMutex.Lock()
	ret, specificReturn := fake.getClusterConfigurationReturnsOnCall[len(fake.getClusterConfigurationArgsForCall)]
	fake.getClusterConfigurationArgsForCall = append(fake.getClusterConfigurationArgsForCall, struct {
		arg1 *client.CreateClusterOptions
	}{arg1})
	stub := fake.GetClusterConfigurationStub
	fakeReturns := fake.getClusterConfigurationReturns
	fake.recordInvocation("GetClusterConfiguration", []interface{}{arg1})
	fake.getClusterConfigurationMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Client) GetClusterConfigurationCallCount() int {
	fake.getClusterConfigurationMutex.RLock()
	defer fake.getClusterConfigurationMutex.RUnlock()
	return len(fake.getClusterConfigurationArgsForCall)
}

func (fake *Client) GetClusterConfigurationCalls(stub func(*client.CreateClusterOptions) ([]byte, error)) {
	fake.getClusterConfigurationMutex.Lock()
	defer fake.getClusterConfigurationMutex.Unlock()
	fake.GetClusterConfigurationStub = stub
}

func (fake *Client) GetClusterConfigurationArgsForCall(i int) *client.CreateClusterOptions {
	fake.getClusterConfigurationMutex.RLock()
	defer fake.getClusterConfigurationMutex.RUnlock()
	argsForCall := fake.getClusterConfigurationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) GetClusterConfigurationReturns(result1 []byte, result2 error) {
	fake.getClusterConfigurationMutex.Lock()
	defer fake.getClusterConfigurationMutex.Unlock()
	fake.GetClusterConfigurationStub = nil
	fake.getClusterConfigurationReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *Client) GetClusterConfigurationReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.getClusterConfigurationMutex.Lock()
	defer fake.getClusterConfigurationMutex.Unlock()
	fake.GetClusterConfigurationStub = nil
	if fake.getClusterConfigurationReturnsOnCall == nil {
		fake.getClusterConfigurationReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.getClusterConfigurationReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *Client) GetClusterPinnipedInfo(arg1 client.GetClusterPinnipedInfoOptions) (*client.ClusterPinnipedInfo, error) {
	fake.getClusterPinnipedInfoMutex.Lock()
	ret, specificReturn := fake.getClusterPinnipedInfoReturnsOnCall[len(fake.getClusterPinnipedInfoArgsForCall)]
	fake.getClusterPinnipedInfoArgsForCall = append(fake.getClusterPinnipedInfoArgsForCall, struct {
		arg1 client.GetClusterPinnipedInfoOptions
	}{arg1})
	stub := fake.GetClusterPinnipedInfoStub
	fakeReturns := fake.getClusterPinnipedInfoReturns
	fake.recordInvocation("GetClusterPinnipedInfo", []interface{}{arg1})
	fake.getClusterPinnipedInfoMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Client) GetClusterPinnipedInfoCallCount() int {
	fake.getClusterPinnipedInfoMutex.RLock()
	defer fake.getClusterPinnipedInfoMutex.RUnlock()
	return len(fake.getClusterPinnipedInfoArgsForCall)
}

func (fake *Client) GetClusterPinnipedInfoCalls(stub func(client.GetClusterPinnipedInfoOptions) (*client.ClusterPinnipedInfo, error)) {
	fake.getClusterPinnipedInfoMutex.Lock()
	defer fake.getClusterPinnipedInfoMutex.Unlock()
	fake.GetClusterPinnipedInfoStub = stub
}

func (fake *Client) GetClusterPinnipedInfoArgsForCall(i int) client.GetClusterPinnipedInfoOptions {
	fake.getClusterPinnipedInfoMutex.RLock()
	defer fake.getClusterPinnipedInfoMutex.RUnlock()
	argsForCall := fake.getClusterPinnipedInfoArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) GetClusterPinnipedInfoReturns(result1 *client.ClusterPinnipedInfo, result2 error) {
	fake.getClusterPinnipedInfoMutex.Lock()
	defer fake.getClusterPinnipedInfoMutex.Unlock()
	fake.GetClusterPinnipedInfoStub = nil
	fake.getClusterPinnipedInfoReturns = struct {
		result1 *client.ClusterPinnipedInfo
		result2 error
	}{result1, result2}
}

func (fake *Client) GetClusterPinnipedInfoReturnsOnCall(i int, result1 *client.ClusterPinnipedInfo, result2 error) {
	fake.getClusterPinnipedInfoMutex.Lock()
	defer fake.getClusterPinnipedInfoMutex.Unlock()
	fake.GetClusterPinnipedInfoStub = nil
	if fake.getClusterPinnipedInfoReturnsOnCall == nil {
		fake.getClusterPinnipedInfoReturnsOnCall = make(map[int]struct {
			result1 *client.ClusterPinnipedInfo
			result2 error
		})
	}
	fake.getClusterPinnipedInfoReturnsOnCall[i] = struct {
		result1 *client.ClusterPinnipedInfo
		result2 error
	}{result1, result2}
}

func (fake *Client) GetCurrentRegionContext() (region.RegionContext, error) {
	fake.getCurrentRegionContextMutex.Lock()
	ret, specificReturn := fake.getCurrentRegionContextReturnsOnCall[len(fake.getCurrentRegionContextArgsForCall)]
	fake.getCurrentRegionContextArgsForCall = append(fake.getCurrentRegionContextArgsForCall, struct {
	}{})
	stub := fake.GetCurrentRegionContextStub
	fakeReturns := fake.getCurrentRegionContextReturns
	fake.recordInvocation("GetCurrentRegionContext", []interface{}{})
	fake.getCurrentRegionContextMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Client) GetCurrentRegionContextCallCount() int {
	fake.getCurrentRegionContextMutex.RLock()
	defer fake.getCurrentRegionContextMutex.RUnlock()
	return len(fake.getCurrentRegionContextArgsForCall)
}

func (fake *Client) GetCurrentRegionContextCalls(stub func() (region.RegionContext, error)) {
	fake.getCurrentRegionContextMutex.Lock()
	defer fake.getCurrentRegionContextMutex.Unlock()
	fake.GetCurrentRegionContextStub = stub
}

func (fake *Client) GetCurrentRegionContextReturns(result1 region.RegionContext, result2 error) {
	fake.getCurrentRegionContextMutex.Lock()
	defer fake.getCurrentRegionContextMutex.Unlock()
	fake.GetCurrentRegionContextStub = nil
	fake.getCurrentRegionContextReturns = struct {
		result1 region.RegionContext
		result2 error
	}{result1, result2}
}

func (fake *Client) GetCurrentRegionContextReturnsOnCall(i int, result1 region.RegionContext, result2 error) {
	fake.getCurrentRegionContextMutex.Lock()
	defer fake.getCurrentRegionContextMutex.Unlock()
	fake.GetCurrentRegionContextStub = nil
	if fake.getCurrentRegionContextReturnsOnCall == nil {
		fake.getCurrentRegionContextReturnsOnCall = make(map[int]struct {
			result1 region.RegionContext
			result2 error
		})
	}
	fake.getCurrentRegionContextReturnsOnCall[i] = struct {
		result1 region.RegionContext
		result2 error
	}{result1, result2}
}

func (fake *Client) GetKubernetesVersions() (*client.KubernetesVersionsInfo, error) {
	fake.getKubernetesVersionsMutex.Lock()
	ret, specificReturn := fake.getKubernetesVersionsReturnsOnCall[len(fake.getKubernetesVersionsArgsForCall)]
	fake.getKubernetesVersionsArgsForCall = append(fake.getKubernetesVersionsArgsForCall, struct {
	}{})
	stub := fake.GetKubernetesVersionsStub
	fakeReturns := fake.getKubernetesVersionsReturns
	fake.recordInvocation("GetKubernetesVersions", []interface{}{})
	fake.getKubernetesVersionsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Client) GetKubernetesVersionsCallCount() int {
	fake.getKubernetesVersionsMutex.RLock()
	defer fake.getKubernetesVersionsMutex.RUnlock()
	return len(fake.getKubernetesVersionsArgsForCall)
}

func (fake *Client) GetKubernetesVersionsCalls(stub func() (*client.KubernetesVersionsInfo, error)) {
	fake.getKubernetesVersionsMutex.Lock()
	defer fake.getKubernetesVersionsMutex.Unlock()
	fake.GetKubernetesVersionsStub = stub
}

func (fake *Client) GetKubernetesVersionsReturns(result1 *client.KubernetesVersionsInfo, result2 error) {
	fake.getKubernetesVersionsMutex.Lock()
	defer fake.getKubernetesVersionsMutex.Unlock()
	fake.GetKubernetesVersionsStub = nil
	fake.getKubernetesVersionsReturns = struct {
		result1 *client.KubernetesVersionsInfo
		result2 error
	}{result1, result2}
}

func (fake *Client) GetKubernetesVersionsReturnsOnCall(i int, result1 *client.KubernetesVersionsInfo, result2 error) {
	fake.getKubernetesVersionsMutex.Lock()
	defer fake.getKubernetesVersionsMutex.Unlock()
	fake.GetKubernetesVersionsStub = nil
	if fake.getKubernetesVersionsReturnsOnCall == nil {
		fake.getKubernetesVersionsReturnsOnCall = make(map[int]struct {
			result1 *client.KubernetesVersionsInfo
			result2 error
		})
	}
	fake.getKubernetesVersionsReturnsOnCall[i] = struct {
		result1 *client.KubernetesVersionsInfo
		result2 error
	}{result1, result2}
}

func (fake *Client) GetMachineDeployments(arg1 client.GetMachineDeploymentOptions) ([]v1alpha3.MachineDeployment, error) {
	fake.getMachineDeploymentsMutex.Lock()
	ret, specificReturn := fake.getMachineDeploymentsReturnsOnCall[len(fake.getMachineDeploymentsArgsForCall)]
	fake.getMachineDeploymentsArgsForCall = append(fake.getMachineDeploymentsArgsForCall, struct {
		arg1 client.GetMachineDeploymentOptions
	}{arg1})
	stub := fake.GetMachineDeploymentsStub
	fakeReturns := fake.getMachineDeploymentsReturns
	fake.recordInvocation("GetMachineDeployments", []interface{}{arg1})
	fake.getMachineDeploymentsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Client) GetMachineDeploymentsCallCount() int {
	fake.getMachineDeploymentsMutex.RLock()
	defer fake.getMachineDeploymentsMutex.RUnlock()
	return len(fake.getMachineDeploymentsArgsForCall)
}

func (fake *Client) GetMachineDeploymentsCalls(stub func(client.GetMachineDeploymentOptions) ([]v1alpha3.MachineDeployment, error)) {
	fake.getMachineDeploymentsMutex.Lock()
	defer fake.getMachineDeploymentsMutex.Unlock()
	fake.GetMachineDeploymentsStub = stub
}

func (fake *Client) GetMachineDeploymentsArgsForCall(i int) client.GetMachineDeploymentOptions {
	fake.getMachineDeploymentsMutex.RLock()
	defer fake.getMachineDeploymentsMutex.RUnlock()
	argsForCall := fake.getMachineDeploymentsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) GetMachineDeploymentsReturns(result1 []v1alpha3.MachineDeployment, result2 error) {
	fake.getMachineDeploymentsMutex.Lock()
	defer fake.getMachineDeploymentsMutex.Unlock()
	fake.GetMachineDeploymentsStub = nil
	fake.getMachineDeploymentsReturns = struct {
		result1 []v1alpha3.MachineDeployment
		result2 error
	}{result1, result2}
}

func (fake *Client) GetMachineDeploymentsReturnsOnCall(i int, result1 []v1alpha3.MachineDeployment, result2 error) {
	fake.getMachineDeploymentsMutex.Lock()
	defer fake.getMachineDeploymentsMutex.Unlock()
	fake.GetMachineDeploymentsStub = nil
	if fake.getMachineDeploymentsReturnsOnCall == nil {
		fake.getMachineDeploymentsReturnsOnCall = make(map[int]struct {
			result1 []v1alpha3.MachineDeployment
			result2 error
		})
	}
	fake.getMachineDeploymentsReturnsOnCall[i] = struct {
		result1 []v1alpha3.MachineDeployment
		result2 error
	}{result1, result2}
}

func (fake *Client) GetMachineHealthChecks(arg1 client.MachineHealthCheckOptions) ([]client.MachineHealthCheck, error) {
	fake.getMachineHealthChecksMutex.Lock()
	ret, specificReturn := fake.getMachineHealthChecksReturnsOnCall[len(fake.getMachineHealthChecksArgsForCall)]
	fake.getMachineHealthChecksArgsForCall = append(fake.getMachineHealthChecksArgsForCall, struct {
		arg1 client.MachineHealthCheckOptions
	}{arg1})
	stub := fake.GetMachineHealthChecksStub
	fakeReturns := fake.getMachineHealthChecksReturns
	fake.recordInvocation("GetMachineHealthChecks", []interface{}{arg1})
	fake.getMachineHealthChecksMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Client) GetMachineHealthChecksCallCount() int {
	fake.getMachineHealthChecksMutex.RLock()
	defer fake.getMachineHealthChecksMutex.RUnlock()
	return len(fake.getMachineHealthChecksArgsForCall)
}

func (fake *Client) GetMachineHealthChecksCalls(stub func(client.MachineHealthCheckOptions) ([]client.MachineHealthCheck, error)) {
	fake.getMachineHealthChecksMutex.Lock()
	defer fake.getMachineHealthChecksMutex.Unlock()
	fake.GetMachineHealthChecksStub = stub
}

func (fake *Client) GetMachineHealthChecksArgsForCall(i int) client.MachineHealthCheckOptions {
	fake.getMachineHealthChecksMutex.RLock()
	defer fake.getMachineHealthChecksMutex.RUnlock()
	argsForCall := fake.getMachineHealthChecksArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) GetMachineHealthChecksReturns(result1 []client.MachineHealthCheck, result2 error) {
	fake.getMachineHealthChecksMutex.Lock()
	defer fake.getMachineHealthChecksMutex.Unlock()
	fake.GetMachineHealthChecksStub = nil
	fake.getMachineHealthChecksReturns = struct {
		result1 []client.MachineHealthCheck
		result2 error
	}{result1, result2}
}

func (fake *Client) GetMachineHealthChecksReturnsOnCall(i int, result1 []client.MachineHealthCheck, result2 error) {
	fake.getMachineHealthChecksMutex.Lock()
	defer fake.getMachineHealthChecksMutex.Unlock()
	fake.GetMachineHealthChecksStub = nil
	if fake.getMachineHealthChecksReturnsOnCall == nil {
		fake.getMachineHealthChecksReturnsOnCall = make(map[int]struct {
			result1 []client.MachineHealthCheck
			result2 error
		})
	}
	fake.getMachineHealthChecksReturnsOnCall[i] = struct {
		result1 []client.MachineHealthCheck
		result2 error
	}{result1, result2}
}

func (fake *Client) GetPacificClusterObject(arg1 string, arg2 string) (*v1alpha2.TanzuKubernetesCluster, error) {
	fake.getPacificClusterObjectMutex.Lock()
	ret, specificReturn := fake.getPacificClusterObjectReturnsOnCall[len(fake.getPacificClusterObjectArgsForCall)]
	fake.getPacificClusterObjectArgsForCall = append(fake.getPacificClusterObjectArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.GetPacificClusterObjectStub
	fakeReturns := fake.getPacificClusterObjectReturns
	fake.recordInvocation("GetPacificClusterObject", []interface{}{arg1, arg2})
	fake.getPacificClusterObjectMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Client) GetPacificClusterObjectCallCount() int {
	fake.getPacificClusterObjectMutex.RLock()
	defer fake.getPacificClusterObjectMutex.RUnlock()
	return len(fake.getPacificClusterObjectArgsForCall)
}

func (fake *Client) GetPacificClusterObjectCalls(stub func(string, string) (*v1alpha2.TanzuKubernetesCluster, error)) {
	fake.getPacificClusterObjectMutex.Lock()
	defer fake.getPacificClusterObjectMutex.Unlock()
	fake.GetPacificClusterObjectStub = stub
}

func (fake *Client) GetPacificClusterObjectArgsForCall(i int) (string, string) {
	fake.getPacificClusterObjectMutex.RLock()
	defer fake.getPacificClusterObjectMutex.RUnlock()
	argsForCall := fake.getPacificClusterObjectArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Client) GetPacificClusterObjectReturns(result1 *v1alpha2.TanzuKubernetesCluster, result2 error) {
	fake.getPacificClusterObjectMutex.Lock()
	defer fake.getPacificClusterObjectMutex.Unlock()
	fake.GetPacificClusterObjectStub = nil
	fake.getPacificClusterObjectReturns = struct {
		result1 *v1alpha2.TanzuKubernetesCluster
		result2 error
	}{result1, result2}
}

func (fake *Client) GetPacificClusterObjectReturnsOnCall(i int, result1 *v1alpha2.TanzuKubernetesCluster, result2 error) {
	fake.getPacificClusterObjectMutex.Lock()
	defer fake.getPacificClusterObjectMutex.Unlock()
	fake.GetPacificClusterObjectStub = nil
	if fake.getPacificClusterObjectReturnsOnCall == nil {
		fake.getPacificClusterObjectReturnsOnCall = make(map[int]struct {
			result1 *v1alpha2.TanzuKubernetesCluster
			result2 error
		})
	}
	fake.getPacificClusterObjectReturnsOnCall[i] = struct {
		result1 *v1alpha2.TanzuKubernetesCluster
		result2 error
	}{result1, result2}
}

func (fake *Client) GetPacificMachineDeployments(arg1 client.GetMachineDeploymentOptions) ([]v1alpha3.MachineDeployment, error) {
	fake.getPacificMachineDeploymentsMutex.Lock()
	ret, specificReturn := fake.getPacificMachineDeploymentsReturnsOnCall[len(fake.getPacificMachineDeploymentsArgsForCall)]
	fake.getPacificMachineDeploymentsArgsForCall = append(fake.getPacificMachineDeploymentsArgsForCall, struct {
		arg1 client.GetMachineDeploymentOptions
	}{arg1})
	stub := fake.GetPacificMachineDeploymentsStub
	fakeReturns := fake.getPacificMachineDeploymentsReturns
	fake.recordInvocation("GetPacificMachineDeployments", []interface{}{arg1})
	fake.getPacificMachineDeploymentsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Client) GetPacificMachineDeploymentsCallCount() int {
	fake.getPacificMachineDeploymentsMutex.RLock()
	defer fake.getPacificMachineDeploymentsMutex.RUnlock()
	return len(fake.getPacificMachineDeploymentsArgsForCall)
}

func (fake *Client) GetPacificMachineDeploymentsCalls(stub func(client.GetMachineDeploymentOptions) ([]v1alpha3.MachineDeployment, error)) {
	fake.getPacificMachineDeploymentsMutex.Lock()
	defer fake.getPacificMachineDeploymentsMutex.Unlock()
	fake.GetPacificMachineDeploymentsStub = stub
}

func (fake *Client) GetPacificMachineDeploymentsArgsForCall(i int) client.GetMachineDeploymentOptions {
	fake.getPacificMachineDeploymentsMutex.RLock()
	defer fake.getPacificMachineDeploymentsMutex.RUnlock()
	argsForCall := fake.getPacificMachineDeploymentsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) GetPacificMachineDeploymentsReturns(result1 []v1alpha3.MachineDeployment, result2 error) {
	fake.getPacificMachineDeploymentsMutex.Lock()
	defer fake.getPacificMachineDeploymentsMutex.Unlock()
	fake.GetPacificMachineDeploymentsStub = nil
	fake.getPacificMachineDeploymentsReturns = struct {
		result1 []v1alpha3.MachineDeployment
		result2 error
	}{result1, result2}
}

func (fake *Client) GetPacificMachineDeploymentsReturnsOnCall(i int, result1 []v1alpha3.MachineDeployment, result2 error) {
	fake.getPacificMachineDeploymentsMutex.Lock()
	defer fake.getPacificMachineDeploymentsMutex.Unlock()
	fake.GetPacificMachineDeploymentsStub = nil
	if fake.getPacificMachineDeploymentsReturnsOnCall == nil {
		fake.getPacificMachineDeploymentsReturnsOnCall = make(map[int]struct {
			result1 []v1alpha3.MachineDeployment
			result2 error
		})
	}
	fake.getPacificMachineDeploymentsReturnsOnCall[i] = struct {
		result1 []v1alpha3.MachineDeployment
		result2 error
	}{result1, result2}
}

func (fake *Client) GetRegionContexts(arg1 string) ([]region.RegionContext, error) {
	fake.getRegionContextsMutex.Lock()
	ret, specificReturn := fake.getRegionContextsReturnsOnCall[len(fake.getRegionContextsArgsForCall)]
	fake.getRegionContextsArgsForCall = append(fake.getRegionContextsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetRegionContextsStub
	fakeReturns := fake.getRegionContextsReturns
	fake.recordInvocation("GetRegionContexts", []interface{}{arg1})
	fake.getRegionContextsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Client) GetRegionContextsCallCount() int {
	fake.getRegionContextsMutex.RLock()
	defer fake.getRegionContextsMutex.RUnlock()
	return len(fake.getRegionContextsArgsForCall)
}

func (fake *Client) GetRegionContextsCalls(stub func(string) ([]region.RegionContext, error)) {
	fake.getRegionContextsMutex.Lock()
	defer fake.getRegionContextsMutex.Unlock()
	fake.GetRegionContextsStub = stub
}

func (fake *Client) GetRegionContextsArgsForCall(i int) string {
	fake.getRegionContextsMutex.RLock()
	defer fake.getRegionContextsMutex.RUnlock()
	argsForCall := fake.getRegionContextsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) GetRegionContextsReturns(result1 []region.RegionContext, result2 error) {
	fake.getRegionContextsMutex.Lock()
	defer fake.getRegionContextsMutex.Unlock()
	fake.GetRegionContextsStub = nil
	fake.getRegionContextsReturns = struct {
		result1 []region.RegionContext
		result2 error
	}{result1, result2}
}

func (fake *Client) GetRegionContextsReturnsOnCall(i int, result1 []region.RegionContext, result2 error) {
	fake.getRegionContextsMutex.Lock()
	defer fake.getRegionContextsMutex.Unlock()
	fake.GetRegionContextsStub = nil
	if fake.getRegionContextsReturnsOnCall == nil {
		fake.getRegionContextsReturnsOnCall = make(map[int]struct {
			result1 []region.RegionContext
			result2 error
		})
	}
	fake.getRegionContextsReturnsOnCall[i] = struct {
		result1 []region.RegionContext
		result2 error
	}{result1, result2}
}

func (fake *Client) GetTanzuKubernetesReleases(arg1 string) ([]v1alpha1.TanzuKubernetesRelease, error) {
	fake.getTanzuKubernetesReleasesMutex.Lock()
	ret, specificReturn := fake.getTanzuKubernetesReleasesReturnsOnCall[len(fake.getTanzuKubernetesReleasesArgsForCall)]
	fake.getTanzuKubernetesReleasesArgsForCall = append(fake.getTanzuKubernetesReleasesArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetTanzuKubernetesReleasesStub
	fakeReturns := fake.getTanzuKubernetesReleasesReturns
	fake.recordInvocation("GetTanzuKubernetesReleases", []interface{}{arg1})
	fake.getTanzuKubernetesReleasesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Client) GetTanzuKubernetesReleasesCallCount() int {
	fake.getTanzuKubernetesReleasesMutex.RLock()
	defer fake.getTanzuKubernetesReleasesMutex.RUnlock()
	return len(fake.getTanzuKubernetesReleasesArgsForCall)
}

func (fake *Client) GetTanzuKubernetesReleasesCalls(stub func(string) ([]v1alpha1.TanzuKubernetesRelease, error)) {
	fake.getTanzuKubernetesReleasesMutex.Lock()
	defer fake.getTanzuKubernetesReleasesMutex.Unlock()
	fake.GetTanzuKubernetesReleasesStub = stub
}

func (fake *Client) GetTanzuKubernetesReleasesArgsForCall(i int) string {
	fake.getTanzuKubernetesReleasesMutex.RLock()
	defer fake.getTanzuKubernetesReleasesMutex.RUnlock()
	argsForCall := fake.getTanzuKubernetesReleasesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) GetTanzuKubernetesReleasesReturns(result1 []v1alpha1.TanzuKubernetesRelease, result2 error) {
	fake.getTanzuKubernetesReleasesMutex.Lock()
	defer fake.getTanzuKubernetesReleasesMutex.Unlock()
	fake.GetTanzuKubernetesReleasesStub = nil
	fake.getTanzuKubernetesReleasesReturns = struct {
		result1 []v1alpha1.TanzuKubernetesRelease
		result2 error
	}{result1, result2}
}

func (fake *Client) GetTanzuKubernetesReleasesReturnsOnCall(i int, result1 []v1alpha1.TanzuKubernetesRelease, result2 error) {
	fake.getTanzuKubernetesReleasesMutex.Lock()
	defer fake.getTanzuKubernetesReleasesMutex.Unlock()
	fake.GetTanzuKubernetesReleasesStub = nil
	if fake.getTanzuKubernetesReleasesReturnsOnCall == nil {
		fake.getTanzuKubernetesReleasesReturnsOnCall = make(map[int]struct {
			result1 []v1alpha1.TanzuKubernetesRelease
			result2 error
		})
	}
	fake.getTanzuKubernetesReleasesReturnsOnCall[i] = struct {
		result1 []v1alpha1.TanzuKubernetesRelease
		result2 error
	}{result1, result2}
}

func (fake *Client) GetVSphereEndpoint(arg1 clusterclient.Client) (vc.Client, error) {
	fake.getVSphereEndpointMutex.Lock()
	ret, specificReturn := fake.getVSphereEndpointReturnsOnCall[len(fake.getVSphereEndpointArgsForCall)]
	fake.getVSphereEndpointArgsForCall = append(fake.getVSphereEndpointArgsForCall, struct {
		arg1 clusterclient.Client
	}{arg1})
	stub := fake.GetVSphereEndpointStub
	fakeReturns := fake.getVSphereEndpointReturns
	fake.recordInvocation("GetVSphereEndpoint", []interface{}{arg1})
	fake.getVSphereEndpointMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Client) GetVSphereEndpointCallCount() int {
	fake.getVSphereEndpointMutex.RLock()
	defer fake.getVSphereEndpointMutex.RUnlock()
	return len(fake.getVSphereEndpointArgsForCall)
}

func (fake *Client) GetVSphereEndpointCalls(stub func(clusterclient.Client) (vc.Client, error)) {
	fake.getVSphereEndpointMutex.Lock()
	defer fake.getVSphereEndpointMutex.Unlock()
	fake.GetVSphereEndpointStub = stub
}

func (fake *Client) GetVSphereEndpointArgsForCall(i int) clusterclient.Client {
	fake.getVSphereEndpointMutex.RLock()
	defer fake.getVSphereEndpointMutex.RUnlock()
	argsForCall := fake.getVSphereEndpointArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) GetVSphereEndpointReturns(result1 vc.Client, result2 error) {
	fake.getVSphereEndpointMutex.Lock()
	defer fake.getVSphereEndpointMutex.Unlock()
	fake.GetVSphereEndpointStub = nil
	fake.getVSphereEndpointReturns = struct {
		result1 vc.Client
		result2 error
	}{result1, result2}
}

func (fake *Client) GetVSphereEndpointReturnsOnCall(i int, result1 vc.Client, result2 error) {
	fake.getVSphereEndpointMutex.Lock()
	defer fake.getVSphereEndpointMutex.Unlock()
	fake.GetVSphereEndpointStub = nil
	if fake.getVSphereEndpointReturnsOnCall == nil {
		fake.getVSphereEndpointReturnsOnCall = make(map[int]struct {
			result1 vc.Client
			result2 error
		})
	}
	fake.getVSphereEndpointReturnsOnCall[i] = struct {
		result1 vc.Client
		result2 error
	}{result1, result2}
}

func (fake *Client) GetWorkloadClusterCredentials(arg1 client.GetWorkloadClusterCredentialsOptions) (string, string, error) {
	fake.getWorkloadClusterCredentialsMutex.Lock()
	ret, specificReturn := fake.getWorkloadClusterCredentialsReturnsOnCall[len(fake.getWorkloadClusterCredentialsArgsForCall)]
	fake.getWorkloadClusterCredentialsArgsForCall = append(fake.getWorkloadClusterCredentialsArgsForCall, struct {
		arg1 client.GetWorkloadClusterCredentialsOptions
	}{arg1})
	stub := fake.GetWorkloadClusterCredentialsStub
	fakeReturns := fake.getWorkloadClusterCredentialsReturns
	fake.recordInvocation("GetWorkloadClusterCredentials", []interface{}{arg1})
	fake.getWorkloadClusterCredentialsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *Client) GetWorkloadClusterCredentialsCallCount() int {
	fake.getWorkloadClusterCredentialsMutex.RLock()
	defer fake.getWorkloadClusterCredentialsMutex.RUnlock()
	return len(fake.getWorkloadClusterCredentialsArgsForCall)
}

func (fake *Client) GetWorkloadClusterCredentialsCalls(stub func(client.GetWorkloadClusterCredentialsOptions) (string, string, error)) {
	fake.getWorkloadClusterCredentialsMutex.Lock()
	defer fake.getWorkloadClusterCredentialsMutex.Unlock()
	fake.GetWorkloadClusterCredentialsStub = stub
}

func (fake *Client) GetWorkloadClusterCredentialsArgsForCall(i int) client.GetWorkloadClusterCredentialsOptions {
	fake.getWorkloadClusterCredentialsMutex.RLock()
	defer fake.getWorkloadClusterCredentialsMutex.RUnlock()
	argsForCall := fake.getWorkloadClusterCredentialsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) GetWorkloadClusterCredentialsReturns(result1 string, result2 string, result3 error) {
	fake.getWorkloadClusterCredentialsMutex.Lock()
	defer fake.getWorkloadClusterCredentialsMutex.Unlock()
	fake.GetWorkloadClusterCredentialsStub = nil
	fake.getWorkloadClusterCredentialsReturns = struct {
		result1 string
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *Client) GetWorkloadClusterCredentialsReturnsOnCall(i int, result1 string, result2 string, result3 error) {
	fake.getWorkloadClusterCredentialsMutex.Lock()
	defer fake.getWorkloadClusterCredentialsMutex.Unlock()
	fake.GetWorkloadClusterCredentialsStub = nil
	if fake.getWorkloadClusterCredentialsReturnsOnCall == nil {
		fake.getWorkloadClusterCredentialsReturnsOnCall = make(map[int]struct {
			result1 string
			result2 string
			result3 error
		})
	}
	fake.getWorkloadClusterCredentialsReturnsOnCall[i] = struct {
		result1 string
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *Client) InitRegion(arg1 *client.InitRegionOptions) error {
	fake.initRegionMutex.Lock()
	ret, specificReturn := fake.initRegionReturnsOnCall[len(fake.initRegionArgsForCall)]
	fake.initRegionArgsForCall = append(fake.initRegionArgsForCall, struct {
		arg1 *client.InitRegionOptions
	}{arg1})
	stub := fake.InitRegionStub
	fakeReturns := fake.initRegionReturns
	fake.recordInvocation("InitRegion", []interface{}{arg1})
	fake.initRegionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Client) InitRegionCallCount() int {
	fake.initRegionMutex.RLock()
	defer fake.initRegionMutex.RUnlock()
	return len(fake.initRegionArgsForCall)
}

func (fake *Client) InitRegionCalls(stub func(*client.InitRegionOptions) error) {
	fake.initRegionMutex.Lock()
	defer fake.initRegionMutex.Unlock()
	fake.InitRegionStub = stub
}

func (fake *Client) InitRegionArgsForCall(i int) *client.InitRegionOptions {
	fake.initRegionMutex.RLock()
	defer fake.initRegionMutex.RUnlock()
	argsForCall := fake.initRegionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) InitRegionReturns(result1 error) {
	fake.initRegionMutex.Lock()
	defer fake.initRegionMutex.Unlock()
	fake.InitRegionStub = nil
	fake.initRegionReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) InitRegionReturnsOnCall(i int, result1 error) {
	fake.initRegionMutex.Lock()
	defer fake.initRegionMutex.Unlock()
	fake.InitRegionStub = nil
	if fake.initRegionReturnsOnCall == nil {
		fake.initRegionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.initRegionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Client) InitRegionDryRun(arg1 *client.InitRegionOptions) ([]byte, error) {
	fake.initRegionDryRunMutex.Lock()
	ret, specificReturn := fake.initRegionDryRunReturnsOnCall[len(fake.initRegionDryRunArgsForCall)]
	fake.initRegionDryRunArgsForCall = append(fake.initRegionDryRunArgsForCall, struct {
		arg1 *client.InitRegionOptions
	}{arg1})
	stub := fake.InitRegionDryRunStub
	fakeReturns := fake.initRegionDryRunReturns
	fake.recordInvocation("InitRegionDryRun", []interface{}{arg1})
	fake.initRegionDryRunMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Client) InitRegionDryRunCallCount() int {
	fake.initRegionDryRunMutex.RLock()
	defer fake.initRegionDryRunMutex.RUnlock()
	return len(fake.initRegionDryRunArgsForCall)
}

func (fake *Client) InitRegionDryRunCalls(stub func(*client.InitRegionOptions) ([]byte, error)) {
	fake.initRegionDryRunMutex.Lock()
	defer fake.initRegionDryRunMutex.Unlock()
	fake.InitRegionDryRunStub = stub
}

func (fake *Client) InitRegionDryRunArgsForCall(i int) *client.InitRegionOptions {
	fake.initRegionDryRunMutex.RLock()
	defer fake.initRegionDryRunMutex.RUnlock()
	argsForCall := fake.initRegionDryRunArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) InitRegionDryRunReturns(result1 []byte, result2 error) {
	fake.initRegionDryRunMutex.Lock()
	defer fake.initRegionDryRunMutex.Unlock()
	fake.InitRegionDryRunStub = nil
	fake.initRegionDryRunReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *Client) InitRegionDryRunReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.initRegionDryRunMutex.Lock()
	defer fake.initRegionDryRunMutex.Unlock()
	fake.InitRegionDryRunStub = nil
	if fake.initRegionDryRunReturnsOnCall == nil {
		fake.initRegionDryRunReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.initRegionDryRunReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *Client) IsManagementClusterAKindCluster(arg1 string) (bool, error) {
	fake.isManagementClusterAKindClusterMutex.Lock()
	ret, specificReturn := fake.isManagementClusterAKindClusterReturnsOnCall[len(fake.isManagementClusterAKindClusterArgsForCall)]
	fake.isManagementClusterAKindClusterArgsForCall = append(fake.isManagementClusterAKindClusterArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.IsManagementClusterAKindClusterStub
	fakeReturns := fake.isManagementClusterAKindClusterReturns
	fake.recordInvocation("IsManagementClusterAKindCluster", []interface{}{arg1})
	fake.isManagementClusterAKindClusterMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Client) IsManagementClusterAKindClusterCallCount() int {
	fake.isManagementClusterAKindClusterMutex.RLock()
	defer fake.isManagementClusterAKindClusterMutex.RUnlock()
	return len(fake.isManagementClusterAKindClusterArgsForCall)
}

func (fake *Client) IsManagementClusterAKindClusterCalls(stub func(string) (bool, error)) {
	fake.isManagementClusterAKindClusterMutex.Lock()
	defer fake.isManagementClusterAKindClusterMutex.Unlock()
	fake.IsManagementClusterAKindClusterStub = stub
}

func (fake *Client) IsManagementClusterAKindClusterArgsForCall(i int) string {
	fake.isManagementClusterAKindClusterMutex.RLock()
	defer fake.isManagementClusterAKindClusterMutex.RUnlock()
	argsForCall := fake.isManagementClusterAKindClusterArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) IsManagementClusterAKindClusterReturns(result1 bool, result2 error) {
	fake.isManagementClusterAKindClusterMutex.Lock()
	defer fake.isManagementClusterAKindClusterMutex.Unlock()
	fake.IsManagementClusterAKindClusterStub = nil
	fake.isManagementClusterAKindClusterReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *Client) IsManagementClusterAKindClusterReturnsOnCall(i int, result1 bool, result2 error) {
	fake.isManagementClusterAKindClusterMutex.Lock()
	defer fake.isManagementClusterAKindClusterMutex.Unlock()
	fake.IsManagementClusterAKindClusterStub = nil
	if fake.isManagementClusterAKindClusterReturnsOnCall == nil {
		fake.isManagementClusterAKindClusterReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.isManagementClusterAKindClusterReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *Client) IsPacificManagementCluster() (bool, error) {
	fake.isPacificManagementClusterMutex.Lock()
	ret, specificReturn := fake.isPacificManagementClusterReturnsOnCall[len(fake.isPacificManagementClusterArgsForCall)]
	fake.isPacificManagementClusterArgsForCall = append(fake.isPacificManagementClusterArgsForCall, struct {
	}{})
	stub := fake.IsPacificManagementClusterStub
	fakeReturns := fake.isPacificManagementClusterReturns
	fake.recordInvocation("IsPacificManagementCluster", []interface{}{})
	fake.isPacificManagementClusterMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Client) IsPacificManagementClusterCallCount() int {
	fake.isPacificManagementClusterMutex.RLock()
	defer fake.isPacificManagementClusterMutex.RUnlock()
	return len(fake.isPacificManagementClusterArgsForCall)
}

func (fake *Client) IsPacificManagementClusterCalls(stub func() (bool, error)) {
	fake.isPacificManagementClusterMutex.Lock()
	defer fake.isPacificManagementClusterMutex.Unlock()
	fake.IsPacificManagementClusterStub = stub
}

func (fake *Client) IsPacificManagementClusterReturns(result1 bool, result2 error) {
	fake.isPacificManagementClusterMutex.Lock()
	defer fake.isPacificManagementClusterMutex.Unlock()
	fake.IsPacificManagementClusterStub = nil
	fake.isPacificManagementClusterReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *Client) IsPacificManagementClusterReturnsOnCall(i int, result1 bool, result2 error) {
	fake.isPacificManagementClusterMutex.Lock()
	defer fake.isPacificManagementClusterMutex.Unlock()
	fake.IsPacificManagementClusterStub = nil
	if fake.isPacificManagementClusterReturnsOnCall == nil {
		fake.isPacificManagementClusterReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.isPacificManagementClusterReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *Client) IsPacificRegionalCluster() (bool, error) {
	fake.isPacificRegionalClusterMutex.Lock()
	ret, specificReturn := fake.isPacificRegionalClusterReturnsOnCall[len(fake.isPacificRegionalClusterArgsForCall)]
	fake.isPacificRegionalClusterArgsForCall = append(fake.isPacificRegionalClusterArgsForCall, struct {
	}{})
	stub := fake.IsPacificRegionalClusterStub
	fakeReturns := fake.isPacificRegionalClusterReturns
	fake.recordInvocation("IsPacificRegionalCluster", []interface{}{})
	fake.isPacificRegionalClusterMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Client) IsPacificRegionalClusterCallCount() int {
	fake.isPacificRegionalClusterMutex.RLock()
	defer fake.isPacificRegionalClusterMutex.RUnlock()
	return len(fake.isPacificRegionalClusterArgsForCall)
}

func (fake *Client) IsPacificRegionalClusterCalls(stub func() (bool, error)) {
	fake.isPacificRegionalClusterMutex.Lock()
	defer fake.isPacificRegionalClusterMutex.Unlock()
	fake.IsPacificRegionalClusterStub = stub
}

func (fake *Client) IsPacificRegionalClusterReturns(result1 bool, result2 error) {
	fake.isPacificRegionalClusterMutex.Lock()
	defer fake.isPacificRegionalClusterMutex.Unlock()
	fake.IsPacificRegionalClusterStub = nil
	fake.isPacificRegionalClusterReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *Client) IsPacificRegionalClusterReturnsOnCall(i int, result1 bool, result2 error) {
	fake.isPacificRegionalClusterMutex.Lock()
	defer fake.isPacificRegionalClusterMutex.Unlock()
	fake.IsPacificRegionalClusterStub = nil
	if fake.isPacificRegionalClusterReturnsOnCall == nil {
		fake.isPacificRegionalClusterReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.isPacificRegionalClusterReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *Client) ListTKGClusters(arg1 client.ListTKGClustersOptions) ([]client.ClusterInfo, error) {
	fake.listTKGClustersMutex.Lock()
	ret, specificReturn := fake.listTKGClustersReturnsOnCall[len(fake.listTKGClustersArgsForCall)]
	fake.listTKGClustersArgsForCall = append(fake.listTKGClustersArgsForCall, struct {
		arg1 client.ListTKGClustersOptions
	}{arg1})
	stub := fake.ListTKGClustersStub
	fakeReturns := fake.listTKGClustersReturns
	fake.recordInvocation("ListTKGClusters", []interface{}{arg1})
	fake.listTKGClustersMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Client) ListTKGClustersCallCount() int {
	fake.listTKGClustersMutex.RLock()
	defer fake.listTKGClustersMutex.RUnlock()
	return len(fake.listTKGClustersArgsForCall)
}

func (fake *Client) ListTKGClustersCalls(stub func(client.ListTKGClustersOptions) ([]client.ClusterInfo, error)) {
	fake.listTKGClustersMutex.Lock()
	defer fake.listTKGClustersMutex.Unlock()
	fake.ListTKGClustersStub = stub
}

func (fake *Client) ListTKGClustersArgsForCall(i int) client.ListTKGClustersOptions {
	fake.listTKGClustersMutex.RLock()
	defer fake.listTKGClustersMutex.RUnlock()
	argsForCall := fake.listTKGClustersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) ListTKGClustersReturns(result1 []client.ClusterInfo, result2 error) {
	fake.listTKGClustersMutex.Lock()
	defer fake.listTKGClustersMutex.Unlock()
	fake.ListTKGClustersStub = nil
	fake.listTKGClustersReturns = struct {
		result1 []client.ClusterInfo
		result2 error
	}{result1, result2}
}

func (fake *Client) ListTKGClustersReturnsOnCall(i int, result1 []client.ClusterInfo, result2 error) {
	fake.listTKGClustersMutex.Lock()
	defer fake.listTKGClustersMutex.Unlock()
	fake.ListTKGClustersStub = nil
	if fake.listTKGClustersReturnsOnCall == nil {
		fake.listTKGClustersReturnsOnCall = make(map[int]struct {
			result1 []client.ClusterInfo
			result2 error
		})
	}
	fake.listTKGClustersReturnsOnCall[i] = struct {
		result1 []client.ClusterInfo
		result2 error
	}{result1, result2}
}

func (fake *Client) ParseHiddenArgsAsFeatureFlags(arg1 *client.InitRegionOptions) {
	fake.parseHiddenArgsAsFeatureFlagsMutex.Lock()
	fake.parseHiddenArgsAsFeatureFlagsArgsForCall = append(fake.parseHiddenArgsAsFeatureFlagsArgsForCall, struct {
		arg1 *client.InitRegionOptions
	}{arg1})
	stub := fake.ParseHiddenArgsAsFeatureFlagsStub
	fake.recordInvocation("ParseHiddenArgsAsFeatureFlags", []interface{}{arg1})
	fake.parseHiddenArgsAsFeatureFlagsMutex.Unlock()
	if stub != nil {
		fake.ParseHiddenArgsAsFeatureFlagsStub(arg1)
	}
}

func (fake *Client) ParseHiddenArgsAsFeatureFlagsCallCount() int {
	fake.parseHiddenArgsAsFeatureFlagsMutex.RLock()
	defer fake.parseHiddenArgsAsFeatureFlagsMutex.RUnlock()
	return len(fake.parseHiddenArgsAsFeatureFlagsArgsForCall)
}

func (fake *Client) ParseHiddenArgsAsFeatureFlagsCalls(stub func(*client.InitRegionOptions)) {
	fake.parseHiddenArgsAsFeatureFlagsMutex.Lock()
	defer fake.parseHiddenArgsAsFeatureFlagsMutex.Unlock()
	fake.ParseHiddenArgsAsFeatureFlagsStub = stub
}

func (fake *Client) ParseHiddenArgsAsFeatureFlagsArgsForCall(i int) *client.InitRegionOptions {
	fake.parseHiddenArgsAsFeatureFlagsMutex.RLock()
	defer fake.parseHiddenArgsAsFeatureFlagsMutex.RUnlock()
	argsForCall := fake.parseHiddenArgsAsFeatureFlagsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) RegisterManagementClusterToTmc(arg1 string, arg2 string) error {
	fake.registerManagementClusterToTmcMutex.Lock()
	ret, specificReturn := fake.registerManagementClusterToTmcReturnsOnCall[len(fake.registerManagementClusterToTmcArgsForCall)]
	fake.registerManagementClusterToTmcArgsForCall = append(fake.registerManagementClusterToTmcArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.RegisterManagementClusterToTmcStub
	fakeReturns := fake.registerManagementClusterToTmcReturns
	fake.recordInvocation("RegisterManagementClusterToTmc", []interface{}{arg1, arg2})
	fake.registerManagementClusterToTmcMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Client) RegisterManagementClusterToTmcCallCount() int {
	fake.registerManagementClusterToTmcMutex.RLock()
	defer fake.registerManagementClusterToTmcMutex.RUnlock()
	return len(fake.registerManagementClusterToTmcArgsForCall)
}

func (fake *Client) RegisterManagementClusterToTmcCalls(stub func(string, string) error) {
	fake.registerManagementClusterToTmcMutex.Lock()
	defer fake.registerManagementClusterToTmcMutex.Unlock()
	fake.RegisterManagementClusterToTmcStub = stub
}

func (fake *Client) RegisterManagementClusterToTmcArgsForCall(i int) (string, string) {
	fake.registerManagementClusterToTmcMutex.RLock()
	defer fake.registerManagementClusterToTmcMutex.RUnlock()
	argsForCall := fake.registerManagementClusterToTmcArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Client) RegisterManagementClusterToTmcReturns(result1 error) {
	fake.registerManagementClusterToTmcMutex.Lock()
	defer fake.registerManagementClusterToTmcMutex.Unlock()
	fake.RegisterManagementClusterToTmcStub = nil
	fake.registerManagementClusterToTmcReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) RegisterManagementClusterToTmcReturnsOnCall(i int, result1 error) {
	fake.registerManagementClusterToTmcMutex.Lock()
	defer fake.registerManagementClusterToTmcMutex.Unlock()
	fake.RegisterManagementClusterToTmcStub = nil
	if fake.registerManagementClusterToTmcReturnsOnCall == nil {
		fake.registerManagementClusterToTmcReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.registerManagementClusterToTmcReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Client) SaveFeatureFlags(arg1 map[string]string) error {
	fake.saveFeatureFlagsMutex.Lock()
	ret, specificReturn := fake.saveFeatureFlagsReturnsOnCall[len(fake.saveFeatureFlagsArgsForCall)]
	fake.saveFeatureFlagsArgsForCall = append(fake.saveFeatureFlagsArgsForCall, struct {
		arg1 map[string]string
	}{arg1})
	stub := fake.SaveFeatureFlagsStub
	fakeReturns := fake.saveFeatureFlagsReturns
	fake.recordInvocation("SaveFeatureFlags", []interface{}{arg1})
	fake.saveFeatureFlagsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Client) SaveFeatureFlagsCallCount() int {
	fake.saveFeatureFlagsMutex.RLock()
	defer fake.saveFeatureFlagsMutex.RUnlock()
	return len(fake.saveFeatureFlagsArgsForCall)
}

func (fake *Client) SaveFeatureFlagsCalls(stub func(map[string]string) error) {
	fake.saveFeatureFlagsMutex.Lock()
	defer fake.saveFeatureFlagsMutex.Unlock()
	fake.SaveFeatureFlagsStub = stub
}

func (fake *Client) SaveFeatureFlagsArgsForCall(i int) map[string]string {
	fake.saveFeatureFlagsMutex.RLock()
	defer fake.saveFeatureFlagsMutex.RUnlock()
	argsForCall := fake.saveFeatureFlagsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) SaveFeatureFlagsReturns(result1 error) {
	fake.saveFeatureFlagsMutex.Lock()
	defer fake.saveFeatureFlagsMutex.Unlock()
	fake.SaveFeatureFlagsStub = nil
	fake.saveFeatureFlagsReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) SaveFeatureFlagsReturnsOnCall(i int, result1 error) {
	fake.saveFeatureFlagsMutex.Lock()
	defer fake.saveFeatureFlagsMutex.Unlock()
	fake.SaveFeatureFlagsStub = nil
	if fake.saveFeatureFlagsReturnsOnCall == nil {
		fake.saveFeatureFlagsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveFeatureFlagsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Client) ScaleCluster(arg1 client.ScaleClusterOptions) error {
	fake.scaleClusterMutex.Lock()
	ret, specificReturn := fake.scaleClusterReturnsOnCall[len(fake.scaleClusterArgsForCall)]
	fake.scaleClusterArgsForCall = append(fake.scaleClusterArgsForCall, struct {
		arg1 client.ScaleClusterOptions
	}{arg1})
	stub := fake.ScaleClusterStub
	fakeReturns := fake.scaleClusterReturns
	fake.recordInvocation("ScaleCluster", []interface{}{arg1})
	fake.scaleClusterMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Client) ScaleClusterCallCount() int {
	fake.scaleClusterMutex.RLock()
	defer fake.scaleClusterMutex.RUnlock()
	return len(fake.scaleClusterArgsForCall)
}

func (fake *Client) ScaleClusterCalls(stub func(client.ScaleClusterOptions) error) {
	fake.scaleClusterMutex.Lock()
	defer fake.scaleClusterMutex.Unlock()
	fake.ScaleClusterStub = stub
}

func (fake *Client) ScaleClusterArgsForCall(i int) client.ScaleClusterOptions {
	fake.scaleClusterMutex.RLock()
	defer fake.scaleClusterMutex.RUnlock()
	argsForCall := fake.scaleClusterArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) ScaleClusterReturns(result1 error) {
	fake.scaleClusterMutex.Lock()
	defer fake.scaleClusterMutex.Unlock()
	fake.ScaleClusterStub = nil
	fake.scaleClusterReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) ScaleClusterReturnsOnCall(i int, result1 error) {
	fake.scaleClusterMutex.Lock()
	defer fake.scaleClusterMutex.Unlock()
	fake.ScaleClusterStub = nil
	if fake.scaleClusterReturnsOnCall == nil {
		fake.scaleClusterReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.scaleClusterReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Client) SetCEIPParticipation(arg1 bool, arg2 string, arg3 string) error {
	fake.setCEIPParticipationMutex.Lock()
	ret, specificReturn := fake.setCEIPParticipationReturnsOnCall[len(fake.setCEIPParticipationArgsForCall)]
	fake.setCEIPParticipationArgsForCall = append(fake.setCEIPParticipationArgsForCall, struct {
		arg1 bool
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.SetCEIPParticipationStub
	fakeReturns := fake.setCEIPParticipationReturns
	fake.recordInvocation("SetCEIPParticipation", []interface{}{arg1, arg2, arg3})
	fake.setCEIPParticipationMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Client) SetCEIPParticipationCallCount() int {
	fake.setCEIPParticipationMutex.RLock()
	defer fake.setCEIPParticipationMutex.RUnlock()
	return len(fake.setCEIPParticipationArgsForCall)
}

func (fake *Client) SetCEIPParticipationCalls(stub func(bool, string, string) error) {
	fake.setCEIPParticipationMutex.Lock()
	defer fake.setCEIPParticipationMutex.Unlock()
	fake.SetCEIPParticipationStub = stub
}

func (fake *Client) SetCEIPParticipationArgsForCall(i int) (bool, string, string) {
	fake.setCEIPParticipationMutex.RLock()
	defer fake.setCEIPParticipationMutex.RUnlock()
	argsForCall := fake.setCEIPParticipationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Client) SetCEIPParticipationReturns(result1 error) {
	fake.setCEIPParticipationMutex.Lock()
	defer fake.setCEIPParticipationMutex.Unlock()
	fake.SetCEIPParticipationStub = nil
	fake.setCEIPParticipationReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) SetCEIPParticipationReturnsOnCall(i int, result1 error) {
	fake.setCEIPParticipationMutex.Lock()
	defer fake.setCEIPParticipationMutex.Unlock()
	fake.SetCEIPParticipationStub = nil
	if fake.setCEIPParticipationReturnsOnCall == nil {
		fake.setCEIPParticipationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setCEIPParticipationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Client) SetMachineDeployment(arg1 *client.SetMachineDeploymentOptions) error {
	fake.setMachineDeploymentMutex.Lock()
	ret, specificReturn := fake.setMachineDeploymentReturnsOnCall[len(fake.setMachineDeploymentArgsForCall)]
	fake.setMachineDeploymentArgsForCall = append(fake.setMachineDeploymentArgsForCall, struct {
		arg1 *client.SetMachineDeploymentOptions
	}{arg1})
	stub := fake.SetMachineDeploymentStub
	fakeReturns := fake.setMachineDeploymentReturns
	fake.recordInvocation("SetMachineDeployment", []interface{}{arg1})
	fake.setMachineDeploymentMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Client) SetMachineDeploymentCallCount() int {
	fake.setMachineDeploymentMutex.RLock()
	defer fake.setMachineDeploymentMutex.RUnlock()
	return len(fake.setMachineDeploymentArgsForCall)
}

func (fake *Client) SetMachineDeploymentCalls(stub func(*client.SetMachineDeploymentOptions) error) {
	fake.setMachineDeploymentMutex.Lock()
	defer fake.setMachineDeploymentMutex.Unlock()
	fake.SetMachineDeploymentStub = stub
}

func (fake *Client) SetMachineDeploymentArgsForCall(i int) *client.SetMachineDeploymentOptions {
	fake.setMachineDeploymentMutex.RLock()
	defer fake.setMachineDeploymentMutex.RUnlock()
	argsForCall := fake.setMachineDeploymentArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) SetMachineDeploymentReturns(result1 error) {
	fake.setMachineDeploymentMutex.Lock()
	defer fake.setMachineDeploymentMutex.Unlock()
	fake.SetMachineDeploymentStub = nil
	fake.setMachineDeploymentReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) SetMachineDeploymentReturnsOnCall(i int, result1 error) {
	fake.setMachineDeploymentMutex.Lock()
	defer fake.setMachineDeploymentMutex.Unlock()
	fake.SetMachineDeploymentStub = nil
	if fake.setMachineDeploymentReturnsOnCall == nil {
		fake.setMachineDeploymentReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setMachineDeploymentReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Client) SetMachineHealthCheck(arg1 *client.SetMachineHealthCheckOptions) error {
	fake.setMachineHealthCheckMutex.Lock()
	ret, specificReturn := fake.setMachineHealthCheckReturnsOnCall[len(fake.setMachineHealthCheckArgsForCall)]
	fake.setMachineHealthCheckArgsForCall = append(fake.setMachineHealthCheckArgsForCall, struct {
		arg1 *client.SetMachineHealthCheckOptions
	}{arg1})
	stub := fake.SetMachineHealthCheckStub
	fakeReturns := fake.setMachineHealthCheckReturns
	fake.recordInvocation("SetMachineHealthCheck", []interface{}{arg1})
	fake.setMachineHealthCheckMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Client) SetMachineHealthCheckCallCount() int {
	fake.setMachineHealthCheckMutex.RLock()
	defer fake.setMachineHealthCheckMutex.RUnlock()
	return len(fake.setMachineHealthCheckArgsForCall)
}

func (fake *Client) SetMachineHealthCheckCalls(stub func(*client.SetMachineHealthCheckOptions) error) {
	fake.setMachineHealthCheckMutex.Lock()
	defer fake.setMachineHealthCheckMutex.Unlock()
	fake.SetMachineHealthCheckStub = stub
}

func (fake *Client) SetMachineHealthCheckArgsForCall(i int) *client.SetMachineHealthCheckOptions {
	fake.setMachineHealthCheckMutex.RLock()
	defer fake.setMachineHealthCheckMutex.RUnlock()
	argsForCall := fake.setMachineHealthCheckArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) SetMachineHealthCheckReturns(result1 error) {
	fake.setMachineHealthCheckMutex.Lock()
	defer fake.setMachineHealthCheckMutex.Unlock()
	fake.SetMachineHealthCheckStub = nil
	fake.setMachineHealthCheckReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) SetMachineHealthCheckReturnsOnCall(i int, result1 error) {
	fake.setMachineHealthCheckMutex.Lock()
	defer fake.setMachineHealthCheckMutex.Unlock()
	fake.SetMachineHealthCheckStub = nil
	if fake.setMachineHealthCheckReturnsOnCall == nil {
		fake.setMachineHealthCheckReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setMachineHealthCheckReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Client) SetRegionContext(arg1 string, arg2 string) error {
	fake.setRegionContextMutex.Lock()
	ret, specificReturn := fake.setRegionContextReturnsOnCall[len(fake.setRegionContextArgsForCall)]
	fake.setRegionContextArgsForCall = append(fake.setRegionContextArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.SetRegionContextStub
	fakeReturns := fake.setRegionContextReturns
	fake.recordInvocation("SetRegionContext", []interface{}{arg1, arg2})
	fake.setRegionContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Client) SetRegionContextCallCount() int {
	fake.setRegionContextMutex.RLock()
	defer fake.setRegionContextMutex.RUnlock()
	return len(fake.setRegionContextArgsForCall)
}

func (fake *Client) SetRegionContextCalls(stub func(string, string) error) {
	fake.setRegionContextMutex.Lock()
	defer fake.setRegionContextMutex.Unlock()
	fake.SetRegionContextStub = stub
}

func (fake *Client) SetRegionContextArgsForCall(i int) (string, string) {
	fake.setRegionContextMutex.RLock()
	defer fake.setRegionContextMutex.RUnlock()
	argsForCall := fake.setRegionContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Client) SetRegionContextReturns(result1 error) {
	fake.setRegionContextMutex.Lock()
	defer fake.setRegionContextMutex.Unlock()
	fake.SetRegionContextStub = nil
	fake.setRegionContextReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) SetRegionContextReturnsOnCall(i int, result1 error) {
	fake.setRegionContextMutex.Lock()
	defer fake.setRegionContextMutex.Unlock()
	fake.SetRegionContextStub = nil
	if fake.setRegionContextReturnsOnCall == nil {
		fake.setRegionContextReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setRegionContextReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Client) TKGConfigReaderWriter() tkgconfigreaderwriter.TKGConfigReaderWriter {
	fake.tKGConfigReaderWriterMutex.Lock()
	ret, specificReturn := fake.tKGConfigReaderWriterReturnsOnCall[len(fake.tKGConfigReaderWriterArgsForCall)]
	fake.tKGConfigReaderWriterArgsForCall = append(fake.tKGConfigReaderWriterArgsForCall, struct {
	}{})
	stub := fake.TKGConfigReaderWriterStub
	fakeReturns := fake.tKGConfigReaderWriterReturns
	fake.recordInvocation("TKGConfigReaderWriter", []interface{}{})
	fake.tKGConfigReaderWriterMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Client) TKGConfigReaderWriterCallCount() int {
	fake.tKGConfigReaderWriterMutex.RLock()
	defer fake.tKGConfigReaderWriterMutex.RUnlock()
	return len(fake.tKGConfigReaderWriterArgsForCall)
}

func (fake *Client) TKGConfigReaderWriterCalls(stub func() tkgconfigreaderwriter.TKGConfigReaderWriter) {
	fake.tKGConfigReaderWriterMutex.Lock()
	defer fake.tKGConfigReaderWriterMutex.Unlock()
	fake.TKGConfigReaderWriterStub = stub
}

func (fake *Client) TKGConfigReaderWriterReturns(result1 tkgconfigreaderwriter.TKGConfigReaderWriter) {
	fake.tKGConfigReaderWriterMutex.Lock()
	defer fake.tKGConfigReaderWriterMutex.Unlock()
	fake.TKGConfigReaderWriterStub = nil
	fake.tKGConfigReaderWriterReturns = struct {
		result1 tkgconfigreaderwriter.TKGConfigReaderWriter
	}{result1}
}

func (fake *Client) TKGConfigReaderWriterReturnsOnCall(i int, result1 tkgconfigreaderwriter.TKGConfigReaderWriter) {
	fake.tKGConfigReaderWriterMutex.Lock()
	defer fake.tKGConfigReaderWriterMutex.Unlock()
	fake.TKGConfigReaderWriterStub = nil
	if fake.tKGConfigReaderWriterReturnsOnCall == nil {
		fake.tKGConfigReaderWriterReturnsOnCall = make(map[int]struct {
			result1 tkgconfigreaderwriter.TKGConfigReaderWriter
		})
	}
	fake.tKGConfigReaderWriterReturnsOnCall[i] = struct {
		result1 tkgconfigreaderwriter.TKGConfigReaderWriter
	}{result1}
}

func (fake *Client) UpdateCredentialsCluster(arg1 *client.UpdateCredentialsOptions) error {
	fake.updateCredentialsClusterMutex.Lock()
	ret, specificReturn := fake.updateCredentialsClusterReturnsOnCall[len(fake.updateCredentialsClusterArgsForCall)]
	fake.updateCredentialsClusterArgsForCall = append(fake.updateCredentialsClusterArgsForCall, struct {
		arg1 *client.UpdateCredentialsOptions
	}{arg1})
	stub := fake.UpdateCredentialsClusterStub
	fakeReturns := fake.updateCredentialsClusterReturns
	fake.recordInvocation("UpdateCredentialsCluster", []interface{}{arg1})
	fake.updateCredentialsClusterMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Client) UpdateCredentialsClusterCallCount() int {
	fake.updateCredentialsClusterMutex.RLock()
	defer fake.updateCredentialsClusterMutex.RUnlock()
	return len(fake.updateCredentialsClusterArgsForCall)
}

func (fake *Client) UpdateCredentialsClusterCalls(stub func(*client.UpdateCredentialsOptions) error) {
	fake.updateCredentialsClusterMutex.Lock()
	defer fake.updateCredentialsClusterMutex.Unlock()
	fake.UpdateCredentialsClusterStub = stub
}

func (fake *Client) UpdateCredentialsClusterArgsForCall(i int) *client.UpdateCredentialsOptions {
	fake.updateCredentialsClusterMutex.RLock()
	defer fake.updateCredentialsClusterMutex.RUnlock()
	argsForCall := fake.updateCredentialsClusterArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) UpdateCredentialsClusterReturns(result1 error) {
	fake.updateCredentialsClusterMutex.Lock()
	defer fake.updateCredentialsClusterMutex.Unlock()
	fake.UpdateCredentialsClusterStub = nil
	fake.updateCredentialsClusterReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) UpdateCredentialsClusterReturnsOnCall(i int, result1 error) {
	fake.updateCredentialsClusterMutex.Lock()
	defer fake.updateCredentialsClusterMutex.Unlock()
	fake.UpdateCredentialsClusterStub = nil
	if fake.updateCredentialsClusterReturnsOnCall == nil {
		fake.updateCredentialsClusterReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateCredentialsClusterReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Client) UpdateCredentialsRegion(arg1 *client.UpdateCredentialsOptions) error {
	fake.updateCredentialsRegionMutex.Lock()
	ret, specificReturn := fake.updateCredentialsRegionReturnsOnCall[len(fake.updateCredentialsRegionArgsForCall)]
	fake.updateCredentialsRegionArgsForCall = append(fake.updateCredentialsRegionArgsForCall, struct {
		arg1 *client.UpdateCredentialsOptions
	}{arg1})
	stub := fake.UpdateCredentialsRegionStub
	fakeReturns := fake.updateCredentialsRegionReturns
	fake.recordInvocation("UpdateCredentialsRegion", []interface{}{arg1})
	fake.updateCredentialsRegionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Client) UpdateCredentialsRegionCallCount() int {
	fake.updateCredentialsRegionMutex.RLock()
	defer fake.updateCredentialsRegionMutex.RUnlock()
	return len(fake.updateCredentialsRegionArgsForCall)
}

func (fake *Client) UpdateCredentialsRegionCalls(stub func(*client.UpdateCredentialsOptions) error) {
	fake.updateCredentialsRegionMutex.Lock()
	defer fake.updateCredentialsRegionMutex.Unlock()
	fake.UpdateCredentialsRegionStub = stub
}

func (fake *Client) UpdateCredentialsRegionArgsForCall(i int) *client.UpdateCredentialsOptions {
	fake.updateCredentialsRegionMutex.RLock()
	defer fake.updateCredentialsRegionMutex.RUnlock()
	argsForCall := fake.updateCredentialsRegionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) UpdateCredentialsRegionReturns(result1 error) {
	fake.updateCredentialsRegionMutex.Lock()
	defer fake.updateCredentialsRegionMutex.Unlock()
	fake.UpdateCredentialsRegionStub = nil
	fake.updateCredentialsRegionReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) UpdateCredentialsRegionReturnsOnCall(i int, result1 error) {
	fake.updateCredentialsRegionMutex.Lock()
	defer fake.updateCredentialsRegionMutex.Unlock()
	fake.UpdateCredentialsRegionStub = nil
	if fake.updateCredentialsRegionReturnsOnCall == nil {
		fake.updateCredentialsRegionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateCredentialsRegionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Client) UpgradeCluster(arg1 *client.UpgradeClusterOptions) error {
	fake.upgradeClusterMutex.Lock()
	ret, specificReturn := fake.upgradeClusterReturnsOnCall[len(fake.upgradeClusterArgsForCall)]
	fake.upgradeClusterArgsForCall = append(fake.upgradeClusterArgsForCall, struct {
		arg1 *client.UpgradeClusterOptions
	}{arg1})
	stub := fake.UpgradeClusterStub
	fakeReturns := fake.upgradeClusterReturns
	fake.recordInvocation("UpgradeCluster", []interface{}{arg1})
	fake.upgradeClusterMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Client) UpgradeClusterCallCount() int {
	fake.upgradeClusterMutex.RLock()
	defer fake.upgradeClusterMutex.RUnlock()
	return len(fake.upgradeClusterArgsForCall)
}

func (fake *Client) UpgradeClusterCalls(stub func(*client.UpgradeClusterOptions) error) {
	fake.upgradeClusterMutex.Lock()
	defer fake.upgradeClusterMutex.Unlock()
	fake.UpgradeClusterStub = stub
}

func (fake *Client) UpgradeClusterArgsForCall(i int) *client.UpgradeClusterOptions {
	fake.upgradeClusterMutex.RLock()
	defer fake.upgradeClusterMutex.RUnlock()
	argsForCall := fake.upgradeClusterArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) UpgradeClusterReturns(result1 error) {
	fake.upgradeClusterMutex.Lock()
	defer fake.upgradeClusterMutex.Unlock()
	fake.UpgradeClusterStub = nil
	fake.upgradeClusterReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) UpgradeClusterReturnsOnCall(i int, result1 error) {
	fake.upgradeClusterMutex.Lock()
	defer fake.upgradeClusterMutex.Unlock()
	fake.UpgradeClusterStub = nil
	if fake.upgradeClusterReturnsOnCall == nil {
		fake.upgradeClusterReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.upgradeClusterReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Client) UpgradeManagementCluster(arg1 *client.UpgradeClusterOptions) error {
	fake.upgradeManagementClusterMutex.Lock()
	ret, specificReturn := fake.upgradeManagementClusterReturnsOnCall[len(fake.upgradeManagementClusterArgsForCall)]
	fake.upgradeManagementClusterArgsForCall = append(fake.upgradeManagementClusterArgsForCall, struct {
		arg1 *client.UpgradeClusterOptions
	}{arg1})
	stub := fake.UpgradeManagementClusterStub
	fakeReturns := fake.upgradeManagementClusterReturns
	fake.recordInvocation("UpgradeManagementCluster", []interface{}{arg1})
	fake.upgradeManagementClusterMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Client) UpgradeManagementClusterCallCount() int {
	fake.upgradeManagementClusterMutex.RLock()
	defer fake.upgradeManagementClusterMutex.RUnlock()
	return len(fake.upgradeManagementClusterArgsForCall)
}

func (fake *Client) UpgradeManagementClusterCalls(stub func(*client.UpgradeClusterOptions) error) {
	fake.upgradeManagementClusterMutex.Lock()
	defer fake.upgradeManagementClusterMutex.Unlock()
	fake.UpgradeManagementClusterStub = stub
}

func (fake *Client) UpgradeManagementClusterArgsForCall(i int) *client.UpgradeClusterOptions {
	fake.upgradeManagementClusterMutex.RLock()
	defer fake.upgradeManagementClusterMutex.RUnlock()
	argsForCall := fake.upgradeManagementClusterArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) UpgradeManagementClusterReturns(result1 error) {
	fake.upgradeManagementClusterMutex.Lock()
	defer fake.upgradeManagementClusterMutex.Unlock()
	fake.UpgradeManagementClusterStub = nil
	fake.upgradeManagementClusterReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) UpgradeManagementClusterReturnsOnCall(i int, result1 error) {
	fake.upgradeManagementClusterMutex.Lock()
	defer fake.upgradeManagementClusterMutex.Unlock()
	fake.UpgradeManagementClusterStub = nil
	if fake.upgradeManagementClusterReturnsOnCall == nil {
		fake.upgradeManagementClusterReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.upgradeManagementClusterReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Client) ValidatePrerequisites(arg1 bool, arg2 bool) error {
	fake.validatePrerequisitesMutex.Lock()
	ret, specificReturn := fake.validatePrerequisitesReturnsOnCall[len(fake.validatePrerequisitesArgsForCall)]
	fake.validatePrerequisitesArgsForCall = append(fake.validatePrerequisitesArgsForCall, struct {
		arg1 bool
		arg2 bool
	}{arg1, arg2})
	stub := fake.ValidatePrerequisitesStub
	fakeReturns := fake.validatePrerequisitesReturns
	fake.recordInvocation("ValidatePrerequisites", []interface{}{arg1, arg2})
	fake.validatePrerequisitesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Client) ValidatePrerequisitesCallCount() int {
	fake.validatePrerequisitesMutex.RLock()
	defer fake.validatePrerequisitesMutex.RUnlock()
	return len(fake.validatePrerequisitesArgsForCall)
}

func (fake *Client) ValidatePrerequisitesCalls(stub func(bool, bool) error) {
	fake.validatePrerequisitesMutex.Lock()
	defer fake.validatePrerequisitesMutex.Unlock()
	fake.ValidatePrerequisitesStub = stub
}

func (fake *Client) ValidatePrerequisitesArgsForCall(i int) (bool, bool) {
	fake.validatePrerequisitesMutex.RLock()
	defer fake.validatePrerequisitesMutex.RUnlock()
	argsForCall := fake.validatePrerequisitesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Client) ValidatePrerequisitesReturns(result1 error) {
	fake.validatePrerequisitesMutex.Lock()
	defer fake.validatePrerequisitesMutex.Unlock()
	fake.ValidatePrerequisitesStub = nil
	fake.validatePrerequisitesReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) ValidatePrerequisitesReturnsOnCall(i int, result1 error) {
	fake.validatePrerequisitesMutex.Lock()
	defer fake.validatePrerequisitesMutex.Unlock()
	fake.ValidatePrerequisitesStub = nil
	if fake.validatePrerequisitesReturnsOnCall == nil {
		fake.validatePrerequisitesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.validatePrerequisitesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Client) VerifyRegion(arg1 string) (region.RegionContext, error) {
	fake.verifyRegionMutex.Lock()
	ret, specificReturn := fake.verifyRegionReturnsOnCall[len(fake.verifyRegionArgsForCall)]
	fake.verifyRegionArgsForCall = append(fake.verifyRegionArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.VerifyRegionStub
	fakeReturns := fake.verifyRegionReturns
	fake.recordInvocation("VerifyRegion", []interface{}{arg1})
	fake.verifyRegionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Client) VerifyRegionCallCount() int {
	fake.verifyRegionMutex.RLock()
	defer fake.verifyRegionMutex.RUnlock()
	return len(fake.verifyRegionArgsForCall)
}

func (fake *Client) VerifyRegionCalls(stub func(string) (region.RegionContext, error)) {
	fake.verifyRegionMutex.Lock()
	defer fake.verifyRegionMutex.Unlock()
	fake.VerifyRegionStub = stub
}

func (fake *Client) VerifyRegionArgsForCall(i int) string {
	fake.verifyRegionMutex.RLock()
	defer fake.verifyRegionMutex.RUnlock()
	argsForCall := fake.verifyRegionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) VerifyRegionReturns(result1 region.RegionContext, result2 error) {
	fake.verifyRegionMutex.Lock()
	defer fake.verifyRegionMutex.Unlock()
	fake.VerifyRegionStub = nil
	fake.verifyRegionReturns = struct {
		result1 region.RegionContext
		result2 error
	}{result1, result2}
}

func (fake *Client) VerifyRegionReturnsOnCall(i int, result1 region.RegionContext, result2 error) {
	fake.verifyRegionMutex.Lock()
	defer fake.verifyRegionMutex.Unlock()
	fake.VerifyRegionStub = nil
	if fake.verifyRegionReturnsOnCall == nil {
		fake.verifyRegionReturnsOnCall = make(map[int]struct {
			result1 region.RegionContext
			result2 error
		})
	}
	fake.verifyRegionReturnsOnCall[i] = struct {
		result1 region.RegionContext
		result2 error
	}{result1, result2}
}

func (fake *Client) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.activateTanzuKubernetesReleasesMutex.RLock()
	defer fake.activateTanzuKubernetesReleasesMutex.RUnlock()
	fake.addRegionContextMutex.RLock()
	defer fake.addRegionContextMutex.RUnlock()
	fake.configureAndValidateManagementClusterConfigurationMutex.RLock()
	defer fake.configureAndValidateManagementClusterConfigurationMutex.RUnlock()
	fake.configureAndValidateTkrVersionMutex.RLock()
	defer fake.configureAndValidateTkrVersionMutex.RUnlock()
	fake.configureTimeoutMutex.RLock()
	defer fake.configureTimeoutMutex.RUnlock()
	fake.createAWSCloudFormationStackMutex.RLock()
	defer fake.createAWSCloudFormationStackMutex.RUnlock()
	fake.createClusterMutex.RLock()
	defer fake.createClusterMutex.RUnlock()
	fake.deRegisterManagementClusterFromTmcMutex.RLock()
	defer fake.deRegisterManagementClusterFromTmcMutex.RUnlock()
	fake.deactivateTanzuKubernetesReleasesMutex.RLock()
	defer fake.deactivateTanzuKubernetesReleasesMutex.RUnlock()
	fake.deleteMachineDeploymentMutex.RLock()
	defer fake.deleteMachineDeploymentMutex.RUnlock()
	fake.deleteMachineHealthCheckMutex.RLock()
	defer fake.deleteMachineHealthCheckMutex.RUnlock()
	fake.deleteRegionMutex.RLock()
	defer fake.deleteRegionMutex.RUnlock()
	fake.deleteWorkloadClusterMutex.RLock()
	defer fake.deleteWorkloadClusterMutex.RUnlock()
	fake.describeClusterMutex.RLock()
	defer fake.describeClusterMutex.RUnlock()
	fake.describeProviderMutex.RLock()
	defer fake.describeProviderMutex.RUnlock()
	fake.downloadBomFileMutex.RLock()
	defer fake.downloadBomFileMutex.RUnlock()
	fake.getCEIPParticipationMutex.RLock()
	defer fake.getCEIPParticipationMutex.RUnlock()
	fake.getClusterConfigurationMutex.RLock()
	defer fake.getClusterConfigurationMutex.RUnlock()
	fake.getClusterPinnipedInfoMutex.RLock()
	defer fake.getClusterPinnipedInfoMutex.RUnlock()
	fake.getCurrentRegionContextMutex.RLock()
	defer fake.getCurrentRegionContextMutex.RUnlock()
	fake.getKubernetesVersionsMutex.RLock()
	defer fake.getKubernetesVersionsMutex.RUnlock()
	fake.getMachineDeploymentsMutex.RLock()
	defer fake.getMachineDeploymentsMutex.RUnlock()
	fake.getMachineHealthChecksMutex.RLock()
	defer fake.getMachineHealthChecksMutex.RUnlock()
	fake.getPacificClusterObjectMutex.RLock()
	defer fake.getPacificClusterObjectMutex.RUnlock()
	fake.getPacificMachineDeploymentsMutex.RLock()
	defer fake.getPacificMachineDeploymentsMutex.RUnlock()
	fake.getRegionContextsMutex.RLock()
	defer fake.getRegionContextsMutex.RUnlock()
	fake.getTanzuKubernetesReleasesMutex.RLock()
	defer fake.getTanzuKubernetesReleasesMutex.RUnlock()
	fake.getVSphereEndpointMutex.RLock()
	defer fake.getVSphereEndpointMutex.RUnlock()
	fake.getWorkloadClusterCredentialsMutex.RLock()
	defer fake.getWorkloadClusterCredentialsMutex.RUnlock()
	fake.initRegionMutex.RLock()
	defer fake.initRegionMutex.RUnlock()
	fake.initRegionDryRunMutex.RLock()
	defer fake.initRegionDryRunMutex.RUnlock()
	fake.isManagementClusterAKindClusterMutex.RLock()
	defer fake.isManagementClusterAKindClusterMutex.RUnlock()
	fake.isPacificManagementClusterMutex.RLock()
	defer fake.isPacificManagementClusterMutex.RUnlock()
	fake.isPacificRegionalClusterMutex.RLock()
	defer fake.isPacificRegionalClusterMutex.RUnlock()
	fake.listTKGClustersMutex.RLock()
	defer fake.listTKGClustersMutex.RUnlock()
	fake.parseHiddenArgsAsFeatureFlagsMutex.RLock()
	defer fake.parseHiddenArgsAsFeatureFlagsMutex.RUnlock()
	fake.registerManagementClusterToTmcMutex.RLock()
	defer fake.registerManagementClusterToTmcMutex.RUnlock()
	fake.saveFeatureFlagsMutex.RLock()
	defer fake.saveFeatureFlagsMutex.RUnlock()
	fake.scaleClusterMutex.RLock()
	defer fake.scaleClusterMutex.RUnlock()
	fake.setCEIPParticipationMutex.RLock()
	defer fake.setCEIPParticipationMutex.RUnlock()
	fake.setMachineDeploymentMutex.RLock()
	defer fake.setMachineDeploymentMutex.RUnlock()
	fake.setMachineHealthCheckMutex.RLock()
	defer fake.setMachineHealthCheckMutex.RUnlock()
	fake.setRegionContextMutex.RLock()
	defer fake.setRegionContextMutex.RUnlock()
	fake.tKGConfigReaderWriterMutex.RLock()
	defer fake.tKGConfigReaderWriterMutex.RUnlock()
	fake.updateCredentialsClusterMutex.RLock()
	defer fake.updateCredentialsClusterMutex.RUnlock()
	fake.updateCredentialsRegionMutex.RLock()
	defer fake.updateCredentialsRegionMutex.RUnlock()
	fake.upgradeClusterMutex.RLock()
	defer fake.upgradeClusterMutex.RUnlock()
	fake.upgradeManagementClusterMutex.RLock()
	defer fake.upgradeManagementClusterMutex.RUnlock()
	fake.validatePrerequisitesMutex.RLock()
	defer fake.validatePrerequisitesMutex.RUnlock()
	fake.verifyRegionMutex.RLock()
	defer fake.verifyRegionMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *Client) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ client.Client = new(Client)
