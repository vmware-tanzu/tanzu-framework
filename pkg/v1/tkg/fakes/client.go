// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"
	"time"

	"github.com/fabriziopandini/capi-conditions/cmd/kubectl-capi-tree/status"
	"sigs.k8s.io/cluster-api/api/v1alpha3"
	v1alpha3a "sigs.k8s.io/cluster-api/cmd/clusterctl/api/v1alpha3"

	"github.com/vmware-tanzu-private/core/pkg/v1/tkg/api/run/v1alpha1"
	"github.com/vmware-tanzu-private/core/pkg/v1/tkg/client"
	"github.com/vmware-tanzu-private/core/pkg/v1/tkg/clusterclient"
	"github.com/vmware-tanzu-private/core/pkg/v1/tkg/region"
	"github.com/vmware-tanzu-private/core/pkg/v1/tkg/tkgconfigreaderwriter"
	"github.com/vmware-tanzu-private/core/pkg/v1/tkg/vc"
)

type Client struct {
	AddRegionContextStub        func(region.RegionContext, bool, bool) error
	addRegionContextMutex       sync.RWMutex
	addRegionContextArgsForCall []struct {
		arg1 region.RegionContext
		arg2 bool
		arg3 bool
	}
	addRegionContextReturns struct {
		result1 error
	}
	addRegionContextReturnsOnCall map[int]struct {
		result1 error
	}
	ConfigureAndValidateManagementClusterConfigurationStub        func(*client.InitRegionOptions, bool) *client.ValidationError
	configureAndValidateManagementClusterConfigurationMutex       sync.RWMutex
	configureAndValidateManagementClusterConfigurationArgsForCall []struct {
		arg1 *client.InitRegionOptions
		arg2 bool
	}
	configureAndValidateManagementClusterConfigurationReturns struct {
		result1 *client.ValidationError
	}
	configureAndValidateManagementClusterConfigurationReturnsOnCall map[int]struct {
		result1 *client.ValidationError
	}
	ConfigureAndValidateTkrVersionStub        func(string) (string, string, error)
	configureAndValidateTkrVersionMutex       sync.RWMutex
	configureAndValidateTkrVersionArgsForCall []struct {
		arg1 string
	}
	configureAndValidateTkrVersionReturns struct {
		result1 string
		result2 string
		result3 error
	}
	configureAndValidateTkrVersionReturnsOnCall map[int]struct {
		result1 string
		result2 string
		result3 error
	}
	ConfigureTimeoutStub        func(time.Duration)
	configureTimeoutMutex       sync.RWMutex
	configureTimeoutArgsForCall []struct {
		arg1 time.Duration
	}
	CreateAWSCloudFormationStackStub        func() error
	createAWSCloudFormationStackMutex       sync.RWMutex
	createAWSCloudFormationStackArgsForCall []struct {
	}
	createAWSCloudFormationStackReturns struct {
		result1 error
	}
	createAWSCloudFormationStackReturnsOnCall map[int]struct {
		result1 error
	}
	CreateClusterStub        func(*client.CreateClusterOptions, bool) error
	createClusterMutex       sync.RWMutex
	createClusterArgsForCall []struct {
		arg1 *client.CreateClusterOptions
		arg2 bool
	}
	createClusterReturns struct {
		result1 error
	}
	createClusterReturnsOnCall map[int]struct {
		result1 error
	}
	DeRegisterManagementClusterFromTmcStub        func(string) error
	deRegisterManagementClusterFromTmcMutex       sync.RWMutex
	deRegisterManagementClusterFromTmcArgsForCall []struct {
		arg1 string
	}
	deRegisterManagementClusterFromTmcReturns struct {
		result1 error
	}
	deRegisterManagementClusterFromTmcReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteMachineHealthCheckStub        func(client.MachineHealthCheckOptions) error
	deleteMachineHealthCheckMutex       sync.RWMutex
	deleteMachineHealthCheckArgsForCall []struct {
		arg1 client.MachineHealthCheckOptions
	}
	deleteMachineHealthCheckReturns struct {
		result1 error
	}
	deleteMachineHealthCheckReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteRegionStub        func(client.DeleteRegionOptions) error
	deleteRegionMutex       sync.RWMutex
	deleteRegionArgsForCall []struct {
		arg1 client.DeleteRegionOptions
	}
	deleteRegionReturns struct {
		result1 error
	}
	deleteRegionReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteWorkloadClusterStub        func(client.DeleteWorkloadClusterOptions) error
	deleteWorkloadClusterMutex       sync.RWMutex
	deleteWorkloadClusterArgsForCall []struct {
		arg1 client.DeleteWorkloadClusterOptions
	}
	deleteWorkloadClusterReturns struct {
		result1 error
	}
	deleteWorkloadClusterReturnsOnCall map[int]struct {
		result1 error
	}
	DescribeClusterStub        func(client.DescribeTKGClustersOptions) (*status.ObjectTree, *v1alpha3.Cluster, *v1alpha3a.ProviderList, error)
	describeClusterMutex       sync.RWMutex
	describeClusterArgsForCall []struct {
		arg1 client.DescribeTKGClustersOptions
	}
	describeClusterReturns struct {
		result1 *status.ObjectTree
		result2 *v1alpha3.Cluster
		result3 *v1alpha3a.ProviderList
		result4 error
	}
	describeClusterReturnsOnCall map[int]struct {
		result1 *status.ObjectTree
		result2 *v1alpha3.Cluster
		result3 *v1alpha3a.ProviderList
		result4 error
	}
	DescribeProviderStub        func() (*v1alpha3a.ProviderList, error)
	describeProviderMutex       sync.RWMutex
	describeProviderArgsForCall []struct {
	}
	describeProviderReturns struct {
		result1 *v1alpha3a.ProviderList
		result2 error
	}
	describeProviderReturnsOnCall map[int]struct {
		result1 *v1alpha3a.ProviderList
		result2 error
	}
	DownloadBomFileStub        func(string) error
	downloadBomFileMutex       sync.RWMutex
	downloadBomFileArgsForCall []struct {
		arg1 string
	}
	downloadBomFileReturns struct {
		result1 error
	}
	downloadBomFileReturnsOnCall map[int]struct {
		result1 error
	}
	GetCEIPParticipationStub        func() (client.ClusterCeipInfo, error)
	getCEIPParticipationMutex       sync.RWMutex
	getCEIPParticipationArgsForCall []struct {
	}
	getCEIPParticipationReturns struct {
		result1 client.ClusterCeipInfo
		result2 error
	}
	getCEIPParticipationReturnsOnCall map[int]struct {
		result1 client.ClusterCeipInfo
		result2 error
	}
	GetClusterConfigurationStub        func(*client.CreateClusterOptions) ([]byte, error)
	getClusterConfigurationMutex       sync.RWMutex
	getClusterConfigurationArgsForCall []struct {
		arg1 *client.CreateClusterOptions
	}
	getClusterConfigurationReturns struct {
		result1 []byte
		result2 error
	}
	getClusterConfigurationReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	GetClusterPinnipedInfoStub        func(client.GetClusterPinnipedInfoOptions) (*client.ClusterPinnipedInfo, error)
	getClusterPinnipedInfoMutex       sync.RWMutex
	getClusterPinnipedInfoArgsForCall []struct {
		arg1 client.GetClusterPinnipedInfoOptions
	}
	getClusterPinnipedInfoReturns struct {
		result1 *client.ClusterPinnipedInfo
		result2 error
	}
	getClusterPinnipedInfoReturnsOnCall map[int]struct {
		result1 *client.ClusterPinnipedInfo
		result2 error
	}
	GetCurrentRegionContextStub        func() (region.RegionContext, error)
	getCurrentRegionContextMutex       sync.RWMutex
	getCurrentRegionContextArgsForCall []struct {
	}
	getCurrentRegionContextReturns struct {
		result1 region.RegionContext
		result2 error
	}
	getCurrentRegionContextReturnsOnCall map[int]struct {
		result1 region.RegionContext
		result2 error
	}
	GetKubernetesVersionsStub        func() (*client.KubernetesVersionsInfo, error)
	getKubernetesVersionsMutex       sync.RWMutex
	getKubernetesVersionsArgsForCall []struct {
	}
	getKubernetesVersionsReturns struct {
		result1 *client.KubernetesVersionsInfo
		result2 error
	}
	getKubernetesVersionsReturnsOnCall map[int]struct {
		result1 *client.KubernetesVersionsInfo
		result2 error
	}
	GetMachineHealthChecksStub        func(client.MachineHealthCheckOptions) ([]client.MachineHealthCheck, error)
	getMachineHealthChecksMutex       sync.RWMutex
	getMachineHealthChecksArgsForCall []struct {
		arg1 client.MachineHealthCheckOptions
	}
	getMachineHealthChecksReturns struct {
		result1 []client.MachineHealthCheck
		result2 error
	}
	getMachineHealthChecksReturnsOnCall map[int]struct {
		result1 []client.MachineHealthCheck
		result2 error
	}
	GetRegionContextsStub        func(string) ([]region.RegionContext, error)
	getRegionContextsMutex       sync.RWMutex
	getRegionContextsArgsForCall []struct {
		arg1 string
	}
	getRegionContextsReturns struct {
		result1 []region.RegionContext
		result2 error
	}
	getRegionContextsReturnsOnCall map[int]struct {
		result1 []region.RegionContext
		result2 error
	}
	GetTanzuKubernetesReleasesStub        func(string) ([]v1alpha1.TanzuKubernetesRelease, error)
	getTanzuKubernetesReleasesMutex       sync.RWMutex
	getTanzuKubernetesReleasesArgsForCall []struct {
		arg1 string
	}
	getTanzuKubernetesReleasesReturns struct {
		result1 []v1alpha1.TanzuKubernetesRelease
		result2 error
	}
	getTanzuKubernetesReleasesReturnsOnCall map[int]struct {
		result1 []v1alpha1.TanzuKubernetesRelease
		result2 error
	}
	GetVSphereEndpointStub        func(clusterclient.Client) (vc.Client, error)
	getVSphereEndpointMutex       sync.RWMutex
	getVSphereEndpointArgsForCall []struct {
		arg1 clusterclient.Client
	}
	getVSphereEndpointReturns struct {
		result1 vc.Client
		result2 error
	}
	getVSphereEndpointReturnsOnCall map[int]struct {
		result1 vc.Client
		result2 error
	}
	GetWorkloadClusterCredentialsStub        func(client.GetWorkloadClusterCredentialsOptions) (string, string, error)
	getWorkloadClusterCredentialsMutex       sync.RWMutex
	getWorkloadClusterCredentialsArgsForCall []struct {
		arg1 client.GetWorkloadClusterCredentialsOptions
	}
	getWorkloadClusterCredentialsReturns struct {
		result1 string
		result2 string
		result3 error
	}
	getWorkloadClusterCredentialsReturnsOnCall map[int]struct {
		result1 string
		result2 string
		result3 error
	}
	InitRegionStub        func(*client.InitRegionOptions) error
	initRegionMutex       sync.RWMutex
	initRegionArgsForCall []struct {
		arg1 *client.InitRegionOptions
	}
	initRegionReturns struct {
		result1 error
	}
	initRegionReturnsOnCall map[int]struct {
		result1 error
	}
	InitRegionDryRunStub        func(*client.InitRegionOptions) ([]byte, error)
	initRegionDryRunMutex       sync.RWMutex
	initRegionDryRunArgsForCall []struct {
		arg1 *client.InitRegionOptions
	}
	initRegionDryRunReturns struct {
		result1 []byte
		result2 error
	}
	initRegionDryRunReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	IsManagementClusterAKindClusterStub        func(string) (bool, error)
	isManagementClusterAKindClusterMutex       sync.RWMutex
	isManagementClusterAKindClusterArgsForCall []struct {
		arg1 string
	}
	isManagementClusterAKindClusterReturns struct {
		result1 bool
		result2 error
	}
	isManagementClusterAKindClusterReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	IsPacificManagementClusterStub        func() (bool, error)
	isPacificManagementClusterMutex       sync.RWMutex
	isPacificManagementClusterArgsForCall []struct {
	}
	isPacificManagementClusterReturns struct {
		result1 bool
		result2 error
	}
	isPacificManagementClusterReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	ListTKGClustersStub        func(client.ListTKGClustersOptions) ([]client.ClusterInfo, error)
	listTKGClustersMutex       sync.RWMutex
	listTKGClustersArgsForCall []struct {
		arg1 client.ListTKGClustersOptions
	}
	listTKGClustersReturns struct {
		result1 []client.ClusterInfo
		result2 error
	}
	listTKGClustersReturnsOnCall map[int]struct {
		result1 []client.ClusterInfo
		result2 error
	}
	ParseHiddenArgsAsFeatureFlagsStub        func(*client.InitRegionOptions)
	parseHiddenArgsAsFeatureFlagsMutex       sync.RWMutex
	parseHiddenArgsAsFeatureFlagsArgsForCall []struct {
		arg1 *client.InitRegionOptions
	}
	RegisterManagementClusterToTmcStub        func(string, string) error
	registerManagementClusterToTmcMutex       sync.RWMutex
	registerManagementClusterToTmcArgsForCall []struct {
		arg1 string
		arg2 string
	}
	registerManagementClusterToTmcReturns struct {
		result1 error
	}
	registerManagementClusterToTmcReturnsOnCall map[int]struct {
		result1 error
	}
	SaveFeatureFlagsStub        func(map[string]string) error
	saveFeatureFlagsMutex       sync.RWMutex
	saveFeatureFlagsArgsForCall []struct {
		arg1 map[string]string
	}
	saveFeatureFlagsReturns struct {
		result1 error
	}
	saveFeatureFlagsReturnsOnCall map[int]struct {
		result1 error
	}
	ScaleClusterStub        func(client.ScaleClusterOptions) error
	scaleClusterMutex       sync.RWMutex
	scaleClusterArgsForCall []struct {
		arg1 client.ScaleClusterOptions
	}
	scaleClusterReturns struct {
		result1 error
	}
	scaleClusterReturnsOnCall map[int]struct {
		result1 error
	}
	SetCEIPParticipationStub        func(bool, string, string) error
	setCEIPParticipationMutex       sync.RWMutex
	setCEIPParticipationArgsForCall []struct {
		arg1 bool
		arg2 string
		arg3 string
	}
	setCEIPParticipationReturns struct {
		result1 error
	}
	setCEIPParticipationReturnsOnCall map[int]struct {
		result1 error
	}
	SetMachineHealthCheckStub        func(*client.SetMachineHealthCheckOptions) error
	setMachineHealthCheckMutex       sync.RWMutex
	setMachineHealthCheckArgsForCall []struct {
		arg1 *client.SetMachineHealthCheckOptions
	}
	setMachineHealthCheckReturns struct {
		result1 error
	}
	setMachineHealthCheckReturnsOnCall map[int]struct {
		result1 error
	}
	SetRegionContextStub        func(string, string) error
	setRegionContextMutex       sync.RWMutex
	setRegionContextArgsForCall []struct {
		arg1 string
		arg2 string
	}
	setRegionContextReturns struct {
		result1 error
	}
	setRegionContextReturnsOnCall map[int]struct {
		result1 error
	}
	TKGConfigReaderWriterStub        func() tkgconfigreaderwriter.TKGConfigReaderWriter
	tKGConfigReaderWriterMutex       sync.RWMutex
	tKGConfigReaderWriterArgsForCall []struct {
	}
	tKGConfigReaderWriterReturns struct {
		result1 tkgconfigreaderwriter.TKGConfigReaderWriter
	}
	tKGConfigReaderWriterReturnsOnCall map[int]struct {
		result1 tkgconfigreaderwriter.TKGConfigReaderWriter
	}
	UpdateCredentialsClusterStub        func(*client.UpdateCredentialsOptions) error
	updateCredentialsClusterMutex       sync.RWMutex
	updateCredentialsClusterArgsForCall []struct {
		arg1 *client.UpdateCredentialsOptions
	}
	updateCredentialsClusterReturns struct {
		result1 error
	}
	updateCredentialsClusterReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateCredentialsRegionStub        func(*client.UpdateCredentialsOptions) error
	updateCredentialsRegionMutex       sync.RWMutex
	updateCredentialsRegionArgsForCall []struct {
		arg1 *client.UpdateCredentialsOptions
	}
	updateCredentialsRegionReturns struct {
		result1 error
	}
	updateCredentialsRegionReturnsOnCall map[int]struct {
		result1 error
	}
	UpgradeClusterStub        func(*client.UpgradeClusterOptions) error
	upgradeClusterMutex       sync.RWMutex
	upgradeClusterArgsForCall []struct {
		arg1 *client.UpgradeClusterOptions
	}
	upgradeClusterReturns struct {
		result1 error
	}
	upgradeClusterReturnsOnCall map[int]struct {
		result1 error
	}
	UpgradeManagementClusterStub        func(*client.UpgradeClusterOptions) error
	upgradeManagementClusterMutex       sync.RWMutex
	upgradeManagementClusterArgsForCall []struct {
		arg1 *client.UpgradeClusterOptions
	}
	upgradeManagementClusterReturns struct {
		result1 error
	}
	upgradeManagementClusterReturnsOnCall map[int]struct {
		result1 error
	}
	ValidatePrerequisitesStub        func(bool, bool) error
	validatePrerequisitesMutex       sync.RWMutex
	validatePrerequisitesArgsForCall []struct {
		arg1 bool
		arg2 bool
	}
	validatePrerequisitesReturns struct {
		result1 error
	}
	validatePrerequisitesReturnsOnCall map[int]struct {
		result1 error
	}
	VerifyRegionStub        func(string) (region.RegionContext, error)
	verifyRegionMutex       sync.RWMutex
	verifyRegionArgsForCall []struct {
		arg1 string
	}
	verifyRegionReturns struct {
		result1 region.RegionContext
		result2 error
	}
	verifyRegionReturnsOnCall map[int]struct {
		result1 region.RegionContext
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *Client) AddRegionContext(arg1 region.RegionContext, arg2 bool, arg3 bool) error {
	fake.addRegionContextMutex.Lock()
	ret, specificReturn := fake.addRegionContextReturnsOnCall[len(fake.addRegionContextArgsForCall)]
	fake.addRegionContextArgsForCall = append(fake.addRegionContextArgsForCall, struct {
		arg1 region.RegionContext
		arg2 bool
		arg3 bool
	}{arg1, arg2, arg3})
	fake.recordInvocation("AddRegionContext", []interface{}{arg1, arg2, arg3})
	fake.addRegionContextMutex.Unlock()
	if fake.AddRegionContextStub != nil {
		return fake.AddRegionContextStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.addRegionContextReturns
	return fakeReturns.result1
}

func (fake *Client) AddRegionContextCallCount() int {
	fake.addRegionContextMutex.RLock()
	defer fake.addRegionContextMutex.RUnlock()
	return len(fake.addRegionContextArgsForCall)
}

func (fake *Client) AddRegionContextCalls(stub func(region.RegionContext, bool, bool) error) {
	fake.addRegionContextMutex.Lock()
	defer fake.addRegionContextMutex.Unlock()
	fake.AddRegionContextStub = stub
}

func (fake *Client) AddRegionContextArgsForCall(i int) (region.RegionContext, bool, bool) {
	fake.addRegionContextMutex.RLock()
	defer fake.addRegionContextMutex.RUnlock()
	argsForCall := fake.addRegionContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Client) AddRegionContextReturns(result1 error) {
	fake.addRegionContextMutex.Lock()
	defer fake.addRegionContextMutex.Unlock()
	fake.AddRegionContextStub = nil
	fake.addRegionContextReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) AddRegionContextReturnsOnCall(i int, result1 error) {
	fake.addRegionContextMutex.Lock()
	defer fake.addRegionContextMutex.Unlock()
	fake.AddRegionContextStub = nil
	if fake.addRegionContextReturnsOnCall == nil {
		fake.addRegionContextReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addRegionContextReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Client) ConfigureAndValidateManagementClusterConfiguration(arg1 *client.InitRegionOptions, arg2 bool) *client.ValidationError {
	fake.configureAndValidateManagementClusterConfigurationMutex.Lock()
	ret, specificReturn := fake.configureAndValidateManagementClusterConfigurationReturnsOnCall[len(fake.configureAndValidateManagementClusterConfigurationArgsForCall)]
	fake.configureAndValidateManagementClusterConfigurationArgsForCall = append(fake.configureAndValidateManagementClusterConfigurationArgsForCall, struct {
		arg1 *client.InitRegionOptions
		arg2 bool
	}{arg1, arg2})
	fake.recordInvocation("ConfigureAndValidateManagementClusterConfiguration", []interface{}{arg1, arg2})
	fake.configureAndValidateManagementClusterConfigurationMutex.Unlock()
	if fake.ConfigureAndValidateManagementClusterConfigurationStub != nil {
		return fake.ConfigureAndValidateManagementClusterConfigurationStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.configureAndValidateManagementClusterConfigurationReturns
	return fakeReturns.result1
}

func (fake *Client) ConfigureAndValidateManagementClusterConfigurationCallCount() int {
	fake.configureAndValidateManagementClusterConfigurationMutex.RLock()
	defer fake.configureAndValidateManagementClusterConfigurationMutex.RUnlock()
	return len(fake.configureAndValidateManagementClusterConfigurationArgsForCall)
}

func (fake *Client) ConfigureAndValidateManagementClusterConfigurationCalls(stub func(*client.InitRegionOptions, bool) *client.ValidationError) {
	fake.configureAndValidateManagementClusterConfigurationMutex.Lock()
	defer fake.configureAndValidateManagementClusterConfigurationMutex.Unlock()
	fake.ConfigureAndValidateManagementClusterConfigurationStub = stub
}

func (fake *Client) ConfigureAndValidateManagementClusterConfigurationArgsForCall(i int) (*client.InitRegionOptions, bool) {
	fake.configureAndValidateManagementClusterConfigurationMutex.RLock()
	defer fake.configureAndValidateManagementClusterConfigurationMutex.RUnlock()
	argsForCall := fake.configureAndValidateManagementClusterConfigurationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Client) ConfigureAndValidateManagementClusterConfigurationReturns(result1 *client.ValidationError) {
	fake.configureAndValidateManagementClusterConfigurationMutex.Lock()
	defer fake.configureAndValidateManagementClusterConfigurationMutex.Unlock()
	fake.ConfigureAndValidateManagementClusterConfigurationStub = nil
	fake.configureAndValidateManagementClusterConfigurationReturns = struct {
		result1 *client.ValidationError
	}{result1}
}

func (fake *Client) ConfigureAndValidateManagementClusterConfigurationReturnsOnCall(i int, result1 *client.ValidationError) {
	fake.configureAndValidateManagementClusterConfigurationMutex.Lock()
	defer fake.configureAndValidateManagementClusterConfigurationMutex.Unlock()
	fake.ConfigureAndValidateManagementClusterConfigurationStub = nil
	if fake.configureAndValidateManagementClusterConfigurationReturnsOnCall == nil {
		fake.configureAndValidateManagementClusterConfigurationReturnsOnCall = make(map[int]struct {
			result1 *client.ValidationError
		})
	}
	fake.configureAndValidateManagementClusterConfigurationReturnsOnCall[i] = struct {
		result1 *client.ValidationError
	}{result1}
}

func (fake *Client) ConfigureAndValidateTkrVersion(arg1 string) (string, string, error) {
	fake.configureAndValidateTkrVersionMutex.Lock()
	ret, specificReturn := fake.configureAndValidateTkrVersionReturnsOnCall[len(fake.configureAndValidateTkrVersionArgsForCall)]
	fake.configureAndValidateTkrVersionArgsForCall = append(fake.configureAndValidateTkrVersionArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("ConfigureAndValidateTkrVersion", []interface{}{arg1})
	fake.configureAndValidateTkrVersionMutex.Unlock()
	if fake.ConfigureAndValidateTkrVersionStub != nil {
		return fake.ConfigureAndValidateTkrVersionStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.configureAndValidateTkrVersionReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *Client) ConfigureAndValidateTkrVersionCallCount() int {
	fake.configureAndValidateTkrVersionMutex.RLock()
	defer fake.configureAndValidateTkrVersionMutex.RUnlock()
	return len(fake.configureAndValidateTkrVersionArgsForCall)
}

func (fake *Client) ConfigureAndValidateTkrVersionCalls(stub func(string) (string, string, error)) {
	fake.configureAndValidateTkrVersionMutex.Lock()
	defer fake.configureAndValidateTkrVersionMutex.Unlock()
	fake.ConfigureAndValidateTkrVersionStub = stub
}

func (fake *Client) ConfigureAndValidateTkrVersionArgsForCall(i int) string {
	fake.configureAndValidateTkrVersionMutex.RLock()
	defer fake.configureAndValidateTkrVersionMutex.RUnlock()
	argsForCall := fake.configureAndValidateTkrVersionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) ConfigureAndValidateTkrVersionReturns(result1 string, result2 string, result3 error) {
	fake.configureAndValidateTkrVersionMutex.Lock()
	defer fake.configureAndValidateTkrVersionMutex.Unlock()
	fake.ConfigureAndValidateTkrVersionStub = nil
	fake.configureAndValidateTkrVersionReturns = struct {
		result1 string
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *Client) ConfigureAndValidateTkrVersionReturnsOnCall(i int, result1 string, result2 string, result3 error) {
	fake.configureAndValidateTkrVersionMutex.Lock()
	defer fake.configureAndValidateTkrVersionMutex.Unlock()
	fake.ConfigureAndValidateTkrVersionStub = nil
	if fake.configureAndValidateTkrVersionReturnsOnCall == nil {
		fake.configureAndValidateTkrVersionReturnsOnCall = make(map[int]struct {
			result1 string
			result2 string
			result3 error
		})
	}
	fake.configureAndValidateTkrVersionReturnsOnCall[i] = struct {
		result1 string
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *Client) ConfigureTimeout(arg1 time.Duration) {
	fake.configureTimeoutMutex.Lock()
	fake.configureTimeoutArgsForCall = append(fake.configureTimeoutArgsForCall, struct {
		arg1 time.Duration
	}{arg1})
	fake.recordInvocation("ConfigureTimeout", []interface{}{arg1})
	fake.configureTimeoutMutex.Unlock()
	if fake.ConfigureTimeoutStub != nil {
		fake.ConfigureTimeoutStub(arg1)
	}
}

func (fake *Client) ConfigureTimeoutCallCount() int {
	fake.configureTimeoutMutex.RLock()
	defer fake.configureTimeoutMutex.RUnlock()
	return len(fake.configureTimeoutArgsForCall)
}

func (fake *Client) ConfigureTimeoutCalls(stub func(time.Duration)) {
	fake.configureTimeoutMutex.Lock()
	defer fake.configureTimeoutMutex.Unlock()
	fake.ConfigureTimeoutStub = stub
}

func (fake *Client) ConfigureTimeoutArgsForCall(i int) time.Duration {
	fake.configureTimeoutMutex.RLock()
	defer fake.configureTimeoutMutex.RUnlock()
	argsForCall := fake.configureTimeoutArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) CreateAWSCloudFormationStack() error {
	fake.createAWSCloudFormationStackMutex.Lock()
	ret, specificReturn := fake.createAWSCloudFormationStackReturnsOnCall[len(fake.createAWSCloudFormationStackArgsForCall)]
	fake.createAWSCloudFormationStackArgsForCall = append(fake.createAWSCloudFormationStackArgsForCall, struct {
	}{})
	fake.recordInvocation("CreateAWSCloudFormationStack", []interface{}{})
	fake.createAWSCloudFormationStackMutex.Unlock()
	if fake.CreateAWSCloudFormationStackStub != nil {
		return fake.CreateAWSCloudFormationStackStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.createAWSCloudFormationStackReturns
	return fakeReturns.result1
}

func (fake *Client) CreateAWSCloudFormationStackCallCount() int {
	fake.createAWSCloudFormationStackMutex.RLock()
	defer fake.createAWSCloudFormationStackMutex.RUnlock()
	return len(fake.createAWSCloudFormationStackArgsForCall)
}

func (fake *Client) CreateAWSCloudFormationStackCalls(stub func() error) {
	fake.createAWSCloudFormationStackMutex.Lock()
	defer fake.createAWSCloudFormationStackMutex.Unlock()
	fake.CreateAWSCloudFormationStackStub = stub
}

func (fake *Client) CreateAWSCloudFormationStackReturns(result1 error) {
	fake.createAWSCloudFormationStackMutex.Lock()
	defer fake.createAWSCloudFormationStackMutex.Unlock()
	fake.CreateAWSCloudFormationStackStub = nil
	fake.createAWSCloudFormationStackReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) CreateAWSCloudFormationStackReturnsOnCall(i int, result1 error) {
	fake.createAWSCloudFormationStackMutex.Lock()
	defer fake.createAWSCloudFormationStackMutex.Unlock()
	fake.CreateAWSCloudFormationStackStub = nil
	if fake.createAWSCloudFormationStackReturnsOnCall == nil {
		fake.createAWSCloudFormationStackReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createAWSCloudFormationStackReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Client) CreateCluster(arg1 *client.CreateClusterOptions, arg2 bool) error {
	fake.createClusterMutex.Lock()
	ret, specificReturn := fake.createClusterReturnsOnCall[len(fake.createClusterArgsForCall)]
	fake.createClusterArgsForCall = append(fake.createClusterArgsForCall, struct {
		arg1 *client.CreateClusterOptions
		arg2 bool
	}{arg1, arg2})
	fake.recordInvocation("CreateCluster", []interface{}{arg1, arg2})
	fake.createClusterMutex.Unlock()
	if fake.CreateClusterStub != nil {
		return fake.CreateClusterStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.createClusterReturns
	return fakeReturns.result1
}

func (fake *Client) CreateClusterCallCount() int {
	fake.createClusterMutex.RLock()
	defer fake.createClusterMutex.RUnlock()
	return len(fake.createClusterArgsForCall)
}

func (fake *Client) CreateClusterCalls(stub func(*client.CreateClusterOptions, bool) error) {
	fake.createClusterMutex.Lock()
	defer fake.createClusterMutex.Unlock()
	fake.CreateClusterStub = stub
}

func (fake *Client) CreateClusterArgsForCall(i int) (*client.CreateClusterOptions, bool) {
	fake.createClusterMutex.RLock()
	defer fake.createClusterMutex.RUnlock()
	argsForCall := fake.createClusterArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Client) CreateClusterReturns(result1 error) {
	fake.createClusterMutex.Lock()
	defer fake.createClusterMutex.Unlock()
	fake.CreateClusterStub = nil
	fake.createClusterReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) CreateClusterReturnsOnCall(i int, result1 error) {
	fake.createClusterMutex.Lock()
	defer fake.createClusterMutex.Unlock()
	fake.CreateClusterStub = nil
	if fake.createClusterReturnsOnCall == nil {
		fake.createClusterReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createClusterReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Client) DeRegisterManagementClusterFromTmc(arg1 string) error {
	fake.deRegisterManagementClusterFromTmcMutex.Lock()
	ret, specificReturn := fake.deRegisterManagementClusterFromTmcReturnsOnCall[len(fake.deRegisterManagementClusterFromTmcArgsForCall)]
	fake.deRegisterManagementClusterFromTmcArgsForCall = append(fake.deRegisterManagementClusterFromTmcArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("DeRegisterManagementClusterFromTmc", []interface{}{arg1})
	fake.deRegisterManagementClusterFromTmcMutex.Unlock()
	if fake.DeRegisterManagementClusterFromTmcStub != nil {
		return fake.DeRegisterManagementClusterFromTmcStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deRegisterManagementClusterFromTmcReturns
	return fakeReturns.result1
}

func (fake *Client) DeRegisterManagementClusterFromTmcCallCount() int {
	fake.deRegisterManagementClusterFromTmcMutex.RLock()
	defer fake.deRegisterManagementClusterFromTmcMutex.RUnlock()
	return len(fake.deRegisterManagementClusterFromTmcArgsForCall)
}

func (fake *Client) DeRegisterManagementClusterFromTmcCalls(stub func(string) error) {
	fake.deRegisterManagementClusterFromTmcMutex.Lock()
	defer fake.deRegisterManagementClusterFromTmcMutex.Unlock()
	fake.DeRegisterManagementClusterFromTmcStub = stub
}

func (fake *Client) DeRegisterManagementClusterFromTmcArgsForCall(i int) string {
	fake.deRegisterManagementClusterFromTmcMutex.RLock()
	defer fake.deRegisterManagementClusterFromTmcMutex.RUnlock()
	argsForCall := fake.deRegisterManagementClusterFromTmcArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) DeRegisterManagementClusterFromTmcReturns(result1 error) {
	fake.deRegisterManagementClusterFromTmcMutex.Lock()
	defer fake.deRegisterManagementClusterFromTmcMutex.Unlock()
	fake.DeRegisterManagementClusterFromTmcStub = nil
	fake.deRegisterManagementClusterFromTmcReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) DeRegisterManagementClusterFromTmcReturnsOnCall(i int, result1 error) {
	fake.deRegisterManagementClusterFromTmcMutex.Lock()
	defer fake.deRegisterManagementClusterFromTmcMutex.Unlock()
	fake.DeRegisterManagementClusterFromTmcStub = nil
	if fake.deRegisterManagementClusterFromTmcReturnsOnCall == nil {
		fake.deRegisterManagementClusterFromTmcReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deRegisterManagementClusterFromTmcReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Client) DeleteMachineHealthCheck(arg1 client.MachineHealthCheckOptions) error {
	fake.deleteMachineHealthCheckMutex.Lock()
	ret, specificReturn := fake.deleteMachineHealthCheckReturnsOnCall[len(fake.deleteMachineHealthCheckArgsForCall)]
	fake.deleteMachineHealthCheckArgsForCall = append(fake.deleteMachineHealthCheckArgsForCall, struct {
		arg1 client.MachineHealthCheckOptions
	}{arg1})
	fake.recordInvocation("DeleteMachineHealthCheck", []interface{}{arg1})
	fake.deleteMachineHealthCheckMutex.Unlock()
	if fake.DeleteMachineHealthCheckStub != nil {
		return fake.DeleteMachineHealthCheckStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteMachineHealthCheckReturns
	return fakeReturns.result1
}

func (fake *Client) DeleteMachineHealthCheckCallCount() int {
	fake.deleteMachineHealthCheckMutex.RLock()
	defer fake.deleteMachineHealthCheckMutex.RUnlock()
	return len(fake.deleteMachineHealthCheckArgsForCall)
}

func (fake *Client) DeleteMachineHealthCheckCalls(stub func(client.MachineHealthCheckOptions) error) {
	fake.deleteMachineHealthCheckMutex.Lock()
	defer fake.deleteMachineHealthCheckMutex.Unlock()
	fake.DeleteMachineHealthCheckStub = stub
}

func (fake *Client) DeleteMachineHealthCheckArgsForCall(i int) client.MachineHealthCheckOptions {
	fake.deleteMachineHealthCheckMutex.RLock()
	defer fake.deleteMachineHealthCheckMutex.RUnlock()
	argsForCall := fake.deleteMachineHealthCheckArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) DeleteMachineHealthCheckReturns(result1 error) {
	fake.deleteMachineHealthCheckMutex.Lock()
	defer fake.deleteMachineHealthCheckMutex.Unlock()
	fake.DeleteMachineHealthCheckStub = nil
	fake.deleteMachineHealthCheckReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) DeleteMachineHealthCheckReturnsOnCall(i int, result1 error) {
	fake.deleteMachineHealthCheckMutex.Lock()
	defer fake.deleteMachineHealthCheckMutex.Unlock()
	fake.DeleteMachineHealthCheckStub = nil
	if fake.deleteMachineHealthCheckReturnsOnCall == nil {
		fake.deleteMachineHealthCheckReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteMachineHealthCheckReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Client) DeleteRegion(arg1 client.DeleteRegionOptions) error {
	fake.deleteRegionMutex.Lock()
	ret, specificReturn := fake.deleteRegionReturnsOnCall[len(fake.deleteRegionArgsForCall)]
	fake.deleteRegionArgsForCall = append(fake.deleteRegionArgsForCall, struct {
		arg1 client.DeleteRegionOptions
	}{arg1})
	fake.recordInvocation("DeleteRegion", []interface{}{arg1})
	fake.deleteRegionMutex.Unlock()
	if fake.DeleteRegionStub != nil {
		return fake.DeleteRegionStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteRegionReturns
	return fakeReturns.result1
}

func (fake *Client) DeleteRegionCallCount() int {
	fake.deleteRegionMutex.RLock()
	defer fake.deleteRegionMutex.RUnlock()
	return len(fake.deleteRegionArgsForCall)
}

func (fake *Client) DeleteRegionCalls(stub func(client.DeleteRegionOptions) error) {
	fake.deleteRegionMutex.Lock()
	defer fake.deleteRegionMutex.Unlock()
	fake.DeleteRegionStub = stub
}

func (fake *Client) DeleteRegionArgsForCall(i int) client.DeleteRegionOptions {
	fake.deleteRegionMutex.RLock()
	defer fake.deleteRegionMutex.RUnlock()
	argsForCall := fake.deleteRegionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) DeleteRegionReturns(result1 error) {
	fake.deleteRegionMutex.Lock()
	defer fake.deleteRegionMutex.Unlock()
	fake.DeleteRegionStub = nil
	fake.deleteRegionReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) DeleteRegionReturnsOnCall(i int, result1 error) {
	fake.deleteRegionMutex.Lock()
	defer fake.deleteRegionMutex.Unlock()
	fake.DeleteRegionStub = nil
	if fake.deleteRegionReturnsOnCall == nil {
		fake.deleteRegionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteRegionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Client) DeleteWorkloadCluster(arg1 client.DeleteWorkloadClusterOptions) error {
	fake.deleteWorkloadClusterMutex.Lock()
	ret, specificReturn := fake.deleteWorkloadClusterReturnsOnCall[len(fake.deleteWorkloadClusterArgsForCall)]
	fake.deleteWorkloadClusterArgsForCall = append(fake.deleteWorkloadClusterArgsForCall, struct {
		arg1 client.DeleteWorkloadClusterOptions
	}{arg1})
	fake.recordInvocation("DeleteWorkloadCluster", []interface{}{arg1})
	fake.deleteWorkloadClusterMutex.Unlock()
	if fake.DeleteWorkloadClusterStub != nil {
		return fake.DeleteWorkloadClusterStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteWorkloadClusterReturns
	return fakeReturns.result1
}

func (fake *Client) DeleteWorkloadClusterCallCount() int {
	fake.deleteWorkloadClusterMutex.RLock()
	defer fake.deleteWorkloadClusterMutex.RUnlock()
	return len(fake.deleteWorkloadClusterArgsForCall)
}

func (fake *Client) DeleteWorkloadClusterCalls(stub func(client.DeleteWorkloadClusterOptions) error) {
	fake.deleteWorkloadClusterMutex.Lock()
	defer fake.deleteWorkloadClusterMutex.Unlock()
	fake.DeleteWorkloadClusterStub = stub
}

func (fake *Client) DeleteWorkloadClusterArgsForCall(i int) client.DeleteWorkloadClusterOptions {
	fake.deleteWorkloadClusterMutex.RLock()
	defer fake.deleteWorkloadClusterMutex.RUnlock()
	argsForCall := fake.deleteWorkloadClusterArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) DeleteWorkloadClusterReturns(result1 error) {
	fake.deleteWorkloadClusterMutex.Lock()
	defer fake.deleteWorkloadClusterMutex.Unlock()
	fake.DeleteWorkloadClusterStub = nil
	fake.deleteWorkloadClusterReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) DeleteWorkloadClusterReturnsOnCall(i int, result1 error) {
	fake.deleteWorkloadClusterMutex.Lock()
	defer fake.deleteWorkloadClusterMutex.Unlock()
	fake.DeleteWorkloadClusterStub = nil
	if fake.deleteWorkloadClusterReturnsOnCall == nil {
		fake.deleteWorkloadClusterReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteWorkloadClusterReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Client) DescribeCluster(arg1 client.DescribeTKGClustersOptions) (*status.ObjectTree, *v1alpha3.Cluster, *v1alpha3a.ProviderList, error) {
	fake.describeClusterMutex.Lock()
	ret, specificReturn := fake.describeClusterReturnsOnCall[len(fake.describeClusterArgsForCall)]
	fake.describeClusterArgsForCall = append(fake.describeClusterArgsForCall, struct {
		arg1 client.DescribeTKGClustersOptions
	}{arg1})
	fake.recordInvocation("DescribeCluster", []interface{}{arg1})
	fake.describeClusterMutex.Unlock()
	if fake.DescribeClusterStub != nil {
		return fake.DescribeClusterStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4
	}
	fakeReturns := fake.describeClusterReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3, fakeReturns.result4
}

func (fake *Client) DescribeClusterCallCount() int {
	fake.describeClusterMutex.RLock()
	defer fake.describeClusterMutex.RUnlock()
	return len(fake.describeClusterArgsForCall)
}

func (fake *Client) DescribeClusterCalls(stub func(client.DescribeTKGClustersOptions) (*status.ObjectTree, *v1alpha3.Cluster, *v1alpha3a.ProviderList, error)) {
	fake.describeClusterMutex.Lock()
	defer fake.describeClusterMutex.Unlock()
	fake.DescribeClusterStub = stub
}

func (fake *Client) DescribeClusterArgsForCall(i int) client.DescribeTKGClustersOptions {
	fake.describeClusterMutex.RLock()
	defer fake.describeClusterMutex.RUnlock()
	argsForCall := fake.describeClusterArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) DescribeClusterReturns(result1 *status.ObjectTree, result2 *v1alpha3.Cluster, result3 *v1alpha3a.ProviderList, result4 error) {
	fake.describeClusterMutex.Lock()
	defer fake.describeClusterMutex.Unlock()
	fake.DescribeClusterStub = nil
	fake.describeClusterReturns = struct {
		result1 *status.ObjectTree
		result2 *v1alpha3.Cluster
		result3 *v1alpha3a.ProviderList
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *Client) DescribeClusterReturnsOnCall(i int, result1 *status.ObjectTree, result2 *v1alpha3.Cluster, result3 *v1alpha3a.ProviderList, result4 error) {
	fake.describeClusterMutex.Lock()
	defer fake.describeClusterMutex.Unlock()
	fake.DescribeClusterStub = nil
	if fake.describeClusterReturnsOnCall == nil {
		fake.describeClusterReturnsOnCall = make(map[int]struct {
			result1 *status.ObjectTree
			result2 *v1alpha3.Cluster
			result3 *v1alpha3a.ProviderList
			result4 error
		})
	}
	fake.describeClusterReturnsOnCall[i] = struct {
		result1 *status.ObjectTree
		result2 *v1alpha3.Cluster
		result3 *v1alpha3a.ProviderList
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *Client) DescribeProvider() (*v1alpha3a.ProviderList, error) {
	fake.describeProviderMutex.Lock()
	ret, specificReturn := fake.describeProviderReturnsOnCall[len(fake.describeProviderArgsForCall)]
	fake.describeProviderArgsForCall = append(fake.describeProviderArgsForCall, struct {
	}{})
	fake.recordInvocation("DescribeProvider", []interface{}{})
	fake.describeProviderMutex.Unlock()
	if fake.DescribeProviderStub != nil {
		return fake.DescribeProviderStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.describeProviderReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Client) DescribeProviderCallCount() int {
	fake.describeProviderMutex.RLock()
	defer fake.describeProviderMutex.RUnlock()
	return len(fake.describeProviderArgsForCall)
}

func (fake *Client) DescribeProviderCalls(stub func() (*v1alpha3a.ProviderList, error)) {
	fake.describeProviderMutex.Lock()
	defer fake.describeProviderMutex.Unlock()
	fake.DescribeProviderStub = stub
}

func (fake *Client) DescribeProviderReturns(result1 *v1alpha3a.ProviderList, result2 error) {
	fake.describeProviderMutex.Lock()
	defer fake.describeProviderMutex.Unlock()
	fake.DescribeProviderStub = nil
	fake.describeProviderReturns = struct {
		result1 *v1alpha3a.ProviderList
		result2 error
	}{result1, result2}
}

func (fake *Client) DescribeProviderReturnsOnCall(i int, result1 *v1alpha3a.ProviderList, result2 error) {
	fake.describeProviderMutex.Lock()
	defer fake.describeProviderMutex.Unlock()
	fake.DescribeProviderStub = nil
	if fake.describeProviderReturnsOnCall == nil {
		fake.describeProviderReturnsOnCall = make(map[int]struct {
			result1 *v1alpha3a.ProviderList
			result2 error
		})
	}
	fake.describeProviderReturnsOnCall[i] = struct {
		result1 *v1alpha3a.ProviderList
		result2 error
	}{result1, result2}
}

func (fake *Client) DownloadBomFile(arg1 string) error {
	fake.downloadBomFileMutex.Lock()
	ret, specificReturn := fake.downloadBomFileReturnsOnCall[len(fake.downloadBomFileArgsForCall)]
	fake.downloadBomFileArgsForCall = append(fake.downloadBomFileArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("DownloadBomFile", []interface{}{arg1})
	fake.downloadBomFileMutex.Unlock()
	if fake.DownloadBomFileStub != nil {
		return fake.DownloadBomFileStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.downloadBomFileReturns
	return fakeReturns.result1
}

func (fake *Client) DownloadBomFileCallCount() int {
	fake.downloadBomFileMutex.RLock()
	defer fake.downloadBomFileMutex.RUnlock()
	return len(fake.downloadBomFileArgsForCall)
}

func (fake *Client) DownloadBomFileCalls(stub func(string) error) {
	fake.downloadBomFileMutex.Lock()
	defer fake.downloadBomFileMutex.Unlock()
	fake.DownloadBomFileStub = stub
}

func (fake *Client) DownloadBomFileArgsForCall(i int) string {
	fake.downloadBomFileMutex.RLock()
	defer fake.downloadBomFileMutex.RUnlock()
	argsForCall := fake.downloadBomFileArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) DownloadBomFileReturns(result1 error) {
	fake.downloadBomFileMutex.Lock()
	defer fake.downloadBomFileMutex.Unlock()
	fake.DownloadBomFileStub = nil
	fake.downloadBomFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) DownloadBomFileReturnsOnCall(i int, result1 error) {
	fake.downloadBomFileMutex.Lock()
	defer fake.downloadBomFileMutex.Unlock()
	fake.DownloadBomFileStub = nil
	if fake.downloadBomFileReturnsOnCall == nil {
		fake.downloadBomFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.downloadBomFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Client) GetCEIPParticipation() (client.ClusterCeipInfo, error) {
	fake.getCEIPParticipationMutex.Lock()
	ret, specificReturn := fake.getCEIPParticipationReturnsOnCall[len(fake.getCEIPParticipationArgsForCall)]
	fake.getCEIPParticipationArgsForCall = append(fake.getCEIPParticipationArgsForCall, struct {
	}{})
	fake.recordInvocation("GetCEIPParticipation", []interface{}{})
	fake.getCEIPParticipationMutex.Unlock()
	if fake.GetCEIPParticipationStub != nil {
		return fake.GetCEIPParticipationStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getCEIPParticipationReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Client) GetCEIPParticipationCallCount() int {
	fake.getCEIPParticipationMutex.RLock()
	defer fake.getCEIPParticipationMutex.RUnlock()
	return len(fake.getCEIPParticipationArgsForCall)
}

func (fake *Client) GetCEIPParticipationCalls(stub func() (client.ClusterCeipInfo, error)) {
	fake.getCEIPParticipationMutex.Lock()
	defer fake.getCEIPParticipationMutex.Unlock()
	fake.GetCEIPParticipationStub = stub
}

func (fake *Client) GetCEIPParticipationReturns(result1 client.ClusterCeipInfo, result2 error) {
	fake.getCEIPParticipationMutex.Lock()
	defer fake.getCEIPParticipationMutex.Unlock()
	fake.GetCEIPParticipationStub = nil
	fake.getCEIPParticipationReturns = struct {
		result1 client.ClusterCeipInfo
		result2 error
	}{result1, result2}
}

func (fake *Client) GetCEIPParticipationReturnsOnCall(i int, result1 client.ClusterCeipInfo, result2 error) {
	fake.getCEIPParticipationMutex.Lock()
	defer fake.getCEIPParticipationMutex.Unlock()
	fake.GetCEIPParticipationStub = nil
	if fake.getCEIPParticipationReturnsOnCall == nil {
		fake.getCEIPParticipationReturnsOnCall = make(map[int]struct {
			result1 client.ClusterCeipInfo
			result2 error
		})
	}
	fake.getCEIPParticipationReturnsOnCall[i] = struct {
		result1 client.ClusterCeipInfo
		result2 error
	}{result1, result2}
}

func (fake *Client) GetClusterConfiguration(arg1 *client.CreateClusterOptions) ([]byte, error) {
	fake.getClusterConfigurationMutex.Lock()
	ret, specificReturn := fake.getClusterConfigurationReturnsOnCall[len(fake.getClusterConfigurationArgsForCall)]
	fake.getClusterConfigurationArgsForCall = append(fake.getClusterConfigurationArgsForCall, struct {
		arg1 *client.CreateClusterOptions
	}{arg1})
	fake.recordInvocation("GetClusterConfiguration", []interface{}{arg1})
	fake.getClusterConfigurationMutex.Unlock()
	if fake.GetClusterConfigurationStub != nil {
		return fake.GetClusterConfigurationStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getClusterConfigurationReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Client) GetClusterConfigurationCallCount() int {
	fake.getClusterConfigurationMutex.RLock()
	defer fake.getClusterConfigurationMutex.RUnlock()
	return len(fake.getClusterConfigurationArgsForCall)
}

func (fake *Client) GetClusterConfigurationCalls(stub func(*client.CreateClusterOptions) ([]byte, error)) {
	fake.getClusterConfigurationMutex.Lock()
	defer fake.getClusterConfigurationMutex.Unlock()
	fake.GetClusterConfigurationStub = stub
}

func (fake *Client) GetClusterConfigurationArgsForCall(i int) *client.CreateClusterOptions {
	fake.getClusterConfigurationMutex.RLock()
	defer fake.getClusterConfigurationMutex.RUnlock()
	argsForCall := fake.getClusterConfigurationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) GetClusterConfigurationReturns(result1 []byte, result2 error) {
	fake.getClusterConfigurationMutex.Lock()
	defer fake.getClusterConfigurationMutex.Unlock()
	fake.GetClusterConfigurationStub = nil
	fake.getClusterConfigurationReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *Client) GetClusterConfigurationReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.getClusterConfigurationMutex.Lock()
	defer fake.getClusterConfigurationMutex.Unlock()
	fake.GetClusterConfigurationStub = nil
	if fake.getClusterConfigurationReturnsOnCall == nil {
		fake.getClusterConfigurationReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.getClusterConfigurationReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *Client) GetClusterPinnipedInfo(arg1 client.GetClusterPinnipedInfoOptions) (*client.ClusterPinnipedInfo, error) {
	fake.getClusterPinnipedInfoMutex.Lock()
	ret, specificReturn := fake.getClusterPinnipedInfoReturnsOnCall[len(fake.getClusterPinnipedInfoArgsForCall)]
	fake.getClusterPinnipedInfoArgsForCall = append(fake.getClusterPinnipedInfoArgsForCall, struct {
		arg1 client.GetClusterPinnipedInfoOptions
	}{arg1})
	fake.recordInvocation("GetClusterPinnipedInfo", []interface{}{arg1})
	fake.getClusterPinnipedInfoMutex.Unlock()
	if fake.GetClusterPinnipedInfoStub != nil {
		return fake.GetClusterPinnipedInfoStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getClusterPinnipedInfoReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Client) GetClusterPinnipedInfoCallCount() int {
	fake.getClusterPinnipedInfoMutex.RLock()
	defer fake.getClusterPinnipedInfoMutex.RUnlock()
	return len(fake.getClusterPinnipedInfoArgsForCall)
}

func (fake *Client) GetClusterPinnipedInfoCalls(stub func(client.GetClusterPinnipedInfoOptions) (*client.ClusterPinnipedInfo, error)) {
	fake.getClusterPinnipedInfoMutex.Lock()
	defer fake.getClusterPinnipedInfoMutex.Unlock()
	fake.GetClusterPinnipedInfoStub = stub
}

func (fake *Client) GetClusterPinnipedInfoArgsForCall(i int) client.GetClusterPinnipedInfoOptions {
	fake.getClusterPinnipedInfoMutex.RLock()
	defer fake.getClusterPinnipedInfoMutex.RUnlock()
	argsForCall := fake.getClusterPinnipedInfoArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) GetClusterPinnipedInfoReturns(result1 *client.ClusterPinnipedInfo, result2 error) {
	fake.getClusterPinnipedInfoMutex.Lock()
	defer fake.getClusterPinnipedInfoMutex.Unlock()
	fake.GetClusterPinnipedInfoStub = nil
	fake.getClusterPinnipedInfoReturns = struct {
		result1 *client.ClusterPinnipedInfo
		result2 error
	}{result1, result2}
}

func (fake *Client) GetClusterPinnipedInfoReturnsOnCall(i int, result1 *client.ClusterPinnipedInfo, result2 error) {
	fake.getClusterPinnipedInfoMutex.Lock()
	defer fake.getClusterPinnipedInfoMutex.Unlock()
	fake.GetClusterPinnipedInfoStub = nil
	if fake.getClusterPinnipedInfoReturnsOnCall == nil {
		fake.getClusterPinnipedInfoReturnsOnCall = make(map[int]struct {
			result1 *client.ClusterPinnipedInfo
			result2 error
		})
	}
	fake.getClusterPinnipedInfoReturnsOnCall[i] = struct {
		result1 *client.ClusterPinnipedInfo
		result2 error
	}{result1, result2}
}

func (fake *Client) GetCurrentRegionContext() (region.RegionContext, error) {
	fake.getCurrentRegionContextMutex.Lock()
	ret, specificReturn := fake.getCurrentRegionContextReturnsOnCall[len(fake.getCurrentRegionContextArgsForCall)]
	fake.getCurrentRegionContextArgsForCall = append(fake.getCurrentRegionContextArgsForCall, struct {
	}{})
	fake.recordInvocation("GetCurrentRegionContext", []interface{}{})
	fake.getCurrentRegionContextMutex.Unlock()
	if fake.GetCurrentRegionContextStub != nil {
		return fake.GetCurrentRegionContextStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getCurrentRegionContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Client) GetCurrentRegionContextCallCount() int {
	fake.getCurrentRegionContextMutex.RLock()
	defer fake.getCurrentRegionContextMutex.RUnlock()
	return len(fake.getCurrentRegionContextArgsForCall)
}

func (fake *Client) GetCurrentRegionContextCalls(stub func() (region.RegionContext, error)) {
	fake.getCurrentRegionContextMutex.Lock()
	defer fake.getCurrentRegionContextMutex.Unlock()
	fake.GetCurrentRegionContextStub = stub
}

func (fake *Client) GetCurrentRegionContextReturns(result1 region.RegionContext, result2 error) {
	fake.getCurrentRegionContextMutex.Lock()
	defer fake.getCurrentRegionContextMutex.Unlock()
	fake.GetCurrentRegionContextStub = nil
	fake.getCurrentRegionContextReturns = struct {
		result1 region.RegionContext
		result2 error
	}{result1, result2}
}

func (fake *Client) GetCurrentRegionContextReturnsOnCall(i int, result1 region.RegionContext, result2 error) {
	fake.getCurrentRegionContextMutex.Lock()
	defer fake.getCurrentRegionContextMutex.Unlock()
	fake.GetCurrentRegionContextStub = nil
	if fake.getCurrentRegionContextReturnsOnCall == nil {
		fake.getCurrentRegionContextReturnsOnCall = make(map[int]struct {
			result1 region.RegionContext
			result2 error
		})
	}
	fake.getCurrentRegionContextReturnsOnCall[i] = struct {
		result1 region.RegionContext
		result2 error
	}{result1, result2}
}

func (fake *Client) GetKubernetesVersions() (*client.KubernetesVersionsInfo, error) {
	fake.getKubernetesVersionsMutex.Lock()
	ret, specificReturn := fake.getKubernetesVersionsReturnsOnCall[len(fake.getKubernetesVersionsArgsForCall)]
	fake.getKubernetesVersionsArgsForCall = append(fake.getKubernetesVersionsArgsForCall, struct {
	}{})
	fake.recordInvocation("GetKubernetesVersions", []interface{}{})
	fake.getKubernetesVersionsMutex.Unlock()
	if fake.GetKubernetesVersionsStub != nil {
		return fake.GetKubernetesVersionsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getKubernetesVersionsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Client) GetKubernetesVersionsCallCount() int {
	fake.getKubernetesVersionsMutex.RLock()
	defer fake.getKubernetesVersionsMutex.RUnlock()
	return len(fake.getKubernetesVersionsArgsForCall)
}

func (fake *Client) GetKubernetesVersionsCalls(stub func() (*client.KubernetesVersionsInfo, error)) {
	fake.getKubernetesVersionsMutex.Lock()
	defer fake.getKubernetesVersionsMutex.Unlock()
	fake.GetKubernetesVersionsStub = stub
}

func (fake *Client) GetKubernetesVersionsReturns(result1 *client.KubernetesVersionsInfo, result2 error) {
	fake.getKubernetesVersionsMutex.Lock()
	defer fake.getKubernetesVersionsMutex.Unlock()
	fake.GetKubernetesVersionsStub = nil
	fake.getKubernetesVersionsReturns = struct {
		result1 *client.KubernetesVersionsInfo
		result2 error
	}{result1, result2}
}

func (fake *Client) GetKubernetesVersionsReturnsOnCall(i int, result1 *client.KubernetesVersionsInfo, result2 error) {
	fake.getKubernetesVersionsMutex.Lock()
	defer fake.getKubernetesVersionsMutex.Unlock()
	fake.GetKubernetesVersionsStub = nil
	if fake.getKubernetesVersionsReturnsOnCall == nil {
		fake.getKubernetesVersionsReturnsOnCall = make(map[int]struct {
			result1 *client.KubernetesVersionsInfo
			result2 error
		})
	}
	fake.getKubernetesVersionsReturnsOnCall[i] = struct {
		result1 *client.KubernetesVersionsInfo
		result2 error
	}{result1, result2}
}

func (fake *Client) GetMachineHealthChecks(arg1 client.MachineHealthCheckOptions) ([]client.MachineHealthCheck, error) {
	fake.getMachineHealthChecksMutex.Lock()
	ret, specificReturn := fake.getMachineHealthChecksReturnsOnCall[len(fake.getMachineHealthChecksArgsForCall)]
	fake.getMachineHealthChecksArgsForCall = append(fake.getMachineHealthChecksArgsForCall, struct {
		arg1 client.MachineHealthCheckOptions
	}{arg1})
	fake.recordInvocation("GetMachineHealthChecks", []interface{}{arg1})
	fake.getMachineHealthChecksMutex.Unlock()
	if fake.GetMachineHealthChecksStub != nil {
		return fake.GetMachineHealthChecksStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getMachineHealthChecksReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Client) GetMachineHealthChecksCallCount() int {
	fake.getMachineHealthChecksMutex.RLock()
	defer fake.getMachineHealthChecksMutex.RUnlock()
	return len(fake.getMachineHealthChecksArgsForCall)
}

func (fake *Client) GetMachineHealthChecksCalls(stub func(client.MachineHealthCheckOptions) ([]client.MachineHealthCheck, error)) {
	fake.getMachineHealthChecksMutex.Lock()
	defer fake.getMachineHealthChecksMutex.Unlock()
	fake.GetMachineHealthChecksStub = stub
}

func (fake *Client) GetMachineHealthChecksArgsForCall(i int) client.MachineHealthCheckOptions {
	fake.getMachineHealthChecksMutex.RLock()
	defer fake.getMachineHealthChecksMutex.RUnlock()
	argsForCall := fake.getMachineHealthChecksArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) GetMachineHealthChecksReturns(result1 []client.MachineHealthCheck, result2 error) {
	fake.getMachineHealthChecksMutex.Lock()
	defer fake.getMachineHealthChecksMutex.Unlock()
	fake.GetMachineHealthChecksStub = nil
	fake.getMachineHealthChecksReturns = struct {
		result1 []client.MachineHealthCheck
		result2 error
	}{result1, result2}
}

func (fake *Client) GetMachineHealthChecksReturnsOnCall(i int, result1 []client.MachineHealthCheck, result2 error) {
	fake.getMachineHealthChecksMutex.Lock()
	defer fake.getMachineHealthChecksMutex.Unlock()
	fake.GetMachineHealthChecksStub = nil
	if fake.getMachineHealthChecksReturnsOnCall == nil {
		fake.getMachineHealthChecksReturnsOnCall = make(map[int]struct {
			result1 []client.MachineHealthCheck
			result2 error
		})
	}
	fake.getMachineHealthChecksReturnsOnCall[i] = struct {
		result1 []client.MachineHealthCheck
		result2 error
	}{result1, result2}
}

func (fake *Client) GetRegionContexts(arg1 string) ([]region.RegionContext, error) {
	fake.getRegionContextsMutex.Lock()
	ret, specificReturn := fake.getRegionContextsReturnsOnCall[len(fake.getRegionContextsArgsForCall)]
	fake.getRegionContextsArgsForCall = append(fake.getRegionContextsArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("GetRegionContexts", []interface{}{arg1})
	fake.getRegionContextsMutex.Unlock()
	if fake.GetRegionContextsStub != nil {
		return fake.GetRegionContextsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getRegionContextsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Client) GetRegionContextsCallCount() int {
	fake.getRegionContextsMutex.RLock()
	defer fake.getRegionContextsMutex.RUnlock()
	return len(fake.getRegionContextsArgsForCall)
}

func (fake *Client) GetRegionContextsCalls(stub func(string) ([]region.RegionContext, error)) {
	fake.getRegionContextsMutex.Lock()
	defer fake.getRegionContextsMutex.Unlock()
	fake.GetRegionContextsStub = stub
}

func (fake *Client) GetRegionContextsArgsForCall(i int) string {
	fake.getRegionContextsMutex.RLock()
	defer fake.getRegionContextsMutex.RUnlock()
	argsForCall := fake.getRegionContextsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) GetRegionContextsReturns(result1 []region.RegionContext, result2 error) {
	fake.getRegionContextsMutex.Lock()
	defer fake.getRegionContextsMutex.Unlock()
	fake.GetRegionContextsStub = nil
	fake.getRegionContextsReturns = struct {
		result1 []region.RegionContext
		result2 error
	}{result1, result2}
}

func (fake *Client) GetRegionContextsReturnsOnCall(i int, result1 []region.RegionContext, result2 error) {
	fake.getRegionContextsMutex.Lock()
	defer fake.getRegionContextsMutex.Unlock()
	fake.GetRegionContextsStub = nil
	if fake.getRegionContextsReturnsOnCall == nil {
		fake.getRegionContextsReturnsOnCall = make(map[int]struct {
			result1 []region.RegionContext
			result2 error
		})
	}
	fake.getRegionContextsReturnsOnCall[i] = struct {
		result1 []region.RegionContext
		result2 error
	}{result1, result2}
}

func (fake *Client) GetTanzuKubernetesReleases(arg1 string) ([]v1alpha1.TanzuKubernetesRelease, error) {
	fake.getTanzuKubernetesReleasesMutex.Lock()
	ret, specificReturn := fake.getTanzuKubernetesReleasesReturnsOnCall[len(fake.getTanzuKubernetesReleasesArgsForCall)]
	fake.getTanzuKubernetesReleasesArgsForCall = append(fake.getTanzuKubernetesReleasesArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("GetTanzuKubernetesReleases", []interface{}{arg1})
	fake.getTanzuKubernetesReleasesMutex.Unlock()
	if fake.GetTanzuKubernetesReleasesStub != nil {
		return fake.GetTanzuKubernetesReleasesStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getTanzuKubernetesReleasesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Client) GetTanzuKubernetesReleasesCallCount() int {
	fake.getTanzuKubernetesReleasesMutex.RLock()
	defer fake.getTanzuKubernetesReleasesMutex.RUnlock()
	return len(fake.getTanzuKubernetesReleasesArgsForCall)
}

func (fake *Client) GetTanzuKubernetesReleasesCalls(stub func(string) ([]v1alpha1.TanzuKubernetesRelease, error)) {
	fake.getTanzuKubernetesReleasesMutex.Lock()
	defer fake.getTanzuKubernetesReleasesMutex.Unlock()
	fake.GetTanzuKubernetesReleasesStub = stub
}

func (fake *Client) GetTanzuKubernetesReleasesArgsForCall(i int) string {
	fake.getTanzuKubernetesReleasesMutex.RLock()
	defer fake.getTanzuKubernetesReleasesMutex.RUnlock()
	argsForCall := fake.getTanzuKubernetesReleasesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) GetTanzuKubernetesReleasesReturns(result1 []v1alpha1.TanzuKubernetesRelease, result2 error) {
	fake.getTanzuKubernetesReleasesMutex.Lock()
	defer fake.getTanzuKubernetesReleasesMutex.Unlock()
	fake.GetTanzuKubernetesReleasesStub = nil
	fake.getTanzuKubernetesReleasesReturns = struct {
		result1 []v1alpha1.TanzuKubernetesRelease
		result2 error
	}{result1, result2}
}

func (fake *Client) GetTanzuKubernetesReleasesReturnsOnCall(i int, result1 []v1alpha1.TanzuKubernetesRelease, result2 error) {
	fake.getTanzuKubernetesReleasesMutex.Lock()
	defer fake.getTanzuKubernetesReleasesMutex.Unlock()
	fake.GetTanzuKubernetesReleasesStub = nil
	if fake.getTanzuKubernetesReleasesReturnsOnCall == nil {
		fake.getTanzuKubernetesReleasesReturnsOnCall = make(map[int]struct {
			result1 []v1alpha1.TanzuKubernetesRelease
			result2 error
		})
	}
	fake.getTanzuKubernetesReleasesReturnsOnCall[i] = struct {
		result1 []v1alpha1.TanzuKubernetesRelease
		result2 error
	}{result1, result2}
}

func (fake *Client) GetVSphereEndpoint(arg1 clusterclient.Client) (vc.Client, error) {
	fake.getVSphereEndpointMutex.Lock()
	ret, specificReturn := fake.getVSphereEndpointReturnsOnCall[len(fake.getVSphereEndpointArgsForCall)]
	fake.getVSphereEndpointArgsForCall = append(fake.getVSphereEndpointArgsForCall, struct {
		arg1 clusterclient.Client
	}{arg1})
	fake.recordInvocation("GetVSphereEndpoint", []interface{}{arg1})
	fake.getVSphereEndpointMutex.Unlock()
	if fake.GetVSphereEndpointStub != nil {
		return fake.GetVSphereEndpointStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getVSphereEndpointReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Client) GetVSphereEndpointCallCount() int {
	fake.getVSphereEndpointMutex.RLock()
	defer fake.getVSphereEndpointMutex.RUnlock()
	return len(fake.getVSphereEndpointArgsForCall)
}

func (fake *Client) GetVSphereEndpointCalls(stub func(clusterclient.Client) (vc.Client, error)) {
	fake.getVSphereEndpointMutex.Lock()
	defer fake.getVSphereEndpointMutex.Unlock()
	fake.GetVSphereEndpointStub = stub
}

func (fake *Client) GetVSphereEndpointArgsForCall(i int) clusterclient.Client {
	fake.getVSphereEndpointMutex.RLock()
	defer fake.getVSphereEndpointMutex.RUnlock()
	argsForCall := fake.getVSphereEndpointArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) GetVSphereEndpointReturns(result1 vc.Client, result2 error) {
	fake.getVSphereEndpointMutex.Lock()
	defer fake.getVSphereEndpointMutex.Unlock()
	fake.GetVSphereEndpointStub = nil
	fake.getVSphereEndpointReturns = struct {
		result1 vc.Client
		result2 error
	}{result1, result2}
}

func (fake *Client) GetVSphereEndpointReturnsOnCall(i int, result1 vc.Client, result2 error) {
	fake.getVSphereEndpointMutex.Lock()
	defer fake.getVSphereEndpointMutex.Unlock()
	fake.GetVSphereEndpointStub = nil
	if fake.getVSphereEndpointReturnsOnCall == nil {
		fake.getVSphereEndpointReturnsOnCall = make(map[int]struct {
			result1 vc.Client
			result2 error
		})
	}
	fake.getVSphereEndpointReturnsOnCall[i] = struct {
		result1 vc.Client
		result2 error
	}{result1, result2}
}

func (fake *Client) GetWorkloadClusterCredentials(arg1 client.GetWorkloadClusterCredentialsOptions) (string, string, error) {
	fake.getWorkloadClusterCredentialsMutex.Lock()
	ret, specificReturn := fake.getWorkloadClusterCredentialsReturnsOnCall[len(fake.getWorkloadClusterCredentialsArgsForCall)]
	fake.getWorkloadClusterCredentialsArgsForCall = append(fake.getWorkloadClusterCredentialsArgsForCall, struct {
		arg1 client.GetWorkloadClusterCredentialsOptions
	}{arg1})
	fake.recordInvocation("GetWorkloadClusterCredentials", []interface{}{arg1})
	fake.getWorkloadClusterCredentialsMutex.Unlock()
	if fake.GetWorkloadClusterCredentialsStub != nil {
		return fake.GetWorkloadClusterCredentialsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.getWorkloadClusterCredentialsReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *Client) GetWorkloadClusterCredentialsCallCount() int {
	fake.getWorkloadClusterCredentialsMutex.RLock()
	defer fake.getWorkloadClusterCredentialsMutex.RUnlock()
	return len(fake.getWorkloadClusterCredentialsArgsForCall)
}

func (fake *Client) GetWorkloadClusterCredentialsCalls(stub func(client.GetWorkloadClusterCredentialsOptions) (string, string, error)) {
	fake.getWorkloadClusterCredentialsMutex.Lock()
	defer fake.getWorkloadClusterCredentialsMutex.Unlock()
	fake.GetWorkloadClusterCredentialsStub = stub
}

func (fake *Client) GetWorkloadClusterCredentialsArgsForCall(i int) client.GetWorkloadClusterCredentialsOptions {
	fake.getWorkloadClusterCredentialsMutex.RLock()
	defer fake.getWorkloadClusterCredentialsMutex.RUnlock()
	argsForCall := fake.getWorkloadClusterCredentialsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) GetWorkloadClusterCredentialsReturns(result1 string, result2 string, result3 error) {
	fake.getWorkloadClusterCredentialsMutex.Lock()
	defer fake.getWorkloadClusterCredentialsMutex.Unlock()
	fake.GetWorkloadClusterCredentialsStub = nil
	fake.getWorkloadClusterCredentialsReturns = struct {
		result1 string
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *Client) GetWorkloadClusterCredentialsReturnsOnCall(i int, result1 string, result2 string, result3 error) {
	fake.getWorkloadClusterCredentialsMutex.Lock()
	defer fake.getWorkloadClusterCredentialsMutex.Unlock()
	fake.GetWorkloadClusterCredentialsStub = nil
	if fake.getWorkloadClusterCredentialsReturnsOnCall == nil {
		fake.getWorkloadClusterCredentialsReturnsOnCall = make(map[int]struct {
			result1 string
			result2 string
			result3 error
		})
	}
	fake.getWorkloadClusterCredentialsReturnsOnCall[i] = struct {
		result1 string
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *Client) InitRegion(arg1 *client.InitRegionOptions) error {
	fake.initRegionMutex.Lock()
	ret, specificReturn := fake.initRegionReturnsOnCall[len(fake.initRegionArgsForCall)]
	fake.initRegionArgsForCall = append(fake.initRegionArgsForCall, struct {
		arg1 *client.InitRegionOptions
	}{arg1})
	fake.recordInvocation("InitRegion", []interface{}{arg1})
	fake.initRegionMutex.Unlock()
	if fake.InitRegionStub != nil {
		return fake.InitRegionStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.initRegionReturns
	return fakeReturns.result1
}

func (fake *Client) InitRegionCallCount() int {
	fake.initRegionMutex.RLock()
	defer fake.initRegionMutex.RUnlock()
	return len(fake.initRegionArgsForCall)
}

func (fake *Client) InitRegionCalls(stub func(*client.InitRegionOptions) error) {
	fake.initRegionMutex.Lock()
	defer fake.initRegionMutex.Unlock()
	fake.InitRegionStub = stub
}

func (fake *Client) InitRegionArgsForCall(i int) *client.InitRegionOptions {
	fake.initRegionMutex.RLock()
	defer fake.initRegionMutex.RUnlock()
	argsForCall := fake.initRegionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) InitRegionReturns(result1 error) {
	fake.initRegionMutex.Lock()
	defer fake.initRegionMutex.Unlock()
	fake.InitRegionStub = nil
	fake.initRegionReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) InitRegionReturnsOnCall(i int, result1 error) {
	fake.initRegionMutex.Lock()
	defer fake.initRegionMutex.Unlock()
	fake.InitRegionStub = nil
	if fake.initRegionReturnsOnCall == nil {
		fake.initRegionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.initRegionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Client) InitRegionDryRun(arg1 *client.InitRegionOptions) ([]byte, error) {
	fake.initRegionDryRunMutex.Lock()
	ret, specificReturn := fake.initRegionDryRunReturnsOnCall[len(fake.initRegionDryRunArgsForCall)]
	fake.initRegionDryRunArgsForCall = append(fake.initRegionDryRunArgsForCall, struct {
		arg1 *client.InitRegionOptions
	}{arg1})
	fake.recordInvocation("InitRegionDryRun", []interface{}{arg1})
	fake.initRegionDryRunMutex.Unlock()
	if fake.InitRegionDryRunStub != nil {
		return fake.InitRegionDryRunStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.initRegionDryRunReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Client) InitRegionDryRunCallCount() int {
	fake.initRegionDryRunMutex.RLock()
	defer fake.initRegionDryRunMutex.RUnlock()
	return len(fake.initRegionDryRunArgsForCall)
}

func (fake *Client) InitRegionDryRunCalls(stub func(*client.InitRegionOptions) ([]byte, error)) {
	fake.initRegionDryRunMutex.Lock()
	defer fake.initRegionDryRunMutex.Unlock()
	fake.InitRegionDryRunStub = stub
}

func (fake *Client) InitRegionDryRunArgsForCall(i int) *client.InitRegionOptions {
	fake.initRegionDryRunMutex.RLock()
	defer fake.initRegionDryRunMutex.RUnlock()
	argsForCall := fake.initRegionDryRunArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) InitRegionDryRunReturns(result1 []byte, result2 error) {
	fake.initRegionDryRunMutex.Lock()
	defer fake.initRegionDryRunMutex.Unlock()
	fake.InitRegionDryRunStub = nil
	fake.initRegionDryRunReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *Client) InitRegionDryRunReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.initRegionDryRunMutex.Lock()
	defer fake.initRegionDryRunMutex.Unlock()
	fake.InitRegionDryRunStub = nil
	if fake.initRegionDryRunReturnsOnCall == nil {
		fake.initRegionDryRunReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.initRegionDryRunReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *Client) IsManagementClusterAKindCluster(arg1 string) (bool, error) {
	fake.isManagementClusterAKindClusterMutex.Lock()
	ret, specificReturn := fake.isManagementClusterAKindClusterReturnsOnCall[len(fake.isManagementClusterAKindClusterArgsForCall)]
	fake.isManagementClusterAKindClusterArgsForCall = append(fake.isManagementClusterAKindClusterArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("IsManagementClusterAKindCluster", []interface{}{arg1})
	fake.isManagementClusterAKindClusterMutex.Unlock()
	if fake.IsManagementClusterAKindClusterStub != nil {
		return fake.IsManagementClusterAKindClusterStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.isManagementClusterAKindClusterReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Client) IsManagementClusterAKindClusterCallCount() int {
	fake.isManagementClusterAKindClusterMutex.RLock()
	defer fake.isManagementClusterAKindClusterMutex.RUnlock()
	return len(fake.isManagementClusterAKindClusterArgsForCall)
}

func (fake *Client) IsManagementClusterAKindClusterCalls(stub func(string) (bool, error)) {
	fake.isManagementClusterAKindClusterMutex.Lock()
	defer fake.isManagementClusterAKindClusterMutex.Unlock()
	fake.IsManagementClusterAKindClusterStub = stub
}

func (fake *Client) IsManagementClusterAKindClusterArgsForCall(i int) string {
	fake.isManagementClusterAKindClusterMutex.RLock()
	defer fake.isManagementClusterAKindClusterMutex.RUnlock()
	argsForCall := fake.isManagementClusterAKindClusterArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) IsManagementClusterAKindClusterReturns(result1 bool, result2 error) {
	fake.isManagementClusterAKindClusterMutex.Lock()
	defer fake.isManagementClusterAKindClusterMutex.Unlock()
	fake.IsManagementClusterAKindClusterStub = nil
	fake.isManagementClusterAKindClusterReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *Client) IsManagementClusterAKindClusterReturnsOnCall(i int, result1 bool, result2 error) {
	fake.isManagementClusterAKindClusterMutex.Lock()
	defer fake.isManagementClusterAKindClusterMutex.Unlock()
	fake.IsManagementClusterAKindClusterStub = nil
	if fake.isManagementClusterAKindClusterReturnsOnCall == nil {
		fake.isManagementClusterAKindClusterReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.isManagementClusterAKindClusterReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *Client) IsPacificManagementCluster() (bool, error) {
	fake.isPacificManagementClusterMutex.Lock()
	ret, specificReturn := fake.isPacificManagementClusterReturnsOnCall[len(fake.isPacificManagementClusterArgsForCall)]
	fake.isPacificManagementClusterArgsForCall = append(fake.isPacificManagementClusterArgsForCall, struct {
	}{})
	fake.recordInvocation("IsPacificManagementCluster", []interface{}{})
	fake.isPacificManagementClusterMutex.Unlock()
	if fake.IsPacificManagementClusterStub != nil {
		return fake.IsPacificManagementClusterStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.isPacificManagementClusterReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Client) IsPacificManagementClusterCallCount() int {
	fake.isPacificManagementClusterMutex.RLock()
	defer fake.isPacificManagementClusterMutex.RUnlock()
	return len(fake.isPacificManagementClusterArgsForCall)
}

func (fake *Client) IsPacificManagementClusterCalls(stub func() (bool, error)) {
	fake.isPacificManagementClusterMutex.Lock()
	defer fake.isPacificManagementClusterMutex.Unlock()
	fake.IsPacificManagementClusterStub = stub
}

func (fake *Client) IsPacificManagementClusterReturns(result1 bool, result2 error) {
	fake.isPacificManagementClusterMutex.Lock()
	defer fake.isPacificManagementClusterMutex.Unlock()
	fake.IsPacificManagementClusterStub = nil
	fake.isPacificManagementClusterReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *Client) IsPacificManagementClusterReturnsOnCall(i int, result1 bool, result2 error) {
	fake.isPacificManagementClusterMutex.Lock()
	defer fake.isPacificManagementClusterMutex.Unlock()
	fake.IsPacificManagementClusterStub = nil
	if fake.isPacificManagementClusterReturnsOnCall == nil {
		fake.isPacificManagementClusterReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.isPacificManagementClusterReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *Client) ListTKGClusters(arg1 client.ListTKGClustersOptions) ([]client.ClusterInfo, error) {
	fake.listTKGClustersMutex.Lock()
	ret, specificReturn := fake.listTKGClustersReturnsOnCall[len(fake.listTKGClustersArgsForCall)]
	fake.listTKGClustersArgsForCall = append(fake.listTKGClustersArgsForCall, struct {
		arg1 client.ListTKGClustersOptions
	}{arg1})
	fake.recordInvocation("ListTKGClusters", []interface{}{arg1})
	fake.listTKGClustersMutex.Unlock()
	if fake.ListTKGClustersStub != nil {
		return fake.ListTKGClustersStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listTKGClustersReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Client) ListTKGClustersCallCount() int {
	fake.listTKGClustersMutex.RLock()
	defer fake.listTKGClustersMutex.RUnlock()
	return len(fake.listTKGClustersArgsForCall)
}

func (fake *Client) ListTKGClustersCalls(stub func(client.ListTKGClustersOptions) ([]client.ClusterInfo, error)) {
	fake.listTKGClustersMutex.Lock()
	defer fake.listTKGClustersMutex.Unlock()
	fake.ListTKGClustersStub = stub
}

func (fake *Client) ListTKGClustersArgsForCall(i int) client.ListTKGClustersOptions {
	fake.listTKGClustersMutex.RLock()
	defer fake.listTKGClustersMutex.RUnlock()
	argsForCall := fake.listTKGClustersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) ListTKGClustersReturns(result1 []client.ClusterInfo, result2 error) {
	fake.listTKGClustersMutex.Lock()
	defer fake.listTKGClustersMutex.Unlock()
	fake.ListTKGClustersStub = nil
	fake.listTKGClustersReturns = struct {
		result1 []client.ClusterInfo
		result2 error
	}{result1, result2}
}

func (fake *Client) ListTKGClustersReturnsOnCall(i int, result1 []client.ClusterInfo, result2 error) {
	fake.listTKGClustersMutex.Lock()
	defer fake.listTKGClustersMutex.Unlock()
	fake.ListTKGClustersStub = nil
	if fake.listTKGClustersReturnsOnCall == nil {
		fake.listTKGClustersReturnsOnCall = make(map[int]struct {
			result1 []client.ClusterInfo
			result2 error
		})
	}
	fake.listTKGClustersReturnsOnCall[i] = struct {
		result1 []client.ClusterInfo
		result2 error
	}{result1, result2}
}

func (fake *Client) ParseHiddenArgsAsFeatureFlags(arg1 *client.InitRegionOptions) {
	fake.parseHiddenArgsAsFeatureFlagsMutex.Lock()
	fake.parseHiddenArgsAsFeatureFlagsArgsForCall = append(fake.parseHiddenArgsAsFeatureFlagsArgsForCall, struct {
		arg1 *client.InitRegionOptions
	}{arg1})
	fake.recordInvocation("ParseHiddenArgsAsFeatureFlags", []interface{}{arg1})
	fake.parseHiddenArgsAsFeatureFlagsMutex.Unlock()
	if fake.ParseHiddenArgsAsFeatureFlagsStub != nil {
		fake.ParseHiddenArgsAsFeatureFlagsStub(arg1)
	}
}

func (fake *Client) ParseHiddenArgsAsFeatureFlagsCallCount() int {
	fake.parseHiddenArgsAsFeatureFlagsMutex.RLock()
	defer fake.parseHiddenArgsAsFeatureFlagsMutex.RUnlock()
	return len(fake.parseHiddenArgsAsFeatureFlagsArgsForCall)
}

func (fake *Client) ParseHiddenArgsAsFeatureFlagsCalls(stub func(*client.InitRegionOptions)) {
	fake.parseHiddenArgsAsFeatureFlagsMutex.Lock()
	defer fake.parseHiddenArgsAsFeatureFlagsMutex.Unlock()
	fake.ParseHiddenArgsAsFeatureFlagsStub = stub
}

func (fake *Client) ParseHiddenArgsAsFeatureFlagsArgsForCall(i int) *client.InitRegionOptions {
	fake.parseHiddenArgsAsFeatureFlagsMutex.RLock()
	defer fake.parseHiddenArgsAsFeatureFlagsMutex.RUnlock()
	argsForCall := fake.parseHiddenArgsAsFeatureFlagsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) RegisterManagementClusterToTmc(arg1 string, arg2 string) error {
	fake.registerManagementClusterToTmcMutex.Lock()
	ret, specificReturn := fake.registerManagementClusterToTmcReturnsOnCall[len(fake.registerManagementClusterToTmcArgsForCall)]
	fake.registerManagementClusterToTmcArgsForCall = append(fake.registerManagementClusterToTmcArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("RegisterManagementClusterToTmc", []interface{}{arg1, arg2})
	fake.registerManagementClusterToTmcMutex.Unlock()
	if fake.RegisterManagementClusterToTmcStub != nil {
		return fake.RegisterManagementClusterToTmcStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.registerManagementClusterToTmcReturns
	return fakeReturns.result1
}

func (fake *Client) RegisterManagementClusterToTmcCallCount() int {
	fake.registerManagementClusterToTmcMutex.RLock()
	defer fake.registerManagementClusterToTmcMutex.RUnlock()
	return len(fake.registerManagementClusterToTmcArgsForCall)
}

func (fake *Client) RegisterManagementClusterToTmcCalls(stub func(string, string) error) {
	fake.registerManagementClusterToTmcMutex.Lock()
	defer fake.registerManagementClusterToTmcMutex.Unlock()
	fake.RegisterManagementClusterToTmcStub = stub
}

func (fake *Client) RegisterManagementClusterToTmcArgsForCall(i int) (string, string) {
	fake.registerManagementClusterToTmcMutex.RLock()
	defer fake.registerManagementClusterToTmcMutex.RUnlock()
	argsForCall := fake.registerManagementClusterToTmcArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Client) RegisterManagementClusterToTmcReturns(result1 error) {
	fake.registerManagementClusterToTmcMutex.Lock()
	defer fake.registerManagementClusterToTmcMutex.Unlock()
	fake.RegisterManagementClusterToTmcStub = nil
	fake.registerManagementClusterToTmcReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) RegisterManagementClusterToTmcReturnsOnCall(i int, result1 error) {
	fake.registerManagementClusterToTmcMutex.Lock()
	defer fake.registerManagementClusterToTmcMutex.Unlock()
	fake.RegisterManagementClusterToTmcStub = nil
	if fake.registerManagementClusterToTmcReturnsOnCall == nil {
		fake.registerManagementClusterToTmcReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.registerManagementClusterToTmcReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Client) SaveFeatureFlags(arg1 map[string]string) error {
	fake.saveFeatureFlagsMutex.Lock()
	ret, specificReturn := fake.saveFeatureFlagsReturnsOnCall[len(fake.saveFeatureFlagsArgsForCall)]
	fake.saveFeatureFlagsArgsForCall = append(fake.saveFeatureFlagsArgsForCall, struct {
		arg1 map[string]string
	}{arg1})
	fake.recordInvocation("SaveFeatureFlags", []interface{}{arg1})
	fake.saveFeatureFlagsMutex.Unlock()
	if fake.SaveFeatureFlagsStub != nil {
		return fake.SaveFeatureFlagsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.saveFeatureFlagsReturns
	return fakeReturns.result1
}

func (fake *Client) SaveFeatureFlagsCallCount() int {
	fake.saveFeatureFlagsMutex.RLock()
	defer fake.saveFeatureFlagsMutex.RUnlock()
	return len(fake.saveFeatureFlagsArgsForCall)
}

func (fake *Client) SaveFeatureFlagsCalls(stub func(map[string]string) error) {
	fake.saveFeatureFlagsMutex.Lock()
	defer fake.saveFeatureFlagsMutex.Unlock()
	fake.SaveFeatureFlagsStub = stub
}

func (fake *Client) SaveFeatureFlagsArgsForCall(i int) map[string]string {
	fake.saveFeatureFlagsMutex.RLock()
	defer fake.saveFeatureFlagsMutex.RUnlock()
	argsForCall := fake.saveFeatureFlagsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) SaveFeatureFlagsReturns(result1 error) {
	fake.saveFeatureFlagsMutex.Lock()
	defer fake.saveFeatureFlagsMutex.Unlock()
	fake.SaveFeatureFlagsStub = nil
	fake.saveFeatureFlagsReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) SaveFeatureFlagsReturnsOnCall(i int, result1 error) {
	fake.saveFeatureFlagsMutex.Lock()
	defer fake.saveFeatureFlagsMutex.Unlock()
	fake.SaveFeatureFlagsStub = nil
	if fake.saveFeatureFlagsReturnsOnCall == nil {
		fake.saveFeatureFlagsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveFeatureFlagsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Client) ScaleCluster(arg1 client.ScaleClusterOptions) error {
	fake.scaleClusterMutex.Lock()
	ret, specificReturn := fake.scaleClusterReturnsOnCall[len(fake.scaleClusterArgsForCall)]
	fake.scaleClusterArgsForCall = append(fake.scaleClusterArgsForCall, struct {
		arg1 client.ScaleClusterOptions
	}{arg1})
	fake.recordInvocation("ScaleCluster", []interface{}{arg1})
	fake.scaleClusterMutex.Unlock()
	if fake.ScaleClusterStub != nil {
		return fake.ScaleClusterStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.scaleClusterReturns
	return fakeReturns.result1
}

func (fake *Client) ScaleClusterCallCount() int {
	fake.scaleClusterMutex.RLock()
	defer fake.scaleClusterMutex.RUnlock()
	return len(fake.scaleClusterArgsForCall)
}

func (fake *Client) ScaleClusterCalls(stub func(client.ScaleClusterOptions) error) {
	fake.scaleClusterMutex.Lock()
	defer fake.scaleClusterMutex.Unlock()
	fake.ScaleClusterStub = stub
}

func (fake *Client) ScaleClusterArgsForCall(i int) client.ScaleClusterOptions {
	fake.scaleClusterMutex.RLock()
	defer fake.scaleClusterMutex.RUnlock()
	argsForCall := fake.scaleClusterArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) ScaleClusterReturns(result1 error) {
	fake.scaleClusterMutex.Lock()
	defer fake.scaleClusterMutex.Unlock()
	fake.ScaleClusterStub = nil
	fake.scaleClusterReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) ScaleClusterReturnsOnCall(i int, result1 error) {
	fake.scaleClusterMutex.Lock()
	defer fake.scaleClusterMutex.Unlock()
	fake.ScaleClusterStub = nil
	if fake.scaleClusterReturnsOnCall == nil {
		fake.scaleClusterReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.scaleClusterReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Client) SetCEIPParticipation(arg1 bool, arg2 string, arg3 string) error {
	fake.setCEIPParticipationMutex.Lock()
	ret, specificReturn := fake.setCEIPParticipationReturnsOnCall[len(fake.setCEIPParticipationArgsForCall)]
	fake.setCEIPParticipationArgsForCall = append(fake.setCEIPParticipationArgsForCall, struct {
		arg1 bool
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("SetCEIPParticipation", []interface{}{arg1, arg2, arg3})
	fake.setCEIPParticipationMutex.Unlock()
	if fake.SetCEIPParticipationStub != nil {
		return fake.SetCEIPParticipationStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.setCEIPParticipationReturns
	return fakeReturns.result1
}

func (fake *Client) SetCEIPParticipationCallCount() int {
	fake.setCEIPParticipationMutex.RLock()
	defer fake.setCEIPParticipationMutex.RUnlock()
	return len(fake.setCEIPParticipationArgsForCall)
}

func (fake *Client) SetCEIPParticipationCalls(stub func(bool, string, string) error) {
	fake.setCEIPParticipationMutex.Lock()
	defer fake.setCEIPParticipationMutex.Unlock()
	fake.SetCEIPParticipationStub = stub
}

func (fake *Client) SetCEIPParticipationArgsForCall(i int) (bool, string, string) {
	fake.setCEIPParticipationMutex.RLock()
	defer fake.setCEIPParticipationMutex.RUnlock()
	argsForCall := fake.setCEIPParticipationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Client) SetCEIPParticipationReturns(result1 error) {
	fake.setCEIPParticipationMutex.Lock()
	defer fake.setCEIPParticipationMutex.Unlock()
	fake.SetCEIPParticipationStub = nil
	fake.setCEIPParticipationReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) SetCEIPParticipationReturnsOnCall(i int, result1 error) {
	fake.setCEIPParticipationMutex.Lock()
	defer fake.setCEIPParticipationMutex.Unlock()
	fake.SetCEIPParticipationStub = nil
	if fake.setCEIPParticipationReturnsOnCall == nil {
		fake.setCEIPParticipationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setCEIPParticipationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Client) SetMachineHealthCheck(arg1 *client.SetMachineHealthCheckOptions) error {
	fake.setMachineHealthCheckMutex.Lock()
	ret, specificReturn := fake.setMachineHealthCheckReturnsOnCall[len(fake.setMachineHealthCheckArgsForCall)]
	fake.setMachineHealthCheckArgsForCall = append(fake.setMachineHealthCheckArgsForCall, struct {
		arg1 *client.SetMachineHealthCheckOptions
	}{arg1})
	fake.recordInvocation("SetMachineHealthCheck", []interface{}{arg1})
	fake.setMachineHealthCheckMutex.Unlock()
	if fake.SetMachineHealthCheckStub != nil {
		return fake.SetMachineHealthCheckStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.setMachineHealthCheckReturns
	return fakeReturns.result1
}

func (fake *Client) SetMachineHealthCheckCallCount() int {
	fake.setMachineHealthCheckMutex.RLock()
	defer fake.setMachineHealthCheckMutex.RUnlock()
	return len(fake.setMachineHealthCheckArgsForCall)
}

func (fake *Client) SetMachineHealthCheckCalls(stub func(*client.SetMachineHealthCheckOptions) error) {
	fake.setMachineHealthCheckMutex.Lock()
	defer fake.setMachineHealthCheckMutex.Unlock()
	fake.SetMachineHealthCheckStub = stub
}

func (fake *Client) SetMachineHealthCheckArgsForCall(i int) *client.SetMachineHealthCheckOptions {
	fake.setMachineHealthCheckMutex.RLock()
	defer fake.setMachineHealthCheckMutex.RUnlock()
	argsForCall := fake.setMachineHealthCheckArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) SetMachineHealthCheckReturns(result1 error) {
	fake.setMachineHealthCheckMutex.Lock()
	defer fake.setMachineHealthCheckMutex.Unlock()
	fake.SetMachineHealthCheckStub = nil
	fake.setMachineHealthCheckReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) SetMachineHealthCheckReturnsOnCall(i int, result1 error) {
	fake.setMachineHealthCheckMutex.Lock()
	defer fake.setMachineHealthCheckMutex.Unlock()
	fake.SetMachineHealthCheckStub = nil
	if fake.setMachineHealthCheckReturnsOnCall == nil {
		fake.setMachineHealthCheckReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setMachineHealthCheckReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Client) SetRegionContext(arg1 string, arg2 string) error {
	fake.setRegionContextMutex.Lock()
	ret, specificReturn := fake.setRegionContextReturnsOnCall[len(fake.setRegionContextArgsForCall)]
	fake.setRegionContextArgsForCall = append(fake.setRegionContextArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("SetRegionContext", []interface{}{arg1, arg2})
	fake.setRegionContextMutex.Unlock()
	if fake.SetRegionContextStub != nil {
		return fake.SetRegionContextStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.setRegionContextReturns
	return fakeReturns.result1
}

func (fake *Client) SetRegionContextCallCount() int {
	fake.setRegionContextMutex.RLock()
	defer fake.setRegionContextMutex.RUnlock()
	return len(fake.setRegionContextArgsForCall)
}

func (fake *Client) SetRegionContextCalls(stub func(string, string) error) {
	fake.setRegionContextMutex.Lock()
	defer fake.setRegionContextMutex.Unlock()
	fake.SetRegionContextStub = stub
}

func (fake *Client) SetRegionContextArgsForCall(i int) (string, string) {
	fake.setRegionContextMutex.RLock()
	defer fake.setRegionContextMutex.RUnlock()
	argsForCall := fake.setRegionContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Client) SetRegionContextReturns(result1 error) {
	fake.setRegionContextMutex.Lock()
	defer fake.setRegionContextMutex.Unlock()
	fake.SetRegionContextStub = nil
	fake.setRegionContextReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) SetRegionContextReturnsOnCall(i int, result1 error) {
	fake.setRegionContextMutex.Lock()
	defer fake.setRegionContextMutex.Unlock()
	fake.SetRegionContextStub = nil
	if fake.setRegionContextReturnsOnCall == nil {
		fake.setRegionContextReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setRegionContextReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Client) TKGConfigReaderWriter() tkgconfigreaderwriter.TKGConfigReaderWriter {
	fake.tKGConfigReaderWriterMutex.Lock()
	ret, specificReturn := fake.tKGConfigReaderWriterReturnsOnCall[len(fake.tKGConfigReaderWriterArgsForCall)]
	fake.tKGConfigReaderWriterArgsForCall = append(fake.tKGConfigReaderWriterArgsForCall, struct {
	}{})
	fake.recordInvocation("TKGConfigReaderWriter", []interface{}{})
	fake.tKGConfigReaderWriterMutex.Unlock()
	if fake.TKGConfigReaderWriterStub != nil {
		return fake.TKGConfigReaderWriterStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.tKGConfigReaderWriterReturns
	return fakeReturns.result1
}

func (fake *Client) TKGConfigReaderWriterCallCount() int {
	fake.tKGConfigReaderWriterMutex.RLock()
	defer fake.tKGConfigReaderWriterMutex.RUnlock()
	return len(fake.tKGConfigReaderWriterArgsForCall)
}

func (fake *Client) TKGConfigReaderWriterCalls(stub func() tkgconfigreaderwriter.TKGConfigReaderWriter) {
	fake.tKGConfigReaderWriterMutex.Lock()
	defer fake.tKGConfigReaderWriterMutex.Unlock()
	fake.TKGConfigReaderWriterStub = stub
}

func (fake *Client) TKGConfigReaderWriterReturns(result1 tkgconfigreaderwriter.TKGConfigReaderWriter) {
	fake.tKGConfigReaderWriterMutex.Lock()
	defer fake.tKGConfigReaderWriterMutex.Unlock()
	fake.TKGConfigReaderWriterStub = nil
	fake.tKGConfigReaderWriterReturns = struct {
		result1 tkgconfigreaderwriter.TKGConfigReaderWriter
	}{result1}
}

func (fake *Client) TKGConfigReaderWriterReturnsOnCall(i int, result1 tkgconfigreaderwriter.TKGConfigReaderWriter) {
	fake.tKGConfigReaderWriterMutex.Lock()
	defer fake.tKGConfigReaderWriterMutex.Unlock()
	fake.TKGConfigReaderWriterStub = nil
	if fake.tKGConfigReaderWriterReturnsOnCall == nil {
		fake.tKGConfigReaderWriterReturnsOnCall = make(map[int]struct {
			result1 tkgconfigreaderwriter.TKGConfigReaderWriter
		})
	}
	fake.tKGConfigReaderWriterReturnsOnCall[i] = struct {
		result1 tkgconfigreaderwriter.TKGConfigReaderWriter
	}{result1}
}

func (fake *Client) UpdateCredentialsCluster(arg1 *client.UpdateCredentialsOptions) error {
	fake.updateCredentialsClusterMutex.Lock()
	ret, specificReturn := fake.updateCredentialsClusterReturnsOnCall[len(fake.updateCredentialsClusterArgsForCall)]
	fake.updateCredentialsClusterArgsForCall = append(fake.updateCredentialsClusterArgsForCall, struct {
		arg1 *client.UpdateCredentialsOptions
	}{arg1})
	fake.recordInvocation("UpdateCredentialsCluster", []interface{}{arg1})
	fake.updateCredentialsClusterMutex.Unlock()
	if fake.UpdateCredentialsClusterStub != nil {
		return fake.UpdateCredentialsClusterStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.updateCredentialsClusterReturns
	return fakeReturns.result1
}

func (fake *Client) UpdateCredentialsClusterCallCount() int {
	fake.updateCredentialsClusterMutex.RLock()
	defer fake.updateCredentialsClusterMutex.RUnlock()
	return len(fake.updateCredentialsClusterArgsForCall)
}

func (fake *Client) UpdateCredentialsClusterCalls(stub func(*client.UpdateCredentialsOptions) error) {
	fake.updateCredentialsClusterMutex.Lock()
	defer fake.updateCredentialsClusterMutex.Unlock()
	fake.UpdateCredentialsClusterStub = stub
}

func (fake *Client) UpdateCredentialsClusterArgsForCall(i int) *client.UpdateCredentialsOptions {
	fake.updateCredentialsClusterMutex.RLock()
	defer fake.updateCredentialsClusterMutex.RUnlock()
	argsForCall := fake.updateCredentialsClusterArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) UpdateCredentialsClusterReturns(result1 error) {
	fake.updateCredentialsClusterMutex.Lock()
	defer fake.updateCredentialsClusterMutex.Unlock()
	fake.UpdateCredentialsClusterStub = nil
	fake.updateCredentialsClusterReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) UpdateCredentialsClusterReturnsOnCall(i int, result1 error) {
	fake.updateCredentialsClusterMutex.Lock()
	defer fake.updateCredentialsClusterMutex.Unlock()
	fake.UpdateCredentialsClusterStub = nil
	if fake.updateCredentialsClusterReturnsOnCall == nil {
		fake.updateCredentialsClusterReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateCredentialsClusterReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Client) UpdateCredentialsRegion(arg1 *client.UpdateCredentialsOptions) error {
	fake.updateCredentialsRegionMutex.Lock()
	ret, specificReturn := fake.updateCredentialsRegionReturnsOnCall[len(fake.updateCredentialsRegionArgsForCall)]
	fake.updateCredentialsRegionArgsForCall = append(fake.updateCredentialsRegionArgsForCall, struct {
		arg1 *client.UpdateCredentialsOptions
	}{arg1})
	fake.recordInvocation("UpdateCredentialsRegion", []interface{}{arg1})
	fake.updateCredentialsRegionMutex.Unlock()
	if fake.UpdateCredentialsRegionStub != nil {
		return fake.UpdateCredentialsRegionStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.updateCredentialsRegionReturns
	return fakeReturns.result1
}

func (fake *Client) UpdateCredentialsRegionCallCount() int {
	fake.updateCredentialsRegionMutex.RLock()
	defer fake.updateCredentialsRegionMutex.RUnlock()
	return len(fake.updateCredentialsRegionArgsForCall)
}

func (fake *Client) UpdateCredentialsRegionCalls(stub func(*client.UpdateCredentialsOptions) error) {
	fake.updateCredentialsRegionMutex.Lock()
	defer fake.updateCredentialsRegionMutex.Unlock()
	fake.UpdateCredentialsRegionStub = stub
}

func (fake *Client) UpdateCredentialsRegionArgsForCall(i int) *client.UpdateCredentialsOptions {
	fake.updateCredentialsRegionMutex.RLock()
	defer fake.updateCredentialsRegionMutex.RUnlock()
	argsForCall := fake.updateCredentialsRegionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) UpdateCredentialsRegionReturns(result1 error) {
	fake.updateCredentialsRegionMutex.Lock()
	defer fake.updateCredentialsRegionMutex.Unlock()
	fake.UpdateCredentialsRegionStub = nil
	fake.updateCredentialsRegionReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) UpdateCredentialsRegionReturnsOnCall(i int, result1 error) {
	fake.updateCredentialsRegionMutex.Lock()
	defer fake.updateCredentialsRegionMutex.Unlock()
	fake.UpdateCredentialsRegionStub = nil
	if fake.updateCredentialsRegionReturnsOnCall == nil {
		fake.updateCredentialsRegionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateCredentialsRegionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Client) UpgradeCluster(arg1 *client.UpgradeClusterOptions) error {
	fake.upgradeClusterMutex.Lock()
	ret, specificReturn := fake.upgradeClusterReturnsOnCall[len(fake.upgradeClusterArgsForCall)]
	fake.upgradeClusterArgsForCall = append(fake.upgradeClusterArgsForCall, struct {
		arg1 *client.UpgradeClusterOptions
	}{arg1})
	fake.recordInvocation("UpgradeCluster", []interface{}{arg1})
	fake.upgradeClusterMutex.Unlock()
	if fake.UpgradeClusterStub != nil {
		return fake.UpgradeClusterStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.upgradeClusterReturns
	return fakeReturns.result1
}

func (fake *Client) UpgradeClusterCallCount() int {
	fake.upgradeClusterMutex.RLock()
	defer fake.upgradeClusterMutex.RUnlock()
	return len(fake.upgradeClusterArgsForCall)
}

func (fake *Client) UpgradeClusterCalls(stub func(*client.UpgradeClusterOptions) error) {
	fake.upgradeClusterMutex.Lock()
	defer fake.upgradeClusterMutex.Unlock()
	fake.UpgradeClusterStub = stub
}

func (fake *Client) UpgradeClusterArgsForCall(i int) *client.UpgradeClusterOptions {
	fake.upgradeClusterMutex.RLock()
	defer fake.upgradeClusterMutex.RUnlock()
	argsForCall := fake.upgradeClusterArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) UpgradeClusterReturns(result1 error) {
	fake.upgradeClusterMutex.Lock()
	defer fake.upgradeClusterMutex.Unlock()
	fake.UpgradeClusterStub = nil
	fake.upgradeClusterReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) UpgradeClusterReturnsOnCall(i int, result1 error) {
	fake.upgradeClusterMutex.Lock()
	defer fake.upgradeClusterMutex.Unlock()
	fake.UpgradeClusterStub = nil
	if fake.upgradeClusterReturnsOnCall == nil {
		fake.upgradeClusterReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.upgradeClusterReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Client) UpgradeManagementCluster(arg1 *client.UpgradeClusterOptions) error {
	fake.upgradeManagementClusterMutex.Lock()
	ret, specificReturn := fake.upgradeManagementClusterReturnsOnCall[len(fake.upgradeManagementClusterArgsForCall)]
	fake.upgradeManagementClusterArgsForCall = append(fake.upgradeManagementClusterArgsForCall, struct {
		arg1 *client.UpgradeClusterOptions
	}{arg1})
	fake.recordInvocation("UpgradeManagementCluster", []interface{}{arg1})
	fake.upgradeManagementClusterMutex.Unlock()
	if fake.UpgradeManagementClusterStub != nil {
		return fake.UpgradeManagementClusterStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.upgradeManagementClusterReturns
	return fakeReturns.result1
}

func (fake *Client) UpgradeManagementClusterCallCount() int {
	fake.upgradeManagementClusterMutex.RLock()
	defer fake.upgradeManagementClusterMutex.RUnlock()
	return len(fake.upgradeManagementClusterArgsForCall)
}

func (fake *Client) UpgradeManagementClusterCalls(stub func(*client.UpgradeClusterOptions) error) {
	fake.upgradeManagementClusterMutex.Lock()
	defer fake.upgradeManagementClusterMutex.Unlock()
	fake.UpgradeManagementClusterStub = stub
}

func (fake *Client) UpgradeManagementClusterArgsForCall(i int) *client.UpgradeClusterOptions {
	fake.upgradeManagementClusterMutex.RLock()
	defer fake.upgradeManagementClusterMutex.RUnlock()
	argsForCall := fake.upgradeManagementClusterArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) UpgradeManagementClusterReturns(result1 error) {
	fake.upgradeManagementClusterMutex.Lock()
	defer fake.upgradeManagementClusterMutex.Unlock()
	fake.UpgradeManagementClusterStub = nil
	fake.upgradeManagementClusterReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) UpgradeManagementClusterReturnsOnCall(i int, result1 error) {
	fake.upgradeManagementClusterMutex.Lock()
	defer fake.upgradeManagementClusterMutex.Unlock()
	fake.UpgradeManagementClusterStub = nil
	if fake.upgradeManagementClusterReturnsOnCall == nil {
		fake.upgradeManagementClusterReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.upgradeManagementClusterReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Client) ValidatePrerequisites(arg1 bool, arg2 bool) error {
	fake.validatePrerequisitesMutex.Lock()
	ret, specificReturn := fake.validatePrerequisitesReturnsOnCall[len(fake.validatePrerequisitesArgsForCall)]
	fake.validatePrerequisitesArgsForCall = append(fake.validatePrerequisitesArgsForCall, struct {
		arg1 bool
		arg2 bool
	}{arg1, arg2})
	fake.recordInvocation("ValidatePrerequisites", []interface{}{arg1, arg2})
	fake.validatePrerequisitesMutex.Unlock()
	if fake.ValidatePrerequisitesStub != nil {
		return fake.ValidatePrerequisitesStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.validatePrerequisitesReturns
	return fakeReturns.result1
}

func (fake *Client) ValidatePrerequisitesCallCount() int {
	fake.validatePrerequisitesMutex.RLock()
	defer fake.validatePrerequisitesMutex.RUnlock()
	return len(fake.validatePrerequisitesArgsForCall)
}

func (fake *Client) ValidatePrerequisitesCalls(stub func(bool, bool) error) {
	fake.validatePrerequisitesMutex.Lock()
	defer fake.validatePrerequisitesMutex.Unlock()
	fake.ValidatePrerequisitesStub = stub
}

func (fake *Client) ValidatePrerequisitesArgsForCall(i int) (bool, bool) {
	fake.validatePrerequisitesMutex.RLock()
	defer fake.validatePrerequisitesMutex.RUnlock()
	argsForCall := fake.validatePrerequisitesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Client) ValidatePrerequisitesReturns(result1 error) {
	fake.validatePrerequisitesMutex.Lock()
	defer fake.validatePrerequisitesMutex.Unlock()
	fake.ValidatePrerequisitesStub = nil
	fake.validatePrerequisitesReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) ValidatePrerequisitesReturnsOnCall(i int, result1 error) {
	fake.validatePrerequisitesMutex.Lock()
	defer fake.validatePrerequisitesMutex.Unlock()
	fake.ValidatePrerequisitesStub = nil
	if fake.validatePrerequisitesReturnsOnCall == nil {
		fake.validatePrerequisitesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.validatePrerequisitesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Client) VerifyRegion(arg1 string) (region.RegionContext, error) {
	fake.verifyRegionMutex.Lock()
	ret, specificReturn := fake.verifyRegionReturnsOnCall[len(fake.verifyRegionArgsForCall)]
	fake.verifyRegionArgsForCall = append(fake.verifyRegionArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("VerifyRegion", []interface{}{arg1})
	fake.verifyRegionMutex.Unlock()
	if fake.VerifyRegionStub != nil {
		return fake.VerifyRegionStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.verifyRegionReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Client) VerifyRegionCallCount() int {
	fake.verifyRegionMutex.RLock()
	defer fake.verifyRegionMutex.RUnlock()
	return len(fake.verifyRegionArgsForCall)
}

func (fake *Client) VerifyRegionCalls(stub func(string) (region.RegionContext, error)) {
	fake.verifyRegionMutex.Lock()
	defer fake.verifyRegionMutex.Unlock()
	fake.VerifyRegionStub = stub
}

func (fake *Client) VerifyRegionArgsForCall(i int) string {
	fake.verifyRegionMutex.RLock()
	defer fake.verifyRegionMutex.RUnlock()
	argsForCall := fake.verifyRegionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) VerifyRegionReturns(result1 region.RegionContext, result2 error) {
	fake.verifyRegionMutex.Lock()
	defer fake.verifyRegionMutex.Unlock()
	fake.VerifyRegionStub = nil
	fake.verifyRegionReturns = struct {
		result1 region.RegionContext
		result2 error
	}{result1, result2}
}

func (fake *Client) VerifyRegionReturnsOnCall(i int, result1 region.RegionContext, result2 error) {
	fake.verifyRegionMutex.Lock()
	defer fake.verifyRegionMutex.Unlock()
	fake.VerifyRegionStub = nil
	if fake.verifyRegionReturnsOnCall == nil {
		fake.verifyRegionReturnsOnCall = make(map[int]struct {
			result1 region.RegionContext
			result2 error
		})
	}
	fake.verifyRegionReturnsOnCall[i] = struct {
		result1 region.RegionContext
		result2 error
	}{result1, result2}
}

func (fake *Client) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addRegionContextMutex.RLock()
	defer fake.addRegionContextMutex.RUnlock()
	fake.configureAndValidateManagementClusterConfigurationMutex.RLock()
	defer fake.configureAndValidateManagementClusterConfigurationMutex.RUnlock()
	fake.configureAndValidateTkrVersionMutex.RLock()
	defer fake.configureAndValidateTkrVersionMutex.RUnlock()
	fake.configureTimeoutMutex.RLock()
	defer fake.configureTimeoutMutex.RUnlock()
	fake.createAWSCloudFormationStackMutex.RLock()
	defer fake.createAWSCloudFormationStackMutex.RUnlock()
	fake.createClusterMutex.RLock()
	defer fake.createClusterMutex.RUnlock()
	fake.deRegisterManagementClusterFromTmcMutex.RLock()
	defer fake.deRegisterManagementClusterFromTmcMutex.RUnlock()
	fake.deleteMachineHealthCheckMutex.RLock()
	defer fake.deleteMachineHealthCheckMutex.RUnlock()
	fake.deleteRegionMutex.RLock()
	defer fake.deleteRegionMutex.RUnlock()
	fake.deleteWorkloadClusterMutex.RLock()
	defer fake.deleteWorkloadClusterMutex.RUnlock()
	fake.describeClusterMutex.RLock()
	defer fake.describeClusterMutex.RUnlock()
	fake.describeProviderMutex.RLock()
	defer fake.describeProviderMutex.RUnlock()
	fake.downloadBomFileMutex.RLock()
	defer fake.downloadBomFileMutex.RUnlock()
	fake.getCEIPParticipationMutex.RLock()
	defer fake.getCEIPParticipationMutex.RUnlock()
	fake.getClusterConfigurationMutex.RLock()
	defer fake.getClusterConfigurationMutex.RUnlock()
	fake.getClusterPinnipedInfoMutex.RLock()
	defer fake.getClusterPinnipedInfoMutex.RUnlock()
	fake.getCurrentRegionContextMutex.RLock()
	defer fake.getCurrentRegionContextMutex.RUnlock()
	fake.getKubernetesVersionsMutex.RLock()
	defer fake.getKubernetesVersionsMutex.RUnlock()
	fake.getMachineHealthChecksMutex.RLock()
	defer fake.getMachineHealthChecksMutex.RUnlock()
	fake.getRegionContextsMutex.RLock()
	defer fake.getRegionContextsMutex.RUnlock()
	fake.getTanzuKubernetesReleasesMutex.RLock()
	defer fake.getTanzuKubernetesReleasesMutex.RUnlock()
	fake.getVSphereEndpointMutex.RLock()
	defer fake.getVSphereEndpointMutex.RUnlock()
	fake.getWorkloadClusterCredentialsMutex.RLock()
	defer fake.getWorkloadClusterCredentialsMutex.RUnlock()
	fake.initRegionMutex.RLock()
	defer fake.initRegionMutex.RUnlock()
	fake.initRegionDryRunMutex.RLock()
	defer fake.initRegionDryRunMutex.RUnlock()
	fake.isManagementClusterAKindClusterMutex.RLock()
	defer fake.isManagementClusterAKindClusterMutex.RUnlock()
	fake.isPacificManagementClusterMutex.RLock()
	defer fake.isPacificManagementClusterMutex.RUnlock()
	fake.listTKGClustersMutex.RLock()
	defer fake.listTKGClustersMutex.RUnlock()
	fake.parseHiddenArgsAsFeatureFlagsMutex.RLock()
	defer fake.parseHiddenArgsAsFeatureFlagsMutex.RUnlock()
	fake.registerManagementClusterToTmcMutex.RLock()
	defer fake.registerManagementClusterToTmcMutex.RUnlock()
	fake.saveFeatureFlagsMutex.RLock()
	defer fake.saveFeatureFlagsMutex.RUnlock()
	fake.scaleClusterMutex.RLock()
	defer fake.scaleClusterMutex.RUnlock()
	fake.setCEIPParticipationMutex.RLock()
	defer fake.setCEIPParticipationMutex.RUnlock()
	fake.setMachineHealthCheckMutex.RLock()
	defer fake.setMachineHealthCheckMutex.RUnlock()
	fake.setRegionContextMutex.RLock()
	defer fake.setRegionContextMutex.RUnlock()
	fake.tKGConfigReaderWriterMutex.RLock()
	defer fake.tKGConfigReaderWriterMutex.RUnlock()
	fake.updateCredentialsClusterMutex.RLock()
	defer fake.updateCredentialsClusterMutex.RUnlock()
	fake.updateCredentialsRegionMutex.RLock()
	defer fake.updateCredentialsRegionMutex.RUnlock()
	fake.upgradeClusterMutex.RLock()
	defer fake.upgradeClusterMutex.RUnlock()
	fake.upgradeManagementClusterMutex.RLock()
	defer fake.upgradeManagementClusterMutex.RUnlock()
	fake.validatePrerequisitesMutex.RLock()
	defer fake.validatePrerequisitesMutex.RUnlock()
	fake.verifyRegionMutex.RLock()
	defer fake.verifyRegionMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *Client) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ client.Client = new(Client)
