// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"context"
	"sync"

	"github.com/vmware-tanzu/tanzu-framework/pkg/v1/tkg/web/server/models"
	"github.com/vmware-tanzu/tanzu-framework/tkg/tkgconfigreaderwriter"
	"github.com/vmware-tanzu/tanzu-framework/tkg/types"
	"github.com/vmware-tanzu/tanzu-framework/tkg/vc"
)

type VCClient struct {
	AcquireTicketStub        func() (string, error)
	acquireTicketMutex       sync.RWMutex
	acquireTicketArgsForCall []struct {
	}
	acquireTicketReturns struct {
		result1 string
		result2 error
	}
	acquireTicketReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	CheckUserSessionActiveStub        func() (bool, error)
	checkUserSessionActiveMutex       sync.RWMutex
	checkUserSessionActiveArgsForCall []struct {
	}
	checkUserSessionActiveReturns struct {
		result1 bool
		result2 error
	}
	checkUserSessionActiveReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	DetectPacificStub        func(context.Context) (bool, error)
	detectPacificMutex       sync.RWMutex
	detectPacificArgsForCall []struct {
		arg1 context.Context
	}
	detectPacificReturns struct {
		result1 bool
		result2 error
	}
	detectPacificReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	FindDataCenterStub        func(context.Context, string) (string, error)
	findDataCenterMutex       sync.RWMutex
	findDataCenterArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	findDataCenterReturns struct {
		result1 string
		result2 error
	}
	findDataCenterReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	FindDatastoreStub        func(context.Context, string, string) (string, error)
	findDatastoreMutex       sync.RWMutex
	findDatastoreArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	findDatastoreReturns struct {
		result1 string
		result2 error
	}
	findDatastoreReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	FindFolderStub        func(context.Context, string, string) (string, error)
	findFolderMutex       sync.RWMutex
	findFolderArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	findFolderReturns struct {
		result1 string
		result2 error
	}
	findFolderReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	FindNetworkStub        func(context.Context, string, string) (string, error)
	findNetworkMutex       sync.RWMutex
	findNetworkArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	findNetworkReturns struct {
		result1 string
		result2 error
	}
	findNetworkReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	FindResourcePoolStub        func(context.Context, string, string) (string, error)
	findResourcePoolMutex       sync.RWMutex
	findResourcePoolArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	findResourcePoolReturns struct {
		result1 string
		result2 error
	}
	findResourcePoolReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	FindVirtualMachineStub        func(context.Context, string, string) (string, error)
	findVirtualMachineMutex       sync.RWMutex
	findVirtualMachineArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	findVirtualMachineReturns struct {
		result1 string
		result2 error
	}
	findVirtualMachineReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetAndValidateVirtualMachineTemplateStub        func([]string, string, string, string, tkgconfigreaderwriter.TKGConfigReaderWriter) (*types.VSphereVirtualMachine, error)
	getAndValidateVirtualMachineTemplateMutex       sync.RWMutex
	getAndValidateVirtualMachineTemplateArgsForCall []struct {
		arg1 []string
		arg2 string
		arg3 string
		arg4 string
		arg5 tkgconfigreaderwriter.TKGConfigReaderWriter
	}
	getAndValidateVirtualMachineTemplateReturns struct {
		result1 *types.VSphereVirtualMachine
		result2 error
	}
	getAndValidateVirtualMachineTemplateReturnsOnCall map[int]struct {
		result1 *types.VSphereVirtualMachine
		result2 error
	}
	GetComputeResourcesStub        func(context.Context, string) ([]*models.VSphereManagementObject, error)
	getComputeResourcesMutex       sync.RWMutex
	getComputeResourcesArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getComputeResourcesReturns struct {
		result1 []*models.VSphereManagementObject
		result2 error
	}
	getComputeResourcesReturnsOnCall map[int]struct {
		result1 []*models.VSphereManagementObject
		result2 error
	}
	GetDataCenterMOIDStub        func(context.Context, string) (string, error)
	getDataCenterMOIDMutex       sync.RWMutex
	getDataCenterMOIDArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getDataCenterMOIDReturns struct {
		result1 string
		result2 error
	}
	getDataCenterMOIDReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetDatacentersStub        func(context.Context) ([]*models.VSphereDatacenter, error)
	getDatacentersMutex       sync.RWMutex
	getDatacentersArgsForCall []struct {
		arg1 context.Context
	}
	getDatacentersReturns struct {
		result1 []*models.VSphereDatacenter
		result2 error
	}
	getDatacentersReturnsOnCall map[int]struct {
		result1 []*models.VSphereDatacenter
		result2 error
	}
	GetDatastoresStub        func(context.Context, string) ([]*models.VSphereDatastore, error)
	getDatastoresMutex       sync.RWMutex
	getDatastoresArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getDatastoresReturns struct {
		result1 []*models.VSphereDatastore
		result2 error
	}
	getDatastoresReturnsOnCall map[int]struct {
		result1 []*models.VSphereDatastore
		result2 error
	}
	GetFoldersStub        func(context.Context, string) ([]*models.VSphereFolder, error)
	getFoldersMutex       sync.RWMutex
	getFoldersArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getFoldersReturns struct {
		result1 []*models.VSphereFolder
		result2 error
	}
	getFoldersReturnsOnCall map[int]struct {
		result1 []*models.VSphereFolder
		result2 error
	}
	GetNetworksStub        func(context.Context, string) ([]*models.VSphereNetwork, error)
	getNetworksMutex       sync.RWMutex
	getNetworksArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getNetworksReturns struct {
		result1 []*models.VSphereNetwork
		result2 error
	}
	getNetworksReturnsOnCall map[int]struct {
		result1 []*models.VSphereNetwork
		result2 error
	}
	GetPathStub        func(context.Context, string) (string, []*models.VSphereManagementObject, error)
	getPathMutex       sync.RWMutex
	getPathArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getPathReturns struct {
		result1 string
		result2 []*models.VSphereManagementObject
		result3 error
	}
	getPathReturnsOnCall map[int]struct {
		result1 string
		result2 []*models.VSphereManagementObject
		result3 error
	}
	GetResourcePoolsStub        func(context.Context, string) ([]*models.VSphereResourcePool, error)
	getResourcePoolsMutex       sync.RWMutex
	getResourcePoolsArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getResourcePoolsReturns struct {
		result1 []*models.VSphereResourcePool
		result2 error
	}
	getResourcePoolsReturnsOnCall map[int]struct {
		result1 []*models.VSphereResourcePool
		result2 error
	}
	GetVSphereVersionStub        func() (string, string, error)
	getVSphereVersionMutex       sync.RWMutex
	getVSphereVersionArgsForCall []struct {
	}
	getVSphereVersionReturns struct {
		result1 string
		result2 string
		result3 error
	}
	getVSphereVersionReturnsOnCall map[int]struct {
		result1 string
		result2 string
		result3 error
	}
	GetVirtualMachineImagesStub        func(context.Context, string) ([]*types.VSphereVirtualMachine, error)
	getVirtualMachineImagesMutex       sync.RWMutex
	getVirtualMachineImagesArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getVirtualMachineImagesReturns struct {
		result1 []*types.VSphereVirtualMachine
		result2 error
	}
	getVirtualMachineImagesReturnsOnCall map[int]struct {
		result1 []*types.VSphereVirtualMachine
		result2 error
	}
	GetVirtualMachinesStub        func(context.Context, string) ([]*models.VSphereVirtualMachine, error)
	getVirtualMachinesMutex       sync.RWMutex
	getVirtualMachinesArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getVirtualMachinesReturns struct {
		result1 []*models.VSphereVirtualMachine
		result2 error
	}
	getVirtualMachinesReturnsOnCall map[int]struct {
		result1 []*models.VSphereVirtualMachine
		result2 error
	}
	LoginStub        func(context.Context, string, string) (string, error)
	loginMutex       sync.RWMutex
	loginArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	loginReturns struct {
		result1 string
		result2 error
	}
	loginReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *VCClient) AcquireTicket() (string, error) {
	fake.acquireTicketMutex.Lock()
	ret, specificReturn := fake.acquireTicketReturnsOnCall[len(fake.acquireTicketArgsForCall)]
	fake.acquireTicketArgsForCall = append(fake.acquireTicketArgsForCall, struct {
	}{})
	stub := fake.AcquireTicketStub
	fakeReturns := fake.acquireTicketReturns
	fake.recordInvocation("AcquireTicket", []interface{}{})
	fake.acquireTicketMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *VCClient) AcquireTicketCallCount() int {
	fake.acquireTicketMutex.RLock()
	defer fake.acquireTicketMutex.RUnlock()
	return len(fake.acquireTicketArgsForCall)
}

func (fake *VCClient) AcquireTicketCalls(stub func() (string, error)) {
	fake.acquireTicketMutex.Lock()
	defer fake.acquireTicketMutex.Unlock()
	fake.AcquireTicketStub = stub
}

func (fake *VCClient) AcquireTicketReturns(result1 string, result2 error) {
	fake.acquireTicketMutex.Lock()
	defer fake.acquireTicketMutex.Unlock()
	fake.AcquireTicketStub = nil
	fake.acquireTicketReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *VCClient) AcquireTicketReturnsOnCall(i int, result1 string, result2 error) {
	fake.acquireTicketMutex.Lock()
	defer fake.acquireTicketMutex.Unlock()
	fake.AcquireTicketStub = nil
	if fake.acquireTicketReturnsOnCall == nil {
		fake.acquireTicketReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.acquireTicketReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *VCClient) CheckUserSessionActive() (bool, error) {
	fake.checkUserSessionActiveMutex.Lock()
	ret, specificReturn := fake.checkUserSessionActiveReturnsOnCall[len(fake.checkUserSessionActiveArgsForCall)]
	fake.checkUserSessionActiveArgsForCall = append(fake.checkUserSessionActiveArgsForCall, struct {
	}{})
	stub := fake.CheckUserSessionActiveStub
	fakeReturns := fake.checkUserSessionActiveReturns
	fake.recordInvocation("CheckUserSessionActive", []interface{}{})
	fake.checkUserSessionActiveMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *VCClient) CheckUserSessionActiveCallCount() int {
	fake.checkUserSessionActiveMutex.RLock()
	defer fake.checkUserSessionActiveMutex.RUnlock()
	return len(fake.checkUserSessionActiveArgsForCall)
}

func (fake *VCClient) CheckUserSessionActiveCalls(stub func() (bool, error)) {
	fake.checkUserSessionActiveMutex.Lock()
	defer fake.checkUserSessionActiveMutex.Unlock()
	fake.CheckUserSessionActiveStub = stub
}

func (fake *VCClient) CheckUserSessionActiveReturns(result1 bool, result2 error) {
	fake.checkUserSessionActiveMutex.Lock()
	defer fake.checkUserSessionActiveMutex.Unlock()
	fake.CheckUserSessionActiveStub = nil
	fake.checkUserSessionActiveReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *VCClient) CheckUserSessionActiveReturnsOnCall(i int, result1 bool, result2 error) {
	fake.checkUserSessionActiveMutex.Lock()
	defer fake.checkUserSessionActiveMutex.Unlock()
	fake.CheckUserSessionActiveStub = nil
	if fake.checkUserSessionActiveReturnsOnCall == nil {
		fake.checkUserSessionActiveReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.checkUserSessionActiveReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *VCClient) DetectPacific(arg1 context.Context) (bool, error) {
	fake.detectPacificMutex.Lock()
	ret, specificReturn := fake.detectPacificReturnsOnCall[len(fake.detectPacificArgsForCall)]
	fake.detectPacificArgsForCall = append(fake.detectPacificArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.DetectPacificStub
	fakeReturns := fake.detectPacificReturns
	fake.recordInvocation("DetectPacific", []interface{}{arg1})
	fake.detectPacificMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *VCClient) DetectPacificCallCount() int {
	fake.detectPacificMutex.RLock()
	defer fake.detectPacificMutex.RUnlock()
	return len(fake.detectPacificArgsForCall)
}

func (fake *VCClient) DetectPacificCalls(stub func(context.Context) (bool, error)) {
	fake.detectPacificMutex.Lock()
	defer fake.detectPacificMutex.Unlock()
	fake.DetectPacificStub = stub
}

func (fake *VCClient) DetectPacificArgsForCall(i int) context.Context {
	fake.detectPacificMutex.RLock()
	defer fake.detectPacificMutex.RUnlock()
	argsForCall := fake.detectPacificArgsForCall[i]
	return argsForCall.arg1
}

func (fake *VCClient) DetectPacificReturns(result1 bool, result2 error) {
	fake.detectPacificMutex.Lock()
	defer fake.detectPacificMutex.Unlock()
	fake.DetectPacificStub = nil
	fake.detectPacificReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *VCClient) DetectPacificReturnsOnCall(i int, result1 bool, result2 error) {
	fake.detectPacificMutex.Lock()
	defer fake.detectPacificMutex.Unlock()
	fake.DetectPacificStub = nil
	if fake.detectPacificReturnsOnCall == nil {
		fake.detectPacificReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.detectPacificReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *VCClient) FindDataCenter(arg1 context.Context, arg2 string) (string, error) {
	fake.findDataCenterMutex.Lock()
	ret, specificReturn := fake.findDataCenterReturnsOnCall[len(fake.findDataCenterArgsForCall)]
	fake.findDataCenterArgsForCall = append(fake.findDataCenterArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.FindDataCenterStub
	fakeReturns := fake.findDataCenterReturns
	fake.recordInvocation("FindDataCenter", []interface{}{arg1, arg2})
	fake.findDataCenterMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *VCClient) FindDataCenterCallCount() int {
	fake.findDataCenterMutex.RLock()
	defer fake.findDataCenterMutex.RUnlock()
	return len(fake.findDataCenterArgsForCall)
}

func (fake *VCClient) FindDataCenterCalls(stub func(context.Context, string) (string, error)) {
	fake.findDataCenterMutex.Lock()
	defer fake.findDataCenterMutex.Unlock()
	fake.FindDataCenterStub = stub
}

func (fake *VCClient) FindDataCenterArgsForCall(i int) (context.Context, string) {
	fake.findDataCenterMutex.RLock()
	defer fake.findDataCenterMutex.RUnlock()
	argsForCall := fake.findDataCenterArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *VCClient) FindDataCenterReturns(result1 string, result2 error) {
	fake.findDataCenterMutex.Lock()
	defer fake.findDataCenterMutex.Unlock()
	fake.FindDataCenterStub = nil
	fake.findDataCenterReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *VCClient) FindDataCenterReturnsOnCall(i int, result1 string, result2 error) {
	fake.findDataCenterMutex.Lock()
	defer fake.findDataCenterMutex.Unlock()
	fake.FindDataCenterStub = nil
	if fake.findDataCenterReturnsOnCall == nil {
		fake.findDataCenterReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.findDataCenterReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *VCClient) FindDatastore(arg1 context.Context, arg2 string, arg3 string) (string, error) {
	fake.findDatastoreMutex.Lock()
	ret, specificReturn := fake.findDatastoreReturnsOnCall[len(fake.findDatastoreArgsForCall)]
	fake.findDatastoreArgsForCall = append(fake.findDatastoreArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.FindDatastoreStub
	fakeReturns := fake.findDatastoreReturns
	fake.recordInvocation("FindDatastore", []interface{}{arg1, arg2, arg3})
	fake.findDatastoreMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *VCClient) FindDatastoreCallCount() int {
	fake.findDatastoreMutex.RLock()
	defer fake.findDatastoreMutex.RUnlock()
	return len(fake.findDatastoreArgsForCall)
}

func (fake *VCClient) FindDatastoreCalls(stub func(context.Context, string, string) (string, error)) {
	fake.findDatastoreMutex.Lock()
	defer fake.findDatastoreMutex.Unlock()
	fake.FindDatastoreStub = stub
}

func (fake *VCClient) FindDatastoreArgsForCall(i int) (context.Context, string, string) {
	fake.findDatastoreMutex.RLock()
	defer fake.findDatastoreMutex.RUnlock()
	argsForCall := fake.findDatastoreArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *VCClient) FindDatastoreReturns(result1 string, result2 error) {
	fake.findDatastoreMutex.Lock()
	defer fake.findDatastoreMutex.Unlock()
	fake.FindDatastoreStub = nil
	fake.findDatastoreReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *VCClient) FindDatastoreReturnsOnCall(i int, result1 string, result2 error) {
	fake.findDatastoreMutex.Lock()
	defer fake.findDatastoreMutex.Unlock()
	fake.FindDatastoreStub = nil
	if fake.findDatastoreReturnsOnCall == nil {
		fake.findDatastoreReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.findDatastoreReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *VCClient) FindFolder(arg1 context.Context, arg2 string, arg3 string) (string, error) {
	fake.findFolderMutex.Lock()
	ret, specificReturn := fake.findFolderReturnsOnCall[len(fake.findFolderArgsForCall)]
	fake.findFolderArgsForCall = append(fake.findFolderArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.FindFolderStub
	fakeReturns := fake.findFolderReturns
	fake.recordInvocation("FindFolder", []interface{}{arg1, arg2, arg3})
	fake.findFolderMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *VCClient) FindFolderCallCount() int {
	fake.findFolderMutex.RLock()
	defer fake.findFolderMutex.RUnlock()
	return len(fake.findFolderArgsForCall)
}

func (fake *VCClient) FindFolderCalls(stub func(context.Context, string, string) (string, error)) {
	fake.findFolderMutex.Lock()
	defer fake.findFolderMutex.Unlock()
	fake.FindFolderStub = stub
}

func (fake *VCClient) FindFolderArgsForCall(i int) (context.Context, string, string) {
	fake.findFolderMutex.RLock()
	defer fake.findFolderMutex.RUnlock()
	argsForCall := fake.findFolderArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *VCClient) FindFolderReturns(result1 string, result2 error) {
	fake.findFolderMutex.Lock()
	defer fake.findFolderMutex.Unlock()
	fake.FindFolderStub = nil
	fake.findFolderReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *VCClient) FindFolderReturnsOnCall(i int, result1 string, result2 error) {
	fake.findFolderMutex.Lock()
	defer fake.findFolderMutex.Unlock()
	fake.FindFolderStub = nil
	if fake.findFolderReturnsOnCall == nil {
		fake.findFolderReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.findFolderReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *VCClient) FindNetwork(arg1 context.Context, arg2 string, arg3 string) (string, error) {
	fake.findNetworkMutex.Lock()
	ret, specificReturn := fake.findNetworkReturnsOnCall[len(fake.findNetworkArgsForCall)]
	fake.findNetworkArgsForCall = append(fake.findNetworkArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.FindNetworkStub
	fakeReturns := fake.findNetworkReturns
	fake.recordInvocation("FindNetwork", []interface{}{arg1, arg2, arg3})
	fake.findNetworkMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *VCClient) FindNetworkCallCount() int {
	fake.findNetworkMutex.RLock()
	defer fake.findNetworkMutex.RUnlock()
	return len(fake.findNetworkArgsForCall)
}

func (fake *VCClient) FindNetworkCalls(stub func(context.Context, string, string) (string, error)) {
	fake.findNetworkMutex.Lock()
	defer fake.findNetworkMutex.Unlock()
	fake.FindNetworkStub = stub
}

func (fake *VCClient) FindNetworkArgsForCall(i int) (context.Context, string, string) {
	fake.findNetworkMutex.RLock()
	defer fake.findNetworkMutex.RUnlock()
	argsForCall := fake.findNetworkArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *VCClient) FindNetworkReturns(result1 string, result2 error) {
	fake.findNetworkMutex.Lock()
	defer fake.findNetworkMutex.Unlock()
	fake.FindNetworkStub = nil
	fake.findNetworkReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *VCClient) FindNetworkReturnsOnCall(i int, result1 string, result2 error) {
	fake.findNetworkMutex.Lock()
	defer fake.findNetworkMutex.Unlock()
	fake.FindNetworkStub = nil
	if fake.findNetworkReturnsOnCall == nil {
		fake.findNetworkReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.findNetworkReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *VCClient) FindResourcePool(arg1 context.Context, arg2 string, arg3 string) (string, error) {
	fake.findResourcePoolMutex.Lock()
	ret, specificReturn := fake.findResourcePoolReturnsOnCall[len(fake.findResourcePoolArgsForCall)]
	fake.findResourcePoolArgsForCall = append(fake.findResourcePoolArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.FindResourcePoolStub
	fakeReturns := fake.findResourcePoolReturns
	fake.recordInvocation("FindResourcePool", []interface{}{arg1, arg2, arg3})
	fake.findResourcePoolMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *VCClient) FindResourcePoolCallCount() int {
	fake.findResourcePoolMutex.RLock()
	defer fake.findResourcePoolMutex.RUnlock()
	return len(fake.findResourcePoolArgsForCall)
}

func (fake *VCClient) FindResourcePoolCalls(stub func(context.Context, string, string) (string, error)) {
	fake.findResourcePoolMutex.Lock()
	defer fake.findResourcePoolMutex.Unlock()
	fake.FindResourcePoolStub = stub
}

func (fake *VCClient) FindResourcePoolArgsForCall(i int) (context.Context, string, string) {
	fake.findResourcePoolMutex.RLock()
	defer fake.findResourcePoolMutex.RUnlock()
	argsForCall := fake.findResourcePoolArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *VCClient) FindResourcePoolReturns(result1 string, result2 error) {
	fake.findResourcePoolMutex.Lock()
	defer fake.findResourcePoolMutex.Unlock()
	fake.FindResourcePoolStub = nil
	fake.findResourcePoolReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *VCClient) FindResourcePoolReturnsOnCall(i int, result1 string, result2 error) {
	fake.findResourcePoolMutex.Lock()
	defer fake.findResourcePoolMutex.Unlock()
	fake.FindResourcePoolStub = nil
	if fake.findResourcePoolReturnsOnCall == nil {
		fake.findResourcePoolReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.findResourcePoolReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *VCClient) FindVirtualMachine(arg1 context.Context, arg2 string, arg3 string) (string, error) {
	fake.findVirtualMachineMutex.Lock()
	ret, specificReturn := fake.findVirtualMachineReturnsOnCall[len(fake.findVirtualMachineArgsForCall)]
	fake.findVirtualMachineArgsForCall = append(fake.findVirtualMachineArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.FindVirtualMachineStub
	fakeReturns := fake.findVirtualMachineReturns
	fake.recordInvocation("FindVirtualMachine", []interface{}{arg1, arg2, arg3})
	fake.findVirtualMachineMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *VCClient) FindVirtualMachineCallCount() int {
	fake.findVirtualMachineMutex.RLock()
	defer fake.findVirtualMachineMutex.RUnlock()
	return len(fake.findVirtualMachineArgsForCall)
}

func (fake *VCClient) FindVirtualMachineCalls(stub func(context.Context, string, string) (string, error)) {
	fake.findVirtualMachineMutex.Lock()
	defer fake.findVirtualMachineMutex.Unlock()
	fake.FindVirtualMachineStub = stub
}

func (fake *VCClient) FindVirtualMachineArgsForCall(i int) (context.Context, string, string) {
	fake.findVirtualMachineMutex.RLock()
	defer fake.findVirtualMachineMutex.RUnlock()
	argsForCall := fake.findVirtualMachineArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *VCClient) FindVirtualMachineReturns(result1 string, result2 error) {
	fake.findVirtualMachineMutex.Lock()
	defer fake.findVirtualMachineMutex.Unlock()
	fake.FindVirtualMachineStub = nil
	fake.findVirtualMachineReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *VCClient) FindVirtualMachineReturnsOnCall(i int, result1 string, result2 error) {
	fake.findVirtualMachineMutex.Lock()
	defer fake.findVirtualMachineMutex.Unlock()
	fake.FindVirtualMachineStub = nil
	if fake.findVirtualMachineReturnsOnCall == nil {
		fake.findVirtualMachineReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.findVirtualMachineReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *VCClient) GetAndValidateVirtualMachineTemplate(arg1 []string, arg2 string, arg3 string, arg4 string, arg5 tkgconfigreaderwriter.TKGConfigReaderWriter) (*types.VSphereVirtualMachine, error) {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.getAndValidateVirtualMachineTemplateMutex.Lock()
	ret, specificReturn := fake.getAndValidateVirtualMachineTemplateReturnsOnCall[len(fake.getAndValidateVirtualMachineTemplateArgsForCall)]
	fake.getAndValidateVirtualMachineTemplateArgsForCall = append(fake.getAndValidateVirtualMachineTemplateArgsForCall, struct {
		arg1 []string
		arg2 string
		arg3 string
		arg4 string
		arg5 tkgconfigreaderwriter.TKGConfigReaderWriter
	}{arg1Copy, arg2, arg3, arg4, arg5})
	stub := fake.GetAndValidateVirtualMachineTemplateStub
	fakeReturns := fake.getAndValidateVirtualMachineTemplateReturns
	fake.recordInvocation("GetAndValidateVirtualMachineTemplate", []interface{}{arg1Copy, arg2, arg3, arg4, arg5})
	fake.getAndValidateVirtualMachineTemplateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *VCClient) GetAndValidateVirtualMachineTemplateCallCount() int {
	fake.getAndValidateVirtualMachineTemplateMutex.RLock()
	defer fake.getAndValidateVirtualMachineTemplateMutex.RUnlock()
	return len(fake.getAndValidateVirtualMachineTemplateArgsForCall)
}

func (fake *VCClient) GetAndValidateVirtualMachineTemplateCalls(stub func([]string, string, string, string, tkgconfigreaderwriter.TKGConfigReaderWriter) (*types.VSphereVirtualMachine, error)) {
	fake.getAndValidateVirtualMachineTemplateMutex.Lock()
	defer fake.getAndValidateVirtualMachineTemplateMutex.Unlock()
	fake.GetAndValidateVirtualMachineTemplateStub = stub
}

func (fake *VCClient) GetAndValidateVirtualMachineTemplateArgsForCall(i int) ([]string, string, string, string, tkgconfigreaderwriter.TKGConfigReaderWriter) {
	fake.getAndValidateVirtualMachineTemplateMutex.RLock()
	defer fake.getAndValidateVirtualMachineTemplateMutex.RUnlock()
	argsForCall := fake.getAndValidateVirtualMachineTemplateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *VCClient) GetAndValidateVirtualMachineTemplateReturns(result1 *types.VSphereVirtualMachine, result2 error) {
	fake.getAndValidateVirtualMachineTemplateMutex.Lock()
	defer fake.getAndValidateVirtualMachineTemplateMutex.Unlock()
	fake.GetAndValidateVirtualMachineTemplateStub = nil
	fake.getAndValidateVirtualMachineTemplateReturns = struct {
		result1 *types.VSphereVirtualMachine
		result2 error
	}{result1, result2}
}

func (fake *VCClient) GetAndValidateVirtualMachineTemplateReturnsOnCall(i int, result1 *types.VSphereVirtualMachine, result2 error) {
	fake.getAndValidateVirtualMachineTemplateMutex.Lock()
	defer fake.getAndValidateVirtualMachineTemplateMutex.Unlock()
	fake.GetAndValidateVirtualMachineTemplateStub = nil
	if fake.getAndValidateVirtualMachineTemplateReturnsOnCall == nil {
		fake.getAndValidateVirtualMachineTemplateReturnsOnCall = make(map[int]struct {
			result1 *types.VSphereVirtualMachine
			result2 error
		})
	}
	fake.getAndValidateVirtualMachineTemplateReturnsOnCall[i] = struct {
		result1 *types.VSphereVirtualMachine
		result2 error
	}{result1, result2}
}

func (fake *VCClient) GetComputeResources(arg1 context.Context, arg2 string) ([]*models.VSphereManagementObject, error) {
	fake.getComputeResourcesMutex.Lock()
	ret, specificReturn := fake.getComputeResourcesReturnsOnCall[len(fake.getComputeResourcesArgsForCall)]
	fake.getComputeResourcesArgsForCall = append(fake.getComputeResourcesArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetComputeResourcesStub
	fakeReturns := fake.getComputeResourcesReturns
	fake.recordInvocation("GetComputeResources", []interface{}{arg1, arg2})
	fake.getComputeResourcesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *VCClient) GetComputeResourcesCallCount() int {
	fake.getComputeResourcesMutex.RLock()
	defer fake.getComputeResourcesMutex.RUnlock()
	return len(fake.getComputeResourcesArgsForCall)
}

func (fake *VCClient) GetComputeResourcesCalls(stub func(context.Context, string) ([]*models.VSphereManagementObject, error)) {
	fake.getComputeResourcesMutex.Lock()
	defer fake.getComputeResourcesMutex.Unlock()
	fake.GetComputeResourcesStub = stub
}

func (fake *VCClient) GetComputeResourcesArgsForCall(i int) (context.Context, string) {
	fake.getComputeResourcesMutex.RLock()
	defer fake.getComputeResourcesMutex.RUnlock()
	argsForCall := fake.getComputeResourcesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *VCClient) GetComputeResourcesReturns(result1 []*models.VSphereManagementObject, result2 error) {
	fake.getComputeResourcesMutex.Lock()
	defer fake.getComputeResourcesMutex.Unlock()
	fake.GetComputeResourcesStub = nil
	fake.getComputeResourcesReturns = struct {
		result1 []*models.VSphereManagementObject
		result2 error
	}{result1, result2}
}

func (fake *VCClient) GetComputeResourcesReturnsOnCall(i int, result1 []*models.VSphereManagementObject, result2 error) {
	fake.getComputeResourcesMutex.Lock()
	defer fake.getComputeResourcesMutex.Unlock()
	fake.GetComputeResourcesStub = nil
	if fake.getComputeResourcesReturnsOnCall == nil {
		fake.getComputeResourcesReturnsOnCall = make(map[int]struct {
			result1 []*models.VSphereManagementObject
			result2 error
		})
	}
	fake.getComputeResourcesReturnsOnCall[i] = struct {
		result1 []*models.VSphereManagementObject
		result2 error
	}{result1, result2}
}

func (fake *VCClient) GetDataCenterMOID(arg1 context.Context, arg2 string) (string, error) {
	fake.getDataCenterMOIDMutex.Lock()
	ret, specificReturn := fake.getDataCenterMOIDReturnsOnCall[len(fake.getDataCenterMOIDArgsForCall)]
	fake.getDataCenterMOIDArgsForCall = append(fake.getDataCenterMOIDArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetDataCenterMOIDStub
	fakeReturns := fake.getDataCenterMOIDReturns
	fake.recordInvocation("GetDataCenterMOID", []interface{}{arg1, arg2})
	fake.getDataCenterMOIDMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *VCClient) GetDataCenterMOIDCallCount() int {
	fake.getDataCenterMOIDMutex.RLock()
	defer fake.getDataCenterMOIDMutex.RUnlock()
	return len(fake.getDataCenterMOIDArgsForCall)
}

func (fake *VCClient) GetDataCenterMOIDCalls(stub func(context.Context, string) (string, error)) {
	fake.getDataCenterMOIDMutex.Lock()
	defer fake.getDataCenterMOIDMutex.Unlock()
	fake.GetDataCenterMOIDStub = stub
}

func (fake *VCClient) GetDataCenterMOIDArgsForCall(i int) (context.Context, string) {
	fake.getDataCenterMOIDMutex.RLock()
	defer fake.getDataCenterMOIDMutex.RUnlock()
	argsForCall := fake.getDataCenterMOIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *VCClient) GetDataCenterMOIDReturns(result1 string, result2 error) {
	fake.getDataCenterMOIDMutex.Lock()
	defer fake.getDataCenterMOIDMutex.Unlock()
	fake.GetDataCenterMOIDStub = nil
	fake.getDataCenterMOIDReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *VCClient) GetDataCenterMOIDReturnsOnCall(i int, result1 string, result2 error) {
	fake.getDataCenterMOIDMutex.Lock()
	defer fake.getDataCenterMOIDMutex.Unlock()
	fake.GetDataCenterMOIDStub = nil
	if fake.getDataCenterMOIDReturnsOnCall == nil {
		fake.getDataCenterMOIDReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getDataCenterMOIDReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *VCClient) GetDatacenters(arg1 context.Context) ([]*models.VSphereDatacenter, error) {
	fake.getDatacentersMutex.Lock()
	ret, specificReturn := fake.getDatacentersReturnsOnCall[len(fake.getDatacentersArgsForCall)]
	fake.getDatacentersArgsForCall = append(fake.getDatacentersArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.GetDatacentersStub
	fakeReturns := fake.getDatacentersReturns
	fake.recordInvocation("GetDatacenters", []interface{}{arg1})
	fake.getDatacentersMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *VCClient) GetDatacentersCallCount() int {
	fake.getDatacentersMutex.RLock()
	defer fake.getDatacentersMutex.RUnlock()
	return len(fake.getDatacentersArgsForCall)
}

func (fake *VCClient) GetDatacentersCalls(stub func(context.Context) ([]*models.VSphereDatacenter, error)) {
	fake.getDatacentersMutex.Lock()
	defer fake.getDatacentersMutex.Unlock()
	fake.GetDatacentersStub = stub
}

func (fake *VCClient) GetDatacentersArgsForCall(i int) context.Context {
	fake.getDatacentersMutex.RLock()
	defer fake.getDatacentersMutex.RUnlock()
	argsForCall := fake.getDatacentersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *VCClient) GetDatacentersReturns(result1 []*models.VSphereDatacenter, result2 error) {
	fake.getDatacentersMutex.Lock()
	defer fake.getDatacentersMutex.Unlock()
	fake.GetDatacentersStub = nil
	fake.getDatacentersReturns = struct {
		result1 []*models.VSphereDatacenter
		result2 error
	}{result1, result2}
}

func (fake *VCClient) GetDatacentersReturnsOnCall(i int, result1 []*models.VSphereDatacenter, result2 error) {
	fake.getDatacentersMutex.Lock()
	defer fake.getDatacentersMutex.Unlock()
	fake.GetDatacentersStub = nil
	if fake.getDatacentersReturnsOnCall == nil {
		fake.getDatacentersReturnsOnCall = make(map[int]struct {
			result1 []*models.VSphereDatacenter
			result2 error
		})
	}
	fake.getDatacentersReturnsOnCall[i] = struct {
		result1 []*models.VSphereDatacenter
		result2 error
	}{result1, result2}
}

func (fake *VCClient) GetDatastores(arg1 context.Context, arg2 string) ([]*models.VSphereDatastore, error) {
	fake.getDatastoresMutex.Lock()
	ret, specificReturn := fake.getDatastoresReturnsOnCall[len(fake.getDatastoresArgsForCall)]
	fake.getDatastoresArgsForCall = append(fake.getDatastoresArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetDatastoresStub
	fakeReturns := fake.getDatastoresReturns
	fake.recordInvocation("GetDatastores", []interface{}{arg1, arg2})
	fake.getDatastoresMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *VCClient) GetDatastoresCallCount() int {
	fake.getDatastoresMutex.RLock()
	defer fake.getDatastoresMutex.RUnlock()
	return len(fake.getDatastoresArgsForCall)
}

func (fake *VCClient) GetDatastoresCalls(stub func(context.Context, string) ([]*models.VSphereDatastore, error)) {
	fake.getDatastoresMutex.Lock()
	defer fake.getDatastoresMutex.Unlock()
	fake.GetDatastoresStub = stub
}

func (fake *VCClient) GetDatastoresArgsForCall(i int) (context.Context, string) {
	fake.getDatastoresMutex.RLock()
	defer fake.getDatastoresMutex.RUnlock()
	argsForCall := fake.getDatastoresArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *VCClient) GetDatastoresReturns(result1 []*models.VSphereDatastore, result2 error) {
	fake.getDatastoresMutex.Lock()
	defer fake.getDatastoresMutex.Unlock()
	fake.GetDatastoresStub = nil
	fake.getDatastoresReturns = struct {
		result1 []*models.VSphereDatastore
		result2 error
	}{result1, result2}
}

func (fake *VCClient) GetDatastoresReturnsOnCall(i int, result1 []*models.VSphereDatastore, result2 error) {
	fake.getDatastoresMutex.Lock()
	defer fake.getDatastoresMutex.Unlock()
	fake.GetDatastoresStub = nil
	if fake.getDatastoresReturnsOnCall == nil {
		fake.getDatastoresReturnsOnCall = make(map[int]struct {
			result1 []*models.VSphereDatastore
			result2 error
		})
	}
	fake.getDatastoresReturnsOnCall[i] = struct {
		result1 []*models.VSphereDatastore
		result2 error
	}{result1, result2}
}

func (fake *VCClient) GetFolders(arg1 context.Context, arg2 string) ([]*models.VSphereFolder, error) {
	fake.getFoldersMutex.Lock()
	ret, specificReturn := fake.getFoldersReturnsOnCall[len(fake.getFoldersArgsForCall)]
	fake.getFoldersArgsForCall = append(fake.getFoldersArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetFoldersStub
	fakeReturns := fake.getFoldersReturns
	fake.recordInvocation("GetFolders", []interface{}{arg1, arg2})
	fake.getFoldersMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *VCClient) GetFoldersCallCount() int {
	fake.getFoldersMutex.RLock()
	defer fake.getFoldersMutex.RUnlock()
	return len(fake.getFoldersArgsForCall)
}

func (fake *VCClient) GetFoldersCalls(stub func(context.Context, string) ([]*models.VSphereFolder, error)) {
	fake.getFoldersMutex.Lock()
	defer fake.getFoldersMutex.Unlock()
	fake.GetFoldersStub = stub
}

func (fake *VCClient) GetFoldersArgsForCall(i int) (context.Context, string) {
	fake.getFoldersMutex.RLock()
	defer fake.getFoldersMutex.RUnlock()
	argsForCall := fake.getFoldersArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *VCClient) GetFoldersReturns(result1 []*models.VSphereFolder, result2 error) {
	fake.getFoldersMutex.Lock()
	defer fake.getFoldersMutex.Unlock()
	fake.GetFoldersStub = nil
	fake.getFoldersReturns = struct {
		result1 []*models.VSphereFolder
		result2 error
	}{result1, result2}
}

func (fake *VCClient) GetFoldersReturnsOnCall(i int, result1 []*models.VSphereFolder, result2 error) {
	fake.getFoldersMutex.Lock()
	defer fake.getFoldersMutex.Unlock()
	fake.GetFoldersStub = nil
	if fake.getFoldersReturnsOnCall == nil {
		fake.getFoldersReturnsOnCall = make(map[int]struct {
			result1 []*models.VSphereFolder
			result2 error
		})
	}
	fake.getFoldersReturnsOnCall[i] = struct {
		result1 []*models.VSphereFolder
		result2 error
	}{result1, result2}
}

func (fake *VCClient) GetNetworks(arg1 context.Context, arg2 string) ([]*models.VSphereNetwork, error) {
	fake.getNetworksMutex.Lock()
	ret, specificReturn := fake.getNetworksReturnsOnCall[len(fake.getNetworksArgsForCall)]
	fake.getNetworksArgsForCall = append(fake.getNetworksArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetNetworksStub
	fakeReturns := fake.getNetworksReturns
	fake.recordInvocation("GetNetworks", []interface{}{arg1, arg2})
	fake.getNetworksMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *VCClient) GetNetworksCallCount() int {
	fake.getNetworksMutex.RLock()
	defer fake.getNetworksMutex.RUnlock()
	return len(fake.getNetworksArgsForCall)
}

func (fake *VCClient) GetNetworksCalls(stub func(context.Context, string) ([]*models.VSphereNetwork, error)) {
	fake.getNetworksMutex.Lock()
	defer fake.getNetworksMutex.Unlock()
	fake.GetNetworksStub = stub
}

func (fake *VCClient) GetNetworksArgsForCall(i int) (context.Context, string) {
	fake.getNetworksMutex.RLock()
	defer fake.getNetworksMutex.RUnlock()
	argsForCall := fake.getNetworksArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *VCClient) GetNetworksReturns(result1 []*models.VSphereNetwork, result2 error) {
	fake.getNetworksMutex.Lock()
	defer fake.getNetworksMutex.Unlock()
	fake.GetNetworksStub = nil
	fake.getNetworksReturns = struct {
		result1 []*models.VSphereNetwork
		result2 error
	}{result1, result2}
}

func (fake *VCClient) GetNetworksReturnsOnCall(i int, result1 []*models.VSphereNetwork, result2 error) {
	fake.getNetworksMutex.Lock()
	defer fake.getNetworksMutex.Unlock()
	fake.GetNetworksStub = nil
	if fake.getNetworksReturnsOnCall == nil {
		fake.getNetworksReturnsOnCall = make(map[int]struct {
			result1 []*models.VSphereNetwork
			result2 error
		})
	}
	fake.getNetworksReturnsOnCall[i] = struct {
		result1 []*models.VSphereNetwork
		result2 error
	}{result1, result2}
}

func (fake *VCClient) GetPath(arg1 context.Context, arg2 string) (string, []*models.VSphereManagementObject, error) {
	fake.getPathMutex.Lock()
	ret, specificReturn := fake.getPathReturnsOnCall[len(fake.getPathArgsForCall)]
	fake.getPathArgsForCall = append(fake.getPathArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetPathStub
	fakeReturns := fake.getPathReturns
	fake.recordInvocation("GetPath", []interface{}{arg1, arg2})
	fake.getPathMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *VCClient) GetPathCallCount() int {
	fake.getPathMutex.RLock()
	defer fake.getPathMutex.RUnlock()
	return len(fake.getPathArgsForCall)
}

func (fake *VCClient) GetPathCalls(stub func(context.Context, string) (string, []*models.VSphereManagementObject, error)) {
	fake.getPathMutex.Lock()
	defer fake.getPathMutex.Unlock()
	fake.GetPathStub = stub
}

func (fake *VCClient) GetPathArgsForCall(i int) (context.Context, string) {
	fake.getPathMutex.RLock()
	defer fake.getPathMutex.RUnlock()
	argsForCall := fake.getPathArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *VCClient) GetPathReturns(result1 string, result2 []*models.VSphereManagementObject, result3 error) {
	fake.getPathMutex.Lock()
	defer fake.getPathMutex.Unlock()
	fake.GetPathStub = nil
	fake.getPathReturns = struct {
		result1 string
		result2 []*models.VSphereManagementObject
		result3 error
	}{result1, result2, result3}
}

func (fake *VCClient) GetPathReturnsOnCall(i int, result1 string, result2 []*models.VSphereManagementObject, result3 error) {
	fake.getPathMutex.Lock()
	defer fake.getPathMutex.Unlock()
	fake.GetPathStub = nil
	if fake.getPathReturnsOnCall == nil {
		fake.getPathReturnsOnCall = make(map[int]struct {
			result1 string
			result2 []*models.VSphereManagementObject
			result3 error
		})
	}
	fake.getPathReturnsOnCall[i] = struct {
		result1 string
		result2 []*models.VSphereManagementObject
		result3 error
	}{result1, result2, result3}
}

func (fake *VCClient) GetResourcePools(arg1 context.Context, arg2 string) ([]*models.VSphereResourcePool, error) {
	fake.getResourcePoolsMutex.Lock()
	ret, specificReturn := fake.getResourcePoolsReturnsOnCall[len(fake.getResourcePoolsArgsForCall)]
	fake.getResourcePoolsArgsForCall = append(fake.getResourcePoolsArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetResourcePoolsStub
	fakeReturns := fake.getResourcePoolsReturns
	fake.recordInvocation("GetResourcePools", []interface{}{arg1, arg2})
	fake.getResourcePoolsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *VCClient) GetResourcePoolsCallCount() int {
	fake.getResourcePoolsMutex.RLock()
	defer fake.getResourcePoolsMutex.RUnlock()
	return len(fake.getResourcePoolsArgsForCall)
}

func (fake *VCClient) GetResourcePoolsCalls(stub func(context.Context, string) ([]*models.VSphereResourcePool, error)) {
	fake.getResourcePoolsMutex.Lock()
	defer fake.getResourcePoolsMutex.Unlock()
	fake.GetResourcePoolsStub = stub
}

func (fake *VCClient) GetResourcePoolsArgsForCall(i int) (context.Context, string) {
	fake.getResourcePoolsMutex.RLock()
	defer fake.getResourcePoolsMutex.RUnlock()
	argsForCall := fake.getResourcePoolsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *VCClient) GetResourcePoolsReturns(result1 []*models.VSphereResourcePool, result2 error) {
	fake.getResourcePoolsMutex.Lock()
	defer fake.getResourcePoolsMutex.Unlock()
	fake.GetResourcePoolsStub = nil
	fake.getResourcePoolsReturns = struct {
		result1 []*models.VSphereResourcePool
		result2 error
	}{result1, result2}
}

func (fake *VCClient) GetResourcePoolsReturnsOnCall(i int, result1 []*models.VSphereResourcePool, result2 error) {
	fake.getResourcePoolsMutex.Lock()
	defer fake.getResourcePoolsMutex.Unlock()
	fake.GetResourcePoolsStub = nil
	if fake.getResourcePoolsReturnsOnCall == nil {
		fake.getResourcePoolsReturnsOnCall = make(map[int]struct {
			result1 []*models.VSphereResourcePool
			result2 error
		})
	}
	fake.getResourcePoolsReturnsOnCall[i] = struct {
		result1 []*models.VSphereResourcePool
		result2 error
	}{result1, result2}
}

func (fake *VCClient) GetVSphereVersion() (string, string, error) {
	fake.getVSphereVersionMutex.Lock()
	ret, specificReturn := fake.getVSphereVersionReturnsOnCall[len(fake.getVSphereVersionArgsForCall)]
	fake.getVSphereVersionArgsForCall = append(fake.getVSphereVersionArgsForCall, struct {
	}{})
	stub := fake.GetVSphereVersionStub
	fakeReturns := fake.getVSphereVersionReturns
	fake.recordInvocation("GetVSphereVersion", []interface{}{})
	fake.getVSphereVersionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *VCClient) GetVSphereVersionCallCount() int {
	fake.getVSphereVersionMutex.RLock()
	defer fake.getVSphereVersionMutex.RUnlock()
	return len(fake.getVSphereVersionArgsForCall)
}

func (fake *VCClient) GetVSphereVersionCalls(stub func() (string, string, error)) {
	fake.getVSphereVersionMutex.Lock()
	defer fake.getVSphereVersionMutex.Unlock()
	fake.GetVSphereVersionStub = stub
}

func (fake *VCClient) GetVSphereVersionReturns(result1 string, result2 string, result3 error) {
	fake.getVSphereVersionMutex.Lock()
	defer fake.getVSphereVersionMutex.Unlock()
	fake.GetVSphereVersionStub = nil
	fake.getVSphereVersionReturns = struct {
		result1 string
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *VCClient) GetVSphereVersionReturnsOnCall(i int, result1 string, result2 string, result3 error) {
	fake.getVSphereVersionMutex.Lock()
	defer fake.getVSphereVersionMutex.Unlock()
	fake.GetVSphereVersionStub = nil
	if fake.getVSphereVersionReturnsOnCall == nil {
		fake.getVSphereVersionReturnsOnCall = make(map[int]struct {
			result1 string
			result2 string
			result3 error
		})
	}
	fake.getVSphereVersionReturnsOnCall[i] = struct {
		result1 string
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *VCClient) GetVirtualMachineImages(arg1 context.Context, arg2 string) ([]*types.VSphereVirtualMachine, error) {
	fake.getVirtualMachineImagesMutex.Lock()
	ret, specificReturn := fake.getVirtualMachineImagesReturnsOnCall[len(fake.getVirtualMachineImagesArgsForCall)]
	fake.getVirtualMachineImagesArgsForCall = append(fake.getVirtualMachineImagesArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetVirtualMachineImagesStub
	fakeReturns := fake.getVirtualMachineImagesReturns
	fake.recordInvocation("GetVirtualMachineImages", []interface{}{arg1, arg2})
	fake.getVirtualMachineImagesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *VCClient) GetVirtualMachineImagesCallCount() int {
	fake.getVirtualMachineImagesMutex.RLock()
	defer fake.getVirtualMachineImagesMutex.RUnlock()
	return len(fake.getVirtualMachineImagesArgsForCall)
}

func (fake *VCClient) GetVirtualMachineImagesCalls(stub func(context.Context, string) ([]*types.VSphereVirtualMachine, error)) {
	fake.getVirtualMachineImagesMutex.Lock()
	defer fake.getVirtualMachineImagesMutex.Unlock()
	fake.GetVirtualMachineImagesStub = stub
}

func (fake *VCClient) GetVirtualMachineImagesArgsForCall(i int) (context.Context, string) {
	fake.getVirtualMachineImagesMutex.RLock()
	defer fake.getVirtualMachineImagesMutex.RUnlock()
	argsForCall := fake.getVirtualMachineImagesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *VCClient) GetVirtualMachineImagesReturns(result1 []*types.VSphereVirtualMachine, result2 error) {
	fake.getVirtualMachineImagesMutex.Lock()
	defer fake.getVirtualMachineImagesMutex.Unlock()
	fake.GetVirtualMachineImagesStub = nil
	fake.getVirtualMachineImagesReturns = struct {
		result1 []*types.VSphereVirtualMachine
		result2 error
	}{result1, result2}
}

func (fake *VCClient) GetVirtualMachineImagesReturnsOnCall(i int, result1 []*types.VSphereVirtualMachine, result2 error) {
	fake.getVirtualMachineImagesMutex.Lock()
	defer fake.getVirtualMachineImagesMutex.Unlock()
	fake.GetVirtualMachineImagesStub = nil
	if fake.getVirtualMachineImagesReturnsOnCall == nil {
		fake.getVirtualMachineImagesReturnsOnCall = make(map[int]struct {
			result1 []*types.VSphereVirtualMachine
			result2 error
		})
	}
	fake.getVirtualMachineImagesReturnsOnCall[i] = struct {
		result1 []*types.VSphereVirtualMachine
		result2 error
	}{result1, result2}
}

func (fake *VCClient) GetVirtualMachines(arg1 context.Context, arg2 string) ([]*models.VSphereVirtualMachine, error) {
	fake.getVirtualMachinesMutex.Lock()
	ret, specificReturn := fake.getVirtualMachinesReturnsOnCall[len(fake.getVirtualMachinesArgsForCall)]
	fake.getVirtualMachinesArgsForCall = append(fake.getVirtualMachinesArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetVirtualMachinesStub
	fakeReturns := fake.getVirtualMachinesReturns
	fake.recordInvocation("GetVirtualMachines", []interface{}{arg1, arg2})
	fake.getVirtualMachinesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *VCClient) GetVirtualMachinesCallCount() int {
	fake.getVirtualMachinesMutex.RLock()
	defer fake.getVirtualMachinesMutex.RUnlock()
	return len(fake.getVirtualMachinesArgsForCall)
}

func (fake *VCClient) GetVirtualMachinesCalls(stub func(context.Context, string) ([]*models.VSphereVirtualMachine, error)) {
	fake.getVirtualMachinesMutex.Lock()
	defer fake.getVirtualMachinesMutex.Unlock()
	fake.GetVirtualMachinesStub = stub
}

func (fake *VCClient) GetVirtualMachinesArgsForCall(i int) (context.Context, string) {
	fake.getVirtualMachinesMutex.RLock()
	defer fake.getVirtualMachinesMutex.RUnlock()
	argsForCall := fake.getVirtualMachinesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *VCClient) GetVirtualMachinesReturns(result1 []*models.VSphereVirtualMachine, result2 error) {
	fake.getVirtualMachinesMutex.Lock()
	defer fake.getVirtualMachinesMutex.Unlock()
	fake.GetVirtualMachinesStub = nil
	fake.getVirtualMachinesReturns = struct {
		result1 []*models.VSphereVirtualMachine
		result2 error
	}{result1, result2}
}

func (fake *VCClient) GetVirtualMachinesReturnsOnCall(i int, result1 []*models.VSphereVirtualMachine, result2 error) {
	fake.getVirtualMachinesMutex.Lock()
	defer fake.getVirtualMachinesMutex.Unlock()
	fake.GetVirtualMachinesStub = nil
	if fake.getVirtualMachinesReturnsOnCall == nil {
		fake.getVirtualMachinesReturnsOnCall = make(map[int]struct {
			result1 []*models.VSphereVirtualMachine
			result2 error
		})
	}
	fake.getVirtualMachinesReturnsOnCall[i] = struct {
		result1 []*models.VSphereVirtualMachine
		result2 error
	}{result1, result2}
}

func (fake *VCClient) Login(arg1 context.Context, arg2 string, arg3 string) (string, error) {
	fake.loginMutex.Lock()
	ret, specificReturn := fake.loginReturnsOnCall[len(fake.loginArgsForCall)]
	fake.loginArgsForCall = append(fake.loginArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.LoginStub
	fakeReturns := fake.loginReturns
	fake.recordInvocation("Login", []interface{}{arg1, arg2, arg3})
	fake.loginMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *VCClient) LoginCallCount() int {
	fake.loginMutex.RLock()
	defer fake.loginMutex.RUnlock()
	return len(fake.loginArgsForCall)
}

func (fake *VCClient) LoginCalls(stub func(context.Context, string, string) (string, error)) {
	fake.loginMutex.Lock()
	defer fake.loginMutex.Unlock()
	fake.LoginStub = stub
}

func (fake *VCClient) LoginArgsForCall(i int) (context.Context, string, string) {
	fake.loginMutex.RLock()
	defer fake.loginMutex.RUnlock()
	argsForCall := fake.loginArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *VCClient) LoginReturns(result1 string, result2 error) {
	fake.loginMutex.Lock()
	defer fake.loginMutex.Unlock()
	fake.LoginStub = nil
	fake.loginReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *VCClient) LoginReturnsOnCall(i int, result1 string, result2 error) {
	fake.loginMutex.Lock()
	defer fake.loginMutex.Unlock()
	fake.LoginStub = nil
	if fake.loginReturnsOnCall == nil {
		fake.loginReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.loginReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *VCClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.acquireTicketMutex.RLock()
	defer fake.acquireTicketMutex.RUnlock()
	fake.checkUserSessionActiveMutex.RLock()
	defer fake.checkUserSessionActiveMutex.RUnlock()
	fake.detectPacificMutex.RLock()
	defer fake.detectPacificMutex.RUnlock()
	fake.findDataCenterMutex.RLock()
	defer fake.findDataCenterMutex.RUnlock()
	fake.findDatastoreMutex.RLock()
	defer fake.findDatastoreMutex.RUnlock()
	fake.findFolderMutex.RLock()
	defer fake.findFolderMutex.RUnlock()
	fake.findNetworkMutex.RLock()
	defer fake.findNetworkMutex.RUnlock()
	fake.findResourcePoolMutex.RLock()
	defer fake.findResourcePoolMutex.RUnlock()
	fake.findVirtualMachineMutex.RLock()
	defer fake.findVirtualMachineMutex.RUnlock()
	fake.getAndValidateVirtualMachineTemplateMutex.RLock()
	defer fake.getAndValidateVirtualMachineTemplateMutex.RUnlock()
	fake.getComputeResourcesMutex.RLock()
	defer fake.getComputeResourcesMutex.RUnlock()
	fake.getDataCenterMOIDMutex.RLock()
	defer fake.getDataCenterMOIDMutex.RUnlock()
	fake.getDatacentersMutex.RLock()
	defer fake.getDatacentersMutex.RUnlock()
	fake.getDatastoresMutex.RLock()
	defer fake.getDatastoresMutex.RUnlock()
	fake.getFoldersMutex.RLock()
	defer fake.getFoldersMutex.RUnlock()
	fake.getNetworksMutex.RLock()
	defer fake.getNetworksMutex.RUnlock()
	fake.getPathMutex.RLock()
	defer fake.getPathMutex.RUnlock()
	fake.getResourcePoolsMutex.RLock()
	defer fake.getResourcePoolsMutex.RUnlock()
	fake.getVSphereVersionMutex.RLock()
	defer fake.getVSphereVersionMutex.RUnlock()
	fake.getVirtualMachineImagesMutex.RLock()
	defer fake.getVirtualMachineImagesMutex.RUnlock()
	fake.getVirtualMachinesMutex.RLock()
	defer fake.getVirtualMachinesMutex.RUnlock()
	fake.loginMutex.RLock()
	defer fake.loginMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *VCClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ vc.Client = new(VCClient)
