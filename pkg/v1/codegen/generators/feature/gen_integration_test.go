// Copyright 2021 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package feature

import (
	"io/ioutil"
	"os"

	. "github.com/onsi/ginkgo"
	. "github.com/onsi/gomega"
	"sigs.k8s.io/controller-tools/pkg/genall"
	"sigs.k8s.io/controller-tools/pkg/loader"
	"sigs.k8s.io/controller-tools/pkg/markers"
	"sigs.k8s.io/yaml"

	configv1alpha1 "github.com/vmware-tanzu/tanzu-framework/apis/config/v1alpha1"
)

var _ = Describe("Feature CR generated by the Feature Generator", func() {
	It("should generate only one Feature CR", func() {
		cwd, err := os.Getwd()
		Expect(err).NotTo(HaveOccurred())
		Expect(os.Chdir("./fakeData")).To(Succeed())
		defer func() { Expect(os.Chdir(cwd)).To(Succeed()) }()

		By("loading the roots")
		pkgs, err := loader.LoadRoots("./mykind_types.go")
		Expect(err).NotTo(HaveOccurred())

		By("registering Feature rule marker")
		reg := &markers.Registry{}
		Expect(reg.Register(RuleDefinition)).To(Succeed())

		By("creating GenerationContext")
		ctx := &genall.GenerationContext{
			Collector: &markers.Collector{Registry: reg},
			Roots:     pkgs,
		}

		By("generating a Feature")
		features := generateFeatures(ctx)
		Expect(err).NotTo(HaveOccurred())
		Expect(len(features)).To(Equal(1))

		By("loading the desired YAML")
		fooFeatureCRBytes, err := ioutil.ReadFile("./foo.yaml")
		Expect(err).NotTo(HaveOccurred())

		By("comparing the generated Feature and expected Feature")
		feature := features[0]
		var expectedFooFeature configv1alpha1.Feature
		Expect(yaml.Unmarshal(fooFeatureCRBytes, &expectedFooFeature)).To(Succeed())
		Expect(feature).To(Equal(expectedFooFeature))
	})

	It("should generate multiple Feature CRs", func() {
		cwd, err := os.Getwd()
		Expect(err).NotTo(HaveOccurred())
		Expect(os.Chdir("./fakeData")).To(Succeed())
		defer func() { Expect(os.Chdir(cwd)).To(Succeed()) }()

		By("loading the roots")
		pkgs, err := loader.LoadRoots("./cronjob_types.go")
		Expect(err).NotTo(HaveOccurred())

		By("registering Feature rule marker")
		reg := &markers.Registry{}
		Expect(reg.Register(RuleDefinition)).To(Succeed())

		By("creating GenerationContext")
		ctx := &genall.GenerationContext{
			Collector: &markers.Collector{Registry: reg},
			Roots:     pkgs,
		}

		By("generating a Feature")
		features := generateFeatures(ctx)
		Expect(err).NotTo(HaveOccurred())
		Expect(len(features)).To(Equal(2))

		By("loading the desired YAML")
		barFeatureCRBytes, err := ioutil.ReadFile("./bar.yaml")
		Expect(err).NotTo(HaveOccurred())
		bazFeatureCRBytes, err := ioutil.ReadFile("./baz.yaml")
		Expect(err).NotTo(HaveOccurred())

		By("comparing the generated Features and expected Features")
		barFeature := features[0]
		var expectedBarFeature configv1alpha1.Feature
		Expect(yaml.Unmarshal(barFeatureCRBytes, &expectedBarFeature)).To(Succeed())
		Expect(barFeature).To(Equal(expectedBarFeature))

		bazFeature := features[1]
		var expectedBazFeature configv1alpha1.Feature
		Expect(yaml.Unmarshal(bazFeatureCRBytes, &expectedBazFeature)).To(Succeed())
		Expect(bazFeature).To(Equal(expectedBazFeature))
	})

	It("should not generate any Feature CR", func() {
		cwd, err := os.Getwd()
		Expect(err).NotTo(HaveOccurred())
		Expect(os.Chdir("./fakeData")).To(Succeed())
		defer func() { Expect(os.Chdir(cwd)).To(Succeed()) }()

		By("loading the roots")
		pkgs, err := loader.LoadRoots("./memcached_types.go")
		Expect(err).NotTo(HaveOccurred())

		By("registering Feature rule marker")
		reg := &markers.Registry{}
		Expect(reg.Register(RuleDefinition)).To(Succeed())

		By("creating GenerationContext")
		ctx := &genall.GenerationContext{
			Collector: &markers.Collector{Registry: reg},
			Roots:     pkgs,
		}

		By("generating a Feature")
		features := generateFeatures(ctx)
		Expect(err).NotTo(HaveOccurred())
		Expect(len(features)).To(BeZero())
	})
})
